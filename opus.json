{"directories": ["sys/init", "sys/boot", "sys/autorun", "sys/etc", "sys/modules", "sys/apps", "sys/help", "sys/modules/opus", "sys/modules/opus/ui", "sys/modules/opus/crypto", "sys/modules/opus/compress", "sys/modules/opus/http", "sys/modules/opus/fs", "sys/modules/opus/ui/components", "sys/modules/opus/crypto/ecc", "sys/apps/network", "sys/apps/system"], "sources": {"startup.lua": "--[[\n\t.startup.boot\n\t\tdelay\n\t\t\tdescription:\tdelays amount before starting the default selection\n\t\t\tdefault:\t\t1.5\n\n\t\tpreload\n\t\t\tdescription :\truns before menu is displayed, can be used for password\n\t\t\t\t\t\t\tlocking, drive encryption, etc.\n\t\t\texample :\t\t{ [1] = '/path/somefile.lua', [2] = 'path2/another.lua' }\n\n\t\tmenu\n\t\t\tdescription:\tarray of menu entries (see .startup.boot for examples)\n]]\n\nlocal colors    = _G.colors\nlocal fs        = _G.fs\nlocal keys      = _G.keys\nlocal os        = _G.os\nlocal settings  = _G.settings\nlocal term      = _G.term\nlocal textutils = _G.textutils\n\nlocal function loadBootOptions()\n\tif not fs.exists('.startup.boot') then\n\t\tlocal f = fs.open('.startup.boot', 'w')\n\t\tf.write(textutils.serialize({\n\t\t\tdelay = 1.5,\n\t\t\tpreload = { },\n\t\t\tmenu = {\n\t\t\t\t{ prompt = os.version() },\n\t\t\t\t{ prompt = 'Opus'         , args = { '/sys/boot/opus.lua' } },\n\t\t\t\t{ prompt = 'Opus Shell'   , args = { '/sys/boot/opus.lua', '/sys/apps/shell.lua' } },\n\t\t\t\t{ prompt = 'Opus Kiosk'   , args = { '/sys/boot/kiosk.lua' } },\n\t\t\t\t{ prompt = 'Opus TLCO'    , args = { '/sys/boot/tlco.lua' } },\n\t\t\t},\n\t\t}))\n\t\tf.close()\n\tend\n\n\tlocal f = fs.open('.startup.boot', 'r')\n\tlocal options = textutils.unserialize(f.readAll())\n\tf.close()\n\n\t-- Backwards compatibility for .startup.boot files created before sys/boot files' extensions were changed\n\tlocal changed = false\n\tfor _, item in pairs(options.menu) do\n\t\tif item.args and item.args[1]:match(\"/?sys/boot/%l+%.boot\") then\n\t\t\titem.args[1] = item.args[1]:gsub(\"%.boot\", \"%.lua\")\n\t\t\tchanged = true\n\t\tend\n\tend\n\tif changed then \n\t\tlocal f = fs.open(\".startup.boot\", \"w\")\n\t\tf.write(textutils.serialize(options))\n\t\tf.close()\n\tend\n\n\treturn options\nend\n\nlocal bootOptions = loadBootOptions()\n\nlocal bootOption = 2\nif settings then\n\tsettings.load('.settings')\n\tbootOption = tonumber(settings.get('opus.boot_option')) or bootOption\nend\n\nlocal function startupMenu()\n\tlocal x, y = term.getSize()\n\tlocal align, selected = 0, bootOption\n\n\tlocal function redraw()\n\t\tlocal title = \"Boot Options:\"\n\t\tterm.clear()\n\t\tterm.setTextColor(colors.white)\n\t\tterm.setCursorPos((x/2)-(#title/2), (y/2)-(#bootOptions.menu/2)-1)\n\t\tterm.write(title)\n\t\tfor i, item in pairs(bootOptions.menu) do\n\t\t\tlocal txt = i .. \". \" .. item.prompt\n\t\t\tterm.setCursorPos((x/2)-(align/2), (y/2)-(#bootOptions.menu/2)+i)\n\t\t\tterm.write(txt)\n\t\tend\n\tend\n\n\tfor _, item in pairs(bootOptions.menu) do\n\t\tif #item.prompt > align then\n\t\t\talign = #item.prompt\n\t\tend\n\tend\n\n\tredraw()\n\twhile true do\n\t\tterm.setCursorPos((x/2)-(align/2)-2, (y/2)-(#bootOptions.menu/2)+selected)\n\t\tterm.setTextColor(term.isColor() and colors.yellow or colors.lightGray)\n\n\t\tterm.write(\">\")\n\t\tlocal event, key = os.pullEvent()\n\t\tif event == \"mouse_scroll\" then\n\t\t\tkey = key == 1 and keys.down or keys.up\n\t\telseif event == 'key_up' then\n\t\t\tkey = nil  -- only process key events\n\t\tend\n\n\t\tif key == keys.enter or key == keys.right then\n\t\t\treturn selected\n\t\telseif key == keys.down then\n\t\t\tif selected == #bootOptions.menu then\n\t\t\t\tselected = 0\n\t\t\tend\n\t\t\tselected = selected + 1\n\t\telseif key == keys.up then\n\t\t\tif selected == 1 then\n\t\t\t\tselected = #bootOptions.menu + 1\n\t\t\tend\n\t\t\tselected = selected - 1\n\t\telseif event == 'char' then\n\t\t\tkey = tonumber(key) or 0\n\t\t\tif bootOptions.menu[key] then\n\t\t\t\treturn key\n\t\t\tend\n\t\tend\n\n\t\tlocal cx, cy = term.getCursorPos()\n\t\tterm.setCursorPos(cx-1, cy)\n\t\tterm.write(\" \")\n\tend\nend\n\nlocal function splash()\n\tlocal w, h = term.current().getSize()\n\n\tterm.setTextColor(colors.white)\n\tif not term.isColor() then\n\t\tlocal str = 'Opus OS'\n\t\tterm.setCursorPos((w - #str) / 2, h / 2)\n\t\tterm.write(str)\n\telse\n\t\tterm.setBackgroundColor(colors.black)\n\t\tterm.clear()\n\t\tlocal opus = {\n\t\t\t'fffff00',\n\t\t\t'ffff07000',\n\t\t\t'ff00770b00f4444',\n\t\t\t'ff077777444444444',\n\t\t\t'f07777744444444444',\n\t\t\t'f0000777444444444',\n\t\t\t'070000111744444',\n\t\t\t'777770000',\n\t\t\t'7777000000',\n\t\t\t'70700000000',\n\t\t\t'077000000000',\n\t\t}\n\t\tfor k,line in ipairs(opus) do\n\t\t\tterm.setCursorPos((w - 18) / 2, k + (h - #opus) / 2)\n\t\t\tterm.blit(string.rep(' ', #line), string.rep('a', #line), line)\n\t\tend\n\tend\n\n\tlocal str = 'Press any key for menu'\n\tterm.setCursorPos((w - #str) / 2, h)\n\tterm.write(str)\nend\n\nfor _, v in pairs(bootOptions.preload) do\n\tos.run(_ENV, v)\nend\n\nterm.clear()\nsplash()\n\nlocal timerId = os.startTimer(bootOptions.delay)\nwhile true do\n\tlocal e, id = os.pullEvent()\n\tif e == 'timer' and id == timerId then\n\t\tbreak\n\tend\n\tif e == 'char' or e == 'key' then\n\t\tbootOption = startupMenu()\n\t\tif settings then\n\t\t\tsettings.set('opus.boot_option', bootOption)\n\t\t\tsettings.save('.settings')\n\t\tend\n\t\tbreak\n\tend\nend\n\nterm.clear()\nterm.setCursorPos(1, 1)\nif bootOptions.menu[bootOption].args then\n\tos.run(_ENV, table.unpack(bootOptions.menu[bootOption].args))\nelse\n\tprint(bootOptions.menu[bootOption].prompt)\nend\n\n", "LICENSE.md": "MIT License\n\nCopyright (c) 2016-2019 kepler155c\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n", "sys/kernel.lua": "local Array    = require('opus.array')\nlocal Terminal = require('opus.terminal')\nlocal trace    = require('opus.trace')\nlocal Util     = require('opus.util')\n\n_G.kernel = {\n\tUID = 0,\n\thooks = { },\n\troutines = { },\n}\n\nlocal fs     = _G.fs\nlocal kernel = _G.kernel\nlocal os     = _G.os\nlocal shell  = _ENV.shell\nlocal term   = _G.term\nlocal window = _G.window\n\nlocal w, h = term.getSize()\nkernel.terminal = term.current()\n\nkernel.window = Terminal.window(kernel.terminal, 1, 1, w, h, false)\nkernel.window.setMaxScroll(200)\n\nlocal focusedRoutineEvents = Util.transpose {\n\t'char', 'key', 'key_up',\n\t'mouse_click', 'mouse_drag', 'mouse_scroll', 'mouse_up',\n\t'paste', 'terminate',\n}\n\n_G._syslog = function(pattern, ...)\n\tkernel.window.scrollBottom()\n\tkernel.window.print(Util.tostring(pattern, ...))\nend\n\n-- any function that runs in a kernel hook does not run in\n-- a separate coroutine or have a window. an error in a hook\n-- function will crash the system.\nfunction kernel.hook(event, fn)\n\tif type(event) == 'table' then\n\t\tfor _,v in pairs(event) do\n\t\t\tkernel.hook(v, fn)\n\t\tend\n\telse\n\t\tif not kernel.hooks[event] then\n\t\t\tkernel.hooks[event] = { }\n\t\tend\n\t\ttable.insert(kernel.hooks[event], fn)\n\tend\nend\n\n-- you *should* only unhook from within the function that hooked\nfunction kernel.unhook(event, fn)\n\tif type(event) == 'table' then\n\t\tfor _,v in pairs(event) do\n\t\t\tkernel.unhook(v, fn)\n\t\tend\n\telse\n\t\tlocal eventHooks = kernel.hooks[event]\n\t\tif eventHooks then\n\t\t\tArray.removeByValue(eventHooks, fn)\n\t\t\tif #eventHooks == 0 then\n\t\t\t\tkernel.hooks[event] = nil\n\t\t\tend\n\t\tend\n\tend\nend\n\nlocal function switch(routine, previous)\n\tif routine then\n\t\tif previous and previous.window then\n\t\t\tprevious.window.setVisible(false)\n\t\t\tif previous.hidden then\n\t\t\t\tkernel.lower(previous.uid)\n\t\t\tend\n\t\tend\n\n\t\tif routine and routine.window then\n\t\t\troutine.window.setVisible(true)\n\t\tend\n\n\t\tos.queueEvent('kernel_focus', routine.uid, previous and previous.uid)\n\tend\nend\n\nlocal Routine = { }\n\nfunction Routine:resume(event, ...)\n\tif not self.co or coroutine.status(self.co) == 'dead' then\n\t\treturn\n\tend\n\n\tif not self.filter or self.filter == event or event == \"terminate\" then\n\t\tlocal previousTerm = term.redirect(self.terminal)\n\n\t\tlocal previous = kernel.running\n\t\tkernel.running = self\n\t\tlocal ok, result = coroutine.resume(self.co, event, ...)\n\t\tkernel.running = previous\n\n\t\tself.filter = result\n\t\tself.terminal = term.current()\n\t\tterm.redirect(previousTerm)\n\n\t\treturn ok, result\n\tend\nend\n\nfunction Routine:run()\n\tself.co = self.co or coroutine.create(function()\n\t\tlocal result, err, fn, stack\n\n\t\tif self.fn then\n\t\t\tfn = self.fn\n\t\t\t_G.setfenv(fn, self.env)\n\t\telseif self.path then\n\t\t\tfn, err = loadfile(self.path, self.env)\n\t\telseif self.chunk then\n\t\t\tfn, err = load(self.chunk, self.title, nil, self.env)\n\t\tend\n\n\t\tif fn then\n\t\t\tresult, err, stack = trace(fn, table.unpack(self.args or { } ))\n\t\telse\n\t\t\terr = err or 'kernel: invalid routine'\n\t\tend\n\n\t\tpcall(self.onExit, self, result, err, stack)\n\t\tself:cleanup()\n\n\t\tif not result then\n\t\t\terror(err)\n\t\tend\n\tend)\n\n\ttable.insert(kernel.routines, self)\n\n\treturn self:resume()\nend\n\n-- override if any post processing is required\nfunction Routine:onExit(status, message) -- self, status, message\n\tif not status and message ~= 'Terminated' then\n\t\t_G.printError(message)\n\tend\nend\n\nfunction Routine:cleanup()\n\tArray.removeByValue(kernel.routines, self)\n\tif #kernel.routines > 0 then\n\t\tswitch(kernel.routines[1])\n\tend\nend\n\nfunction kernel.getFocused()\n\treturn kernel.routines[1]\nend\n\nfunction kernel.getCurrent()\n\treturn kernel.running\nend\n\nfunction kernel.getShell()\n\treturn shell\nend\n\n-- each routine inherits the parent's env\nfunction kernel.makeEnv(env, dir)\n\tenv = setmetatable(Util.shallowCopy(env or _ENV), { __index = _G })\n\t_G.requireInjector(env, dir)\n\treturn env\nend\n\nfunction kernel.newRoutine(env, args)\n\tkernel.UID = kernel.UID + 1\n\n\tlocal routine = setmetatable({\n\t\tuid = kernel.UID,\n\t\ttimestamp = os.clock(),\n\t\twindow = kernel.window,\n\t\ttitle = 'untitled',\n\t}, { __index = Routine })\n\n\tUtil.merge(routine, args)\n\troutine.env = args.env or kernel.makeEnv(env, routine.path and fs.getDir(routine.path))\n\troutine.terminal = routine.terminal or routine.window\n\n\treturn routine\nend\n\nfunction kernel.run(env, args)\n\tlocal routine = kernel.newRoutine(env, args)\n\tlocal s, m = routine:run()\n\treturn s and routine, m\nend\n\nfunction kernel.raise(uid)\n\tif kernel.getFocused() and kernel.getFocused().pinned then\n\t\treturn false\n\tend\n\n\tlocal routine = Util.find(kernel.routines, 'uid', uid)\n\n\tif routine then\n\t\tlocal previous = kernel.routines[1]\n\t\tif routine ~= previous then\n\t\t\tArray.removeByValue(kernel.routines, routine)\n\t\t\ttable.insert(kernel.routines, 1, routine)\n\t\tend\n\n\t\tswitch(routine, previous)\n\t\treturn true\n\tend\n\treturn false\nend\n\nfunction kernel.lower(uid)\n\tlocal routine = Util.find(kernel.routines, 'uid', uid)\n\n\tif routine and #kernel.routines > 1 then\n\t\tif routine == kernel.routines[1] then\n\t\t\tlocal nextRoutine = kernel.routines[2]\n\t\t\tif nextRoutine then\n\t\t\t\tkernel.raise(nextRoutine.uid)\n\t\t\tend\n\t\tend\n\n\t\tArray.removeByValue(kernel.routines, routine)\n\t\ttable.insert(kernel.routines, routine)\n\t\treturn true\n\tend\n\treturn false\nend\n\nfunction kernel.find(uid)\n\treturn Util.find(kernel.routines, 'uid', uid)\nend\n\nfunction kernel.halt(status, message)\n\tos.queueEvent('kernel_halt', status, message)\nend\n\nfunction kernel.event(event, eventData)\n\tlocal stopPropagation\n\n\tlocal eventHooks = kernel.hooks['*']\n\tif eventHooks then\n\t\tfor i = #eventHooks, 1, -1 do\n\t\t\tstopPropagation = eventHooks[i](event, eventData)\n\t\t\tif stopPropagation then\n\t\t\t\tbreak\n\t\t\tend\n\t\tend\n\tend\n\n\teventHooks = kernel.hooks[event]\n\tif eventHooks then\n\t\tfor i = #eventHooks, 1, -1 do\n\t\t\tstopPropagation = eventHooks[i](event, eventData)\n\t\t\tif stopPropagation then\n\t\t\t\tbreak\n\t\t\tend\n\t\tend\n\tend\n\n\tif not stopPropagation then\n\t\tif focusedRoutineEvents[event] then\n\t\t\tlocal active = kernel.routines[1]\n\t\t\tif active then\n\t\t\t\tactive:resume(event, table.unpack(eventData))\n\t\t\tend\n\t\telse\n\t\t\t-- Passthrough to all processes\n\t\t\tfor _,routine in pairs(Util.shallowCopy(kernel.routines)) do\n\t\t\t\troutine:resume(event, table.unpack(eventData))\n\t\t\tend\n\t\tend\n\tend\nend\n\nfunction kernel.start()\n\tlocal s, m\n\tlocal s2, m2 = pcall(function()\n\t\trepeat\n\t\t\tlocal eventData = { os.pullEventRaw() }\n\t\t\tlocal event = table.remove(eventData, 1)\n\t\t\tkernel.event(event, eventData)\n\t\t\tif event == 'kernel_halt' then\n\t\t\t\ts = eventData[1]\n\t\t\t\tm = eventData[2]\n\t\t\tend\n\t\tuntil event == 'kernel_halt'\n\tend)\n\n\tif (not s and m) or (not s2 and m2) then\n\t\tkernel.window.setVisible(true)\n\t\tterm.redirect(kernel.window)\n\t\tprint('\\nCrash detected\\n')\n\t\t_G.printError(m or m2)\n\tend\n\tterm.redirect(kernel.terminal)\nend\n\nlocal function init(...)\n\tlocal args = { ... }\n\n\tlocal runLevel = #args > 0 and 6 or 7\n\n\tprint('Starting Opus OS')\n\tlocal dir = 'sys/init'\n\tlocal files = fs.list(dir)\n\ttable.sort(files)\n\tfor _,file in ipairs(files) do\n\t\tlocal level = file:match('(%d).%S+.lua') or 99\n\t\tif tonumber(level) <= runLevel then\n\t\t\t-- All init programs run under the original shell\n\t\t\tlocal s, m = shell.run(fs.combine(dir, file))\n\t\t\tif not s then\n\t\t\t\terror(m, -1)\n\t\t\tend\n\t\t\tos.sleep(0)\n\t\tend\n\tend\n\n\tos.queueEvent('kernel_ready')\n\n\tif args[1] then\n\t\tkernel.hook('kernel_ready', function()\n\n\t\t\tterm.redirect(kernel.window)\n\t\t\tshell.run('sys/apps/autorun.lua')\n\n\t\t\tlocal win = window.create(kernel.terminal, 1, 1, w, h, true)\n\t\t\tlocal s, m = kernel.run(_ENV, {\n\t\t\t\ttitle = args[1],\n\t\t\t\tpath = 'sys/apps/shell.lua',\n\t\t\t\targs = args,\n\t\t\t\twindow = win,\n\t\t\t\tonExit = function(_, s, m)\n\t\t\t\t\tkernel.halt(s, m)\n\t\t\t\tend,\n\t\t\t})\n\t\t\tif s then\n\t\t\t\tkernel.raise(s.uid)\n\t\t\telse\n\t\t\t\terror(m)\n\t\t\tend\n\t\tend)\n\tend\nend\n\nkernel.run(_ENV, {\n\tfn = init,\n\ttitle = 'init',\n\targs = { ... },\n\tonExit = function(_, status, message)\n\t\tif not status then\n\t\t\tkernel.halt(status, message)\n\t\tend\n\tend,\n})\n\nkernel.start()\n", "sys/init/4.user.lua": "local Util = require('opus.util')\n\nlocal fs    = _G.fs\nlocal shell = _ENV.shell\n\nif not fs.exists('usr/apps') then\n\tfs.makeDir('usr/apps')\nend\nif not fs.exists('usr/autorun') then\n\tfs.makeDir('usr/autorun')\nend\n\n-- move the fstab out of config so that the config directory\n-- can be remapped to another disk (and for consistency)\nif fs.exists('usr/config/fstab') and not fs.exists('usr/etc/fstab') then\n\tfs.move('usr/config/fstab', 'usr/etc/fstab')\nend\nfs.loadTab('usr/etc/fstab')\n\n-- TODO: Temporary\nlocal upgrade = Util.readTable('usr/config/shell')\nif upgrade and (not upgrade.upgraded or upgrade.upgraded ~= 1) then\n\tfs.delete('usr/config/shell')\nend\n\nif not fs.exists('usr/config/shell') then\n\tUtil.writeTable('usr/config/shell', {\n\t\taliases  = shell.aliases(),\n\t\tpath     = '/usr/apps',\n\t\tlua_path = package.path,\n\t\tupgraded = 1,\n\t})\nend\n\nlocal config = Util.readTable('usr/config/shell')\nif config.aliases then\n\tfor k in pairs(shell.aliases()) do\n\t\tshell.clearAlias(k)\n\tend\n\tfor k,v in pairs(config.aliases) do\n\t\tshell.setAlias(k, v)\n\tend\nend\n\nlocal path = config.path and Util.split(config.path, '(.-):') or { }\ntable.insert(path, '/sys/apps')\nfor _, v in pairs(Util.split(shell.path(), '(.-):')) do\n\ttable.insert(path, v)\nend\n\nshell.setPath(table.concat(path, ':'))\n\n--_G.LUA_PATH = config.lua_path\n--_G.settings.set('mbs.shell.require_path', config.lua_path)\n", "sys/init/4.label.lua": "local os         = _G.os\nlocal peripheral = _G.peripheral\n\n-- Default label\nif not os.getComputerLabel() then\n\tlocal id = os.getComputerID()\n\n\tif _G.turtle then\n\t\tos.setComputerLabel('turtle_' .. id)\n\n\telseif _G.pocket then\n\t\tos.setComputerLabel('pocket_' .. id)\n\n\telseif _G.commands then\n\t\tos.setComputerLabel('command_' .. id)\n\n\telseif peripheral.find('neuralInterface') then\n\t\tos.setComputerLabel('neural_' .. id)\n\n\telse\n\t\tos.setComputerLabel('computer_' .. id)\n\tend\nend\n", "sys/init/3.relay.lua": "local device     = _G.device\nlocal kernel     = _G.kernel\n\nlocal function register(v)\n\tif v and v.isWireless and v.isAccessPoint and v.getNamesRemote then\n\t\tv._children = { }\n\t\tfor _, name in pairs(v.getNamesRemote()) do\n\t\t\tlocal dev = v.getMethodsRemote(name)\n\t\t\tif dev then\n\t\t\t\tdev.name = name\n\t\t\t\tdev.side = v.side\n\t\t\t\tdev.type = v.getTypeRemote(name)\n\t\t\t\tdevice[name] = dev\n\t\t\tend\n\t\tend\n\tend\nend\n\nfor _,v in pairs(device) do\n\tregister(v)\nend\n\n-- register oc devices as peripherals\nkernel.hook('device_attach', function(_, eventData)\n\tregister(device[eventData[1]])\nend)\n", "sys/init/5.network.lua": "local Config = require('opus.config')\n\nlocal device     = _G.device\nlocal kernel     = _G.kernel\nlocal os         = _G.os\n\ndo\n\tlocal config = Config.load('os')\n\t_G.network = setmetatable({ }, { __index = {\n\t\tgetGroup = function() return config.group end,\n\t\tsetGroup = function(name)\n\t\t\tconfig.group = name\n\t\tend\n\t}})\nend\n\nlocal function startNetwork()\n\tkernel.run(_ENV, {\n\t\ttitle = 'Net daemon',\n\t\tpath = 'sys/apps/netdaemon.lua',\n\t\thidden = true,\n\t})\nend\n\nlocal function setModem(dev)\n\tif not device.wireless_modem and dev.isWireless() then\n\t\tlocal config = Config.load('os')\n\n\t\tif not config.wirelessModem or\n\t\t\tconfig.wirelessModem == 'auto' or\n\t\t\tdev.name == config.wirelessModem then\n\n\t\t\tdevice.wireless_modem = dev\n\t\t\tos.queueEvent('device_attach', 'wireless_modem')\n\t\t\treturn dev\n\t\tend\n\tend\nend\n\n-- create a psuedo-device named 'wireless_modem'\nkernel.hook('device_attach', function(_, eventData)\n\tlocal dev = device[eventData[1]]\n\tif dev and dev.type == 'modem' then\n\t\tif setModem(dev) then\n\t\t\tstartNetwork()\n\t\tend\n\tend\nend)\n\nkernel.hook('device_detach', function(_, eventData)\n\tif device.wireless_modem and eventData[1] == device.wireless_modem.name then\n\t\tdevice['wireless_modem'] = nil\n\t\tos.queueEvent('device_detach', 'wireless_modem')\n\tend\nend)\n\nfor _,dev in pairs(device) do\n\tif dev.type == 'modem' then\n\t\tif setModem(dev) then\n\t\t\tbreak\n\t\tend\n\tend\nend\n\nif device.wireless_modem then\n\tprint('waiting for network...')\n\tstartNetwork()\n\tos.pullEvent('network_up')\nend\n", "sys/init/2.vfs.lua": "local fs = _G.fs\n\nif fs.native then\n\treturn\nend\n\nlocal Util = require('opus.util')\n\nfs.native = Util.shallowCopy(fs)\n\nlocal fstypes = { }\nlocal nativefs = { }\n\nfor k,fn in pairs(fs) do\n\tif type(fn) == 'function' then\n\t\tnativefs[k] = function(_, ...)\n\t\t\treturn fn(...)\n\t\tend\n\tend\nend\n\nfunction nativefs.resolve(_, dir)\n\treturn dir\nend\n\nfunction nativefs.list(node, dir)\n\tlocal files\n\tif fs.native.isDir(dir) then\n\t\tfiles = fs.native.list(dir)\n\tend\n\n\tlocal function inList(l, e)\n\t\tfor _,v in ipairs(l) do\n\t\t\tif v == e then\n\t\t\t\treturn true\n\t\t\tend\n\t\tend\n\tend\n\n\tif dir == node.mountPoint and node.nodes then\n\t\tfiles = files or { }\n\t\tfor k in pairs(node.nodes) do\n\t\t\tif not inList(files, k) then\n\t\t\t\ttable.insert(files, k)\n\t\t\tend\n\t\tend\n\tend\n\n\tif not files then\n\t\terror('Not a directory', 2)\n\tend\n\n\treturn files\nend\n\nfunction nativefs.getSize(node, dir, recursive)\n\tif recursive and fs.native.isDir(dir) then\n\t\tlocal function sum(dir)\n\t\t\tlocal total = 0\n\t\t\tlocal files = fs.native.list(dir)\n\t\t\tfor _,f in ipairs(files) do\n\t\t\t\tlocal fullName = fs.combine(dir, f)\n\t\t\t\tif fs.native.isDir(fullName) then\n\t\t\t\t\ttotal = total + sum(fullName)\n\t\t\t\telse\n\t\t\t\t\ttotal = total + fs.native.getSize(fullName)\n\t\t\t\tend\n\t\t\tend\n\t\t\treturn total\n\t\tend\n\t\treturn sum(dir)\n\tend\n\tif node.mountPoint == dir and node.nodes then\n\t\treturn 0\n\tend\n\treturn fs.native.getSize(dir)\nend\n\nfunction nativefs.isDir(node, dir)\n\tif node.mountPoint == dir then\n\t\treturn not not node.nodes\n\tend\n\treturn fs.native.isDir(dir)\nend\n\nfunction nativefs.attributes(node, path)\n\tif node.mountPoint == path then\n\t\treturn {\n\t\t\tcreated = node.created or os.epoch('utc'),\n\t\t\tmodification = node.modification or os.epoch('utc'),\n\t\t\tisDir = not not node.nodes,\n\t\t\tsize = node.size or 0,\n\t\t}\n\tend\n\treturn fs.native.attributes(path)\nend\n\nfunction nativefs.exists(node, dir)\n\tif node.mountPoint == dir then\n\t\treturn true\n\tend\n\treturn fs.native.exists(dir)\nend\n\nfunction nativefs.getDrive(node, dir)\n\tif node.mountPoint == dir then\n\t\treturn fs.native.getDrive(dir) or 'virt'\n\tend\n\treturn fs.native.getDrive(dir)\nend\n\nfunction nativefs.delete(node, dir)\n\tif node.mountPoint == dir then\n\t\tfs.unmount(dir)\n\telse\n\t\tfs.native.delete(dir)\n\tend\nend\n\nfstypes.nativefs = nativefs\nfs.nodes = {\n\tfs = nativefs,\n\tmountPoint = '',\n\tfstype = 'nativefs',\n\tnodes = { },\n}\n\nlocal function splitpath(path)\n\tlocal parts = { }\n\tfor match in string.gmatch(path, \"[^/]+\") do\n\t\ttable.insert(parts, match)\n\tend\n\treturn parts\nend\n\nlocal function getNode(dir)\n\tif not dir then error('Invalid directory', 2) end\n\tlocal cd = fs.combine(dir, '')\n\tlocal parts = splitpath(cd)\n\tlocal node = fs.nodes\n\n\tfor _,d in ipairs(parts) do\n\t\tif node.nodes and node.nodes[d] then\n\t\t\tnode = node.nodes[d]\n\t\telse\n\t\t\tbreak\n\t\tend\n\tend\n\n\treturn node\nend\n\nfs.getNode = getNode\n\nlocal methods = { 'delete', 'getFreeSpace', 'exists', 'isDir', 'getSize',\n\t'isReadOnly', 'makeDir', 'getDrive', 'list', 'open', 'attributes' }\n\nfor _,m in pairs(methods) do\n\tfs[m] = function(dir, ...)\n\t\tdir = fs.combine(dir or '', '')\n\t\tlocal node = getNode(dir)\n\t\treturn node.fs[m](node, dir, ...)\n\tend\nend\n\n-- if a link, return the source for this link\nfunction fs.resolve(dir)\n\tlocal n = getNode(dir)\n\treturn n.fs.resolve and n.fs.resolve(n, dir) or dir\nend\n\nfunction fs.complete(partial, dir, includeFiles, includeSlash)\n\tdir = fs.combine(dir, '')\n\tlocal node = getNode(dir)\n\tif node.fs.complete then\n\t\treturn node.fs.complete(node, partial, dir, includeFiles, includeSlash)\n\tend\n\treturn fs.native.complete(partial, dir, includeFiles, includeSlash)\nend\n\nlocal displayFlags = {\n\turlfs  = 'U',\n\tlinkfs = 'L',\n\tramfs  = 'T',\n\tnetfs  = 'N',\n}\n\nfunction fs.listEx(dir)\n  dir = fs.combine(dir, '')\n\tlocal node = getNode(dir)\n\tif node.fs.listEx then\n\t\treturn node.fs.listEx(node, dir)\n\tend\n\n\tlocal t = { }\n\tlocal files = node.fs.list(node, dir)\n\n\tfor _,f in ipairs(files) do\n\t\tpcall(function()\n\t\t\tlocal fullName = fs.combine(dir, f)\n\t\t\tlocal n = fs.getNode(fullName)\n\t\t\tlocal file = {\n\t\t\t\tname = f,\n\t\t\t\tisDir = fs.isDir(fullName),\n\t\t\t\tisReadOnly = fs.isReadOnly(fullName),\n\t\t\t\tfstype = n.mountPoint == fullName and displayFlags[n.fstype],\n\t\t\t}\n\t\t\tif not file.isDir then\n\t\t\t\tfile.size = fs.getSize(fullName)\n\t\t\tend\n\t\t\ttable.insert(t, file)\n\t\tend)\n\tend\n\treturn t\nend\n\nfunction fs.copy(s, t)\n\tif not s then error('copy: bad argument #1') end\n\tif not t then error('copy: bad argument #2') end\n\tlocal sp = getNode(s)\n\tlocal tp = getNode(t)\n\tif sp == tp and sp.fs.copy then\n\t\treturn sp.fs.copy(sp, s, t)\n\tend\n\n\tif fs.exists(t) then\n\t\terror('File exists')\n\tend\n\n\tif fs.isDir(s) then\n\t\tfs.makeDir(t)\n\t\tlocal list = fs.list(s)\n\t\tfor _,f in ipairs(list) do\n\t\t\tfs.copy(fs.combine(s, f), fs.combine(t, f))\n\t\tend\n\n\telse\n\t\tlocal sf = Util.readFile(s, 'rb')\n\t\tif not sf then\n\t\t\terror('No such file')\n\t\tend\n\n\t\tUtil.writeFile(t, sf, 'wb')\n\tend\nend\n\nfunction fs.find(spec) -- not optimized\n--  local node = getNode(spec)\n--  local files = node.fs.find(node, spec)\n\tlocal files = { }\n\t-- method from https://github.com/N70/deltaOS/blob/dev/vfs\n\n\t-- REVISIT - see globbing in shellex package\n\tlocal function recurse_spec(results, path, spec)\n\t\tlocal segment = spec:match('([^/]*)'):gsub('/', '')\n\t\tlocal pattern = '^' .. segment:gsub(\"[%.%[%]%(%)%%%+%-%?%^%$]\",\"%%%1\"):gsub(\"%z\",\"%%z\"):gsub(\"%*\",\"[^/]-\") .. '$'\n\t\tif fs.isDir(path) then\n\t\t\tfor _, file in ipairs(fs.list(path)) do\n\t\t\t\tif file:match(pattern) then\n\t\t\t\t\tlocal f = fs.combine(path, file)\n\t\t\t\t\tif spec == segment then\n\t\t\t\t\t\ttable.insert(results, f)\n\t\t\t\t\tend\n\t\t\t\t\tif fs.isDir(f) then\n\t\t\t\t\t\trecurse_spec(results, f, spec:sub(#segment + 2))\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\trecurse_spec(files, '', spec)\n\ttable.sort(files)\n\n\treturn files\nend\n\nfunction fs.move(s, t)\n\tlocal sp = getNode(s)\n\tlocal tp = getNode(t)\n\tif sp == tp and sp.fs.move then\n\t\treturn sp.fs.move(sp, s, t)\n\tend\n\tfs.copy(s, t)\n\tfs.delete(s)\nend\n\nlocal function getfstype(fstype)\n\tlocal vfs = fstypes[fstype]\n\tif not vfs then\n\t\tvfs = require('opus.fs.' .. fstype)\n\t\tfs.registerType(fstype, vfs)\n\tend\n\treturn vfs\nend\n\nfunction fs.mount(path, fstype, ...)\n\tlocal vfs = getfstype(fstype)\n\tif not vfs then\n\t\terror('Invalid file system type')\n\tend\n\n\t-- get the mount point for the path\n\t-- ie. if packages is mapped to disk/packages\n\t-- and a request to mount /packages/foo\n\t-- then use disk/packages/foo as the mountPoint\n\tpath = fs.resolve(path)\n\n\tlocal node = vfs.mount(path, ...)\n\tif node then\n\t\tlocal parts = splitpath(path)\n\t\tlocal targetName = table.remove(parts, #parts)\n\n\t\tlocal tp = fs.nodes\n\t\tfor _,d in ipairs(parts) do\n\t\t\tif not tp.nodes then\n\t\t\t\ttp.nodes = { }\n\t\t\tend\n\t\t\tif not tp.nodes[d] then\n\t\t\t\ttp.nodes[d] = Util.shallowCopy(tp)\n\t\t\t\ttp.nodes[d].nodes = { }\n\t\t\t\ttp.nodes[d].mountPoint = fs.combine(tp.mountPoint, d)\n\t\t\t\ttp.nodes[d].created = os.epoch('utc')\n\t\t\t\ttp.nodes[d].modification = os.epoch('utc')\n\t\t\tend\n\t\t\ttp = tp.nodes[d]\n\t\tend\n\n\t\tnode.fs = vfs\n\t\tnode.fstype = fstype\n\t\tnode.created = node.created or os.epoch('utc')\n\t\tnode.modification = node.modification or os.epoch('utc')\n\t\tif not targetName then\n\t\t\tnode.mountPoint = ''\n\t\t\tfs.nodes = node\n\t\telse\n\t\t\tnode.mountPoint = fs.combine(tp.mountPoint, targetName)\n\t\t\ttp.nodes[targetName] = node\n\t\tend\n\tend\n\treturn node\nend\n\nfunction fs.loadTab(path)\n\tlocal mounts = Util.readFile(path)\n\tif mounts then\n\t\tfor _,l in ipairs(Util.split(mounts)) do\n\t\t\tl = Util.trim(l)\n\t\t\tif #l > 0 and l:sub(1, 1) ~= '#' then\n\t\t\t\tlocal s, m = pcall(function()\n\t\t\t\t\tfs.mount(table.unpack(Util.matches(l)))\n\t\t\t\tend)\n\t\t\t\tif not s then\n\t\t\t\t\t_G.printError('Mount failed')\n\t\t\t\t\t_G.printError(l)\n\t\t\t\t\t_G.printError(m)\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\nend\n\nlocal function getNodeByParts(parts)\n\tlocal node = fs.nodes\n\n\tfor _,d in ipairs(parts) do\n\t\tif not node.nodes[d] then\n\t\t\treturn\n\t\tend\n\t\tnode = node.nodes[d]\n\tend\n\treturn node\nend\n\nfunction fs.unmount(path)\n\tlocal parts = splitpath(path)\n\tlocal targetName = table.remove(parts, #parts)\n\n\tlocal node = getNodeByParts(parts)\n\n\tif node and node.nodes[targetName] then\n\t\tnode.nodes[targetName] = nil\n\tend\nend\n\nfunction fs.registerType(name, vfs)\n\tfstypes[name] = vfs\nend\n\nfunction fs.getTypes()\n\treturn fstypes\nend\n\nfunction fs.restore()\n\tlocal native = fs.native\n\tUtil.clear(fs)\n\tUtil.merge(fs, native)\nend", "sys/init/3.sys.lua": "local fs     = _G.fs\nlocal os     = _G.os\n\nfs.loadTab('sys/etc/fstab')\n\n-- add some Lua compatibility functions\nfunction os.remove(a)\n\tif fs.exists(a) then\n\t\tlocal s = pcall(fs.delete, a)\n\t\treturn s and true or nil, a .. ': Unable to remove file'\n\tend\n\treturn nil, a .. ': No such file or directory'\nend\n\nos.execute = function(cmd)\n\tlocal env = _G.getfenv(2)\n\tif not cmd then\n\t\treturn env.shell and 1 or 0\n\tend\n\n\tif not env.shell then\n\t\treturn 0\n\tend\n\n\tlocal s, m = env.shell.run('sys/apps/shell.lua ' .. cmd)\n\n\tif not s then\n\t\treturn 1, m\n\tend\n\n\treturn 0\nend\n\nos.tmpname = function()\n\tlocal fname\n\trepeat\n\t\tfname = 'tmp/a' .. math.random(1, 32768)\n\tuntil not fs.exists(fname)\n\n\treturn fname\nend\n\n-- non-standard - will raise error instead\nos.exit = function(code)\n\terror(code or 0)\nend", "sys/init/3.modules.lua": "local Util       = require('opus.util')\n\nlocal device     = _G.device\nlocal kernel     = _G.kernel\nlocal os         = _G.os\n\nlocal containers = {\n\tmanipulator = true,\n\tneuralInterface = true,\n}\n\nlocal cache = { }\n\n-- manipulators will throw an error on listModules\n-- if the user has logged off\nlocal function getModules(dev, side)\n\tlocal list = { }\n\tlocal s, m = pcall(function()\n\t\tif dev and dev.listModules then\n\t\t\tfor _, module in pairs(dev.listModules()) do\n\t\t\t\tlist[module] = Util.shallowCopy(dev)\n\t\t\t\tlist[module].name = module\n\t\t\t\tlist[module].type = module\n\t\t\t\tlist[module].side = side\n\t\t\tend\n\t\tend\n\tend)\n\tif not s and m then\n\t\t_G._syslog(m)\n\tend\n\treturn list\nend\n\n-- if a device has been reattached, reuse the existing\n-- table so any references to the table are retained\nlocal function addDevice(dev, args, doQueue)\n\tlocal name = args.name\n\n\tif not cache[name] then\n\t\tcache[name] = { }\n\tend\n\tdevice[name] = cache[name]\n\tUtil.merge(device[name], dev)\n\tUtil.merge(device[name], args)\n\n\tif doQueue then\n\t\tos.queueEvent('device_attach', name)\n\tend\nend\n\n-- directly access the peripheral as the methods in getInventory, etc.\n-- can become invalid without any way to tell\nlocal function damnManipulator(container, method, args, doQueue)\n\tlocal dev = { }\n\tlocal methods = {\n\t\t'drop', 'getDocs', 'getItem', 'getItemMeta', 'getTransferLocations',\n\t\t'list', 'pullItems', 'pushItems', 'size', 'suck',\n\t}\n\t-- the user might not be logged in when the compputer is started\n\t-- and there's no way to know when they have logged in.\n\t-- these methods will error if the user is not logged in\n\tif container[method] then\n\t\tfor _,k in pairs(methods) do\n\t\t\tdev[k] = function(...)\n\t\t\t\treturn device[container.name][method]()[k](...)\n\t\t\tend\n\t\tend\n\n\t\taddDevice(dev, args, doQueue)\n\tend\nend\n\nlocal function addContainer(v, doQueue)\n\t-- add devices like plethora:scanner\n\tfor name, dev in pairs(getModules(v, v.side)) do\n\t\t-- neural and attached modules have precedence over manipulator modules\n\t\tif not device[name] or v.type ~= 'manipulator' then\n\t\t\taddDevice(dev, { name = dev.name, type = dev.name, side = dev.side }, doQueue)\n\t\tend\n\tend\n\n\tif v.getName then\n\t\tlocal s, m = pcall(function()\n\t\t\tlocal name = v.getName()\n\t\t\tif name then\n\t\t\t\tdamnManipulator(v, 'getInventory', {\n\t\t\t\t\tname = name .. ':inventory',\n\t\t\t\t\ttype = 'inventory',\n\t\t\t\t\tside = v.side\n\t\t\t\t}, doQueue)\n\t\t\t\tdamnManipulator(v, 'getEquipment', {\n\t\t\t\t\tname = name .. ':equipment',\n\t\t\t\t\ttype = 'equipment',\n\t\t\t\t\tside = v.side\n\t\t\t\t}, doQueue)\n\t\t\t\tdamnManipulator(v, 'getEnder', {\n\t\t\t\t\tname = name .. ':enderChest',\n\t\t\t\t\ttype = 'enderChest',\n\t\t\t\t\tside = v.side\n\t\t\t\t}, doQueue)\n\t\t\tend\n\t\tend)\n\t\tif not s and m then\n\t\t\t_G._syslog(m)\n\t\tend\n\tend\nend\n\nfor k,v in pairs(device) do\n\tif containers[v.type] then\n\t\tcache[k] = v\n\t\taddContainer(v)\n\tend\nend\n\n-- register modules as peripherals\nkernel.hook('device_attach', function(_, eventData)\n\tlocal name = eventData[1]\n\tlocal dev = device[name]\n\n\tif dev and containers[dev.type] then\n\t\t-- so... basically, if you get a handle to device.neuralInterface\n\t\t-- (or manipulator) - that handle will still be valid after\n\t\t-- a module is removed\n\t\tif cache[name] then\n\t\t\tdevice[name] = cache[name]\n\t\t\tfor k,v in pairs(device[name]) do\n\t\t\t\tif type(v) == 'function' then\n\t\t\t\t\tdevice[name][k] = nil\n\t\t\t\tend\n\t\t\tend\n\t\t\tUtil.merge(device[name], dev)\n\t\telse\n\t\t\tcache[name] = dev\n\t\tend\n\t\taddContainer(dev, true)\n\tend\nend)\n", "sys/init/5.unpackage.lua": "local LZW  = require('opus.compress.lzw')\nlocal Tar  = require('opus.compress.tar')\nlocal Util = require('opus.util')\n\nlocal fs = _G.fs\n\nif not fs.exists('packages') or not fs.isDir('packages') then\n\treturn\nend\n\nfor _, name in pairs(fs.list('packages')) do\n\tlocal fullName = fs.combine('packages', name)\n\tlocal packageName = name:match('(.+)%.tar%.lzw$')\n\tif packageName and not fs.isDir(fullName) then\n\t\tlocal dir = fs.combine('packages', packageName)\n\t\tif not fs.exists(dir) then\n\t\t\tlocal s, m = pcall(function()\n\t\t\t\tfs.mount(dir, 'ramfs', 'directory')\n\n\t\t\t\tlocal c = Util.readFile(fullName, 'rb')\n\n\t\t\t\tTar.untar_string(LZW.decompress(c), dir)\n\t\t\tend)\n\t\t\tif not s then\n\t\t\t\tfs.delete(dir)\n\t\t\t\tprint('failed to extract ' .. fullName)\n\t\t\t\tprint(m)\n\t\t\tend\n\t\tend\n\tend\nend\n", "sys/init/6.packages.lua": "local Packages = require('opus.packages')\nlocal Util     = require('opus.util')\n\nlocal fs    = _G.fs\nlocal help  = _G.help\nlocal shell = _ENV.shell\n\nlocal appPaths = Util.split(shell.path(), '(.-):')\nlocal helpPaths = Util.split(help.path(), '(.-):')\n\ntable.insert(helpPaths, '/sys/help')\n\nfor name in pairs(Packages:installed()) do\n\tlocal packageDir = fs.combine('packages', name)\n\n\tlocal fstabPath = fs.combine(packageDir, 'etc/fstab')\n\tif fs.exists(fstabPath) then\n\t\tfs.loadTab(fstabPath)\n\tend\n\n\ttable.insert(appPaths, 1, '/' .. packageDir)\n\n\tlocal apiPath = fs.combine(packageDir, 'apis') -- TODO: rename dir to 'modules' (someday)\n\tif fs.exists(apiPath) then\n\t\tfs.mount(fs.combine('rom/modules/main', name), 'linkfs', apiPath)\n\tend\n\n\tlocal helpPath = '/' .. fs.combine(packageDir, 'help')\n\tif fs.exists(helpPath) then\n\t\ttable.insert(helpPaths, helpPath)\n\tend\nend\n\nhelp.setPath(table.concat(helpPaths, ':'))\nshell.setPath(table.concat(appPaths, ':'))\n\nlocal function runDir(directory)\n\tlocal files = fs.list(directory)\n\ttable.sort(files)\n\n\tfor _,file in ipairs(files) do\n\t\tos.sleep(0)\n\t\tlocal result, err = shell.run(directory .. '/' .. file)\n\t\tif not result and err then\n\t\t\t_G.printError('\\n' .. err)\n\t\tend\n\tend\nend\n\nfor _, package in pairs(Packages:installedSorted()) do\n\tlocal packageDir = 'packages/' .. package.name .. '/init'\n\tif fs.exists(packageDir) and fs.isDir(packageDir) then\n\t\trunDir(packageDir)\n\tend\nend\n", "sys/init/7.multishell.lua": "local Blit     = require('opus.ui.blit')\nlocal Config   = require('opus.config')\nlocal Util     = require('opus.util')\n\nlocal colors     = _G.colors\nlocal fs         = _G.fs\nlocal kernel     = _G.kernel\nlocal keys       = _G.keys\nlocal os         = _G.os\nlocal printError = _G.printError\nlocal window     = _G.window\n\nlocal parentTerm = _G.device.terminal\nlocal w,h = parentTerm.getSize()\nlocal overviewId\nlocal tabsDirty = false\nlocal closeInd = Util.getVersion() >= 1.76 and '\\215' or '*'\nlocal multishell = { }\n\n_ENV.multishell = multishell\n\nkernel.window.reposition(1, 2, w, h - 1)\n\nlocal config = {\n\tstandard = {\n\t\ttextColor  = colors.lightGray,\n\t\ttabBarTextColor = colors.lightGray,\n\t\tfocusTextColor = colors.white,\n\t\tbackgroundColor = colors.gray,\n\t\ttabBarBackgroundColor = colors.gray,\n\t\tfocusBackgroundColor = colors.gray,\n\t\terrorColor = colors.black,\n\t},\n\tcolor = {\n\t\ttextColor  = colors.lightGray,\n\t\ttabBarTextColor = colors.lightGray,\n\t\tfocusTextColor = colors.white,\n\t\tbackgroundColor = colors.gray,\n\t\ttabBarBackgroundColor = colors.gray,\n\t\tfocusBackgroundColor = colors.gray,\n\t\terrorColor = colors.red,\n\t},\n}\nConfig.load('multishell', config)\n\nlocal _colors = parentTerm.isColor() and config.color or config.standard\nlocal palette = parentTerm.isColor() and Blit.colorPalette or Blit.grayscalePalette\n\nlocal function redrawMenu()\n\tif not tabsDirty then\n\t\tos.queueEvent('multishell_redraw')\n\t\ttabsDirty = true\n\tend\nend\n\nfunction multishell.getFocus()\n\tlocal currentTab = kernel.getFocused()\n\treturn currentTab.uid\nend\n\nfunction multishell.setFocus(tabId)\n\treturn kernel.raise(tabId)\nend\n\nfunction multishell.getTitle(tabId)\n\tlocal tab = kernel.find(tabId)\n\treturn tab and tab.title\nend\n\nfunction multishell.setTitle(tabId, title)\n\tlocal tab = kernel.find(tabId)\n\tif tab then\n\t\ttab.title = title\n\t\tredrawMenu()\n\tend\nend\n\nfunction multishell.getCurrent()\n\tlocal runningTab = kernel.getCurrent()\n\treturn runningTab and runningTab.uid\nend\n\nfunction multishell.getTab(tabId)\n\treturn kernel.find(tabId)\nend\n\nfunction multishell.terminate(tabId)\n\tos.queueEvent('multishell_terminate', tabId)\nend\n\nfunction multishell.getTabs()\n\treturn kernel.routines\nend\n\nfunction multishell.launch(env, path, ...)\n\t-- backwards compatibility\n\treturn multishell.openTab(env, {\n\t\tpath = path,\n\t\targs = { ... },\n\t})\nend\n\nlocal function chain(orig, fn)\n\tif not orig then\n\t\treturn fn\n\tend\n\n\tif type(orig) == 'table' then\n\t\ttable.insert(orig, fn)\n\t\treturn orig\n\tend\n\n\treturn setmetatable({ orig, fn }, {\n\t\t__call = function(self, ...)\n\t\t\tfor _,v in pairs(self) do\n\t\t\t\tv(...)\n\t\t\tend\n\t\tend\n\t})\nend\n\nfunction multishell.openTab(env, tab)\n\tif not tab.title and tab.path then\n\t\ttab.title = fs.getName(tab.path):match('([^%.]+)')\n\tend\n\ttab.title = tab.title or 'untitled'\n\ttab.window = tab.window or window.create(parentTerm, 1, 2, w, h - 1, false)\n\t\t-- require('opus.terminal').window(parentTerm, 1, 2, w, h - 1, false)\n\ttab.onExit = chain(tab.onExit, function(self, result, err, stack)\n\t\tif not result and err and err ~= 'Terminated' then\n\t\t\tself.terminal.setTextColor(colors.white)\n\t\t\tself.terminal.setCursorBlink(false)\n\t\t\tprint('\\nThe program terminated with an error.\\n')\n\t\t\tif tonumber(err) then\n\t\t\t\tprintError('Process exited with error code: ' .. err)\n\t\t\telseif err then\n\t\t\t\tprintError(tostring(err))\n\t\t\tend\n\t\t\tif type(stack) == 'table' and #stack > 0 then\n\t\t\t\tlocal _, cy = self.terminal.getCursorPos()\n\t\t\t\tlocal _, th = self.terminal.getSize()\n\t\t\t\tself.terminal.setTextColor(colors.white)\n\t\t\t\tif cy < th - 4 then\n\t\t\t\t\tprint('\\nstack traceback:')\n\t\t\t\t\tfor _, v in ipairs(stack or { }) do\n\t\t\t\t\t\t_, cy = self.terminal.getCursorPos()\n\t\t\t\t\t\tif cy > th - 3 then\n\t\t\t\t\t\t\tprint(' ...')\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\tend\n\t\t\t\t\t\tprint(v)\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\tend\n\t\t\tself.terminal.setTextColor(parentTerm.isColor() and colors.yellow or colors.white)\n\t\t\t_G.write('\\nPress enter to close')\n\t\t\tself.isDead = true\n\t\t\tself.hidden = false\n\t\t\tredrawMenu()\n\t\t\twhile true do\n\t\t\t\tlocal e, code = os.pullEventRaw('key')\n\t\t\t\tif e == 'terminate' or e == 'key' and code == keys.enter then\n\t\t\t\t\tbreak\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend)\n\n\tlocal routine, message = kernel.run(env, tab)\n\n\tif routine then\n\t\tif tab.focused then\n\t\t\tmultishell.setFocus(routine.uid)\n\t\telse\n\t\t\tredrawMenu()\n\t\tend\n\tend\n\n\treturn routine and routine.uid, message\nend\n\nfunction multishell.hideTab(tabId)\n\tlocal tab = kernel.find(tabId)\n\tif tab then\n\t\ttab.hidden = true\n\t\tkernel.lower(tab.uid)\n\t\tredrawMenu()\n\tend\nend\n\nfunction multishell.unhideTab(tabId)\n\tlocal tab = kernel.find(tabId)\n\tif tab then\n\t\ttab.hidden = false\n\t\tredrawMenu()\n\tend\nend\n\nfunction multishell.getCount()\n\treturn #kernel.routines\nend\n\nkernel.hook('kernel_focus', function()\n\tredrawMenu()\nend)\n\nkernel.hook('multishell_terminate', function(_, eventData)\n\tlocal tab = kernel.find(eventData[1])\n\tif tab and not tab.isOverview then\n\t\tif coroutine.status(tab.co) ~= 'dead' then\n\t\t\ttab:resume(\"terminate\")\n\t\tend\n\tend\n\treturn true\nend)\n\nkernel.hook('terminate', function()\n\treturn kernel.getFocused().isOverview\nend)\n\nkernel.hook('multishell_redraw', function()\n\ttabsDirty = false\n\n\tlocal blit = Blit(w, {\n\t\tbg = _colors.tabBarBackgroundColor,\n\t\tfg = _colors.textColor,\n\t\tpalette = palette,\n\t})\n\n\tlocal currentTab = kernel.getFocused()\n\n\tfor _,tab in pairs(kernel.routines) do\n\t\tif tab.hidden and tab ~= currentTab then\n\t\t\ttab.width = 0\n\t\telse\n\t\t\ttab.width = #tab.title + 1\n\t\tend\n\tend\n\n\tlocal function width()\n\t\tlocal tw = 0\n\t\tUtil.each(kernel.routines, function(t) tw = tw + t.width end)\n\t\treturn tw\n\tend\n\n\twhile width() > w - 3 do\n\t\tlocal tab = select(2,\n\t\t\tUtil.spairs(kernel.routines, function(a, b) return a.width > b.width end)())\n\t\ttab.width = tab.width - 1\n\tend\n\n\tlocal function compareTab(a, b)\n\t\tif a.hidden then return false end\n\t\treturn b.hidden or a.uid < b.uid\n\tend\n\n\tlocal tabX = 0\n\tfor _,tab in Util.spairs(kernel.routines, compareTab) do\n\t\tif tab.width > 0 then\n\t\t\ttab.sx = tabX + 1\n\t\t\ttab.ex = tabX + tab.width\n\t\t\ttabX = tabX + tab.width\n\t\t\tif tab ~= currentTab then\n\t\t\t\tlocal textColor = tab.isDead and _colors.errorColor or _colors.textColor\n\t\t\t\tblit:write(tab.sx, tab.title:sub(1, tab.width - 1),\n\t\t\t\t\t_colors.backgroundColor, textColor)\n\t\t\tend\n\t\tend\n\tend\n\n\tif currentTab then\n\t\tif currentTab.sx then\n\t\t\tlocal textColor = currentTab.isDead and _colors.errorColor or _colors.focusTextColor\n\t\t\tblit:write(currentTab.sx - 1,\n\t\t\t\t' ' .. currentTab.title:sub(1, currentTab.width - 1) .. ' ',\n\t\t\t\t_colors.focusBackgroundColor, textColor)\n\t\tend\n\t\tif not currentTab.noTerminate then\n\t\t\tblit:write(w, closeInd, nil, _colors.focusTextColor)\n\t\tend\n\tend\n\n\tparentTerm.setCursorPos(1, 1)\n\tparentTerm.blit(blit.text, blit.fg, blit.bg)\n\n\tif currentTab and currentTab.window then\n\t\tcurrentTab.window.restoreCursor()\n\tend\n\n\treturn true\nend)\n\nkernel.hook('term_resize', function(_, eventData)\n\tif not eventData[1] then                            --- TEST\n\t\tw,h = parentTerm.getSize()\n\n\t\tlocal windowHeight = h-1\n\n\t\tfor _,key in pairs(Util.keys(kernel.routines)) do\n\t\t\tlocal tab = kernel.routines[key]\n\t\t\tlocal x,y = tab.window.getCursorPos()\n\t\t\tif y > windowHeight then\n\t\t\t\ttab.window.scroll(y - windowHeight)\n\t\t\t\ttab.window.setCursorPos(x, windowHeight)\n\t\t\tend\n\t\t\ttab.window.reposition(1, 2, w, windowHeight)\n\t\tend\n\n\t\tredrawMenu()\n\tend\nend)\n\nkernel.hook('mouse_click', function(_, eventData)\n\tif not eventData[4] then\n\t\tlocal x, y = eventData[2], eventData[3]\n\n\t\tif y == 1 then\n\t\t\tif x == 1 then\n\t\t\t\tmultishell.setFocus(overviewId)\n\t\t\telseif x == w then\n\t\t\t\tlocal currentTab = kernel.getFocused()\n\t\t\t\tif currentTab then\n\t\t\t\t\tmultishell.terminate(currentTab.uid)\n\t\t\t\tend\n\t\t\telse\n\t\t\t\tfor _,tab in pairs(kernel.routines) do\n\t\t\t\t\tif not tab.hidden and tab.sx then\n\t\t\t\t\t\tif x >= tab.sx and x <= tab.ex then\n\t\t\t\t\t\t\tmultishell.setFocus(tab.uid)\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\tend\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\tend\n\t\t\treturn true\n\t\tend\n\t\teventData[3] = eventData[3] - 1\n\tend\nend)\n\nkernel.hook({ 'mouse_up', 'mouse_drag' }, function(_, eventData)\n\tif not eventData[4] then\n\t\teventData[3] = eventData[3] - 1\n\tend\nend)\n\nkernel.hook('mouse_scroll', function(_, eventData)\n\tif not eventData[4] then\n\t\tif eventData[3] == 1 then\n\t\t\treturn true\n\t\tend\n\t\teventData[3] = eventData[3] - 1\n\tend\nend)\n\nkernel.hook('kernel_ready', function()\n\toverviewId = multishell.openTab(_ENV, {\n\t\tpath = 'sys/apps/shell.lua',\n\t\targs = { config.launcher or 'sys/apps/Overview.lua' },\n\t\tisOverview = true,\n\t\tnoTerminate = true,\n\t\tfocused = true,\n\t\ttitle = '+',\n\t\tonExit = function(_, s, m)\n\t\t\tif not s then\n\t\t\t\tkernel.halt(s, m)\n\t\t\tend\n\t\tend,\n\t})\n\tmultishell.setTitle(overviewId, '+')\n\n\tmultishell.openTab(_ENV, {\n\t\tpath = 'sys/apps/shell.lua',\n\t\targs = { 'sys/apps/autorun.lua' },\n\t\ttitle = 'Autorun',\n\t})\nend)\n", "sys/init/1.device.lua": "local Peripheral = require('opus.peripheral')\n\n_G.device = Peripheral.getList()\n\n_G.device.terminal = _G.kernel.terminal\n_G.device.terminal.side = 'terminal'\n_G.device.terminal.type = 'terminal'\n_G.device.terminal.name = 'terminal'\n\n_G.device.keyboard = {\n\tside    = 'keyboard',\n\ttype    = 'keyboard',\n\tname    = 'keyboard',\n\thotkeys = { },\n\tstate   = { },\n}\n\n_G.device.mouse = {\n\tside    = 'mouse',\n\ttype    = 'mouse',\n\tname    = 'mouse',\n\tstate   = { },\n}\n\nlocal Input      = require('opus.input')\nlocal Util       = require('opus.util')\n\nlocal device   = _G.device\nlocal kernel   = _G.kernel\nlocal keyboard = _G.device.keyboard\nlocal keys     = _G.keys\nlocal mouse    = _G.device.mouse\nlocal os       = _G.os\n\nkernel.hook('peripheral', function(_, eventData)\n\tlocal side = eventData[1]\n\tif side then\n\t\tlocal dev = Peripheral.addDevice(device, side)\n\t\tif dev then\n\t\t\tos.queueEvent('device_attach', dev.name)\n\t\tend\n\tend\nend)\n\nkernel.hook('peripheral_detach', function(_, eventData)\n\tlocal side = eventData[1]\n\tif side then\n\t\tfor _, dev in pairs(Util.findAll(device, 'side', side)) do\n\t\t\tos.queueEvent('device_detach', dev.name)\n\t\t\tdevice[dev.name] = nil\n\t\tend\n\tend\nend)\n\nlocal modifiers = Util.transpose {\n\tkeys.leftCtrl,  keys.rightCtrl,\n\tkeys.leftShift, keys.rightShift,\n\tkeys.leftAlt,   keys.rightAlt,\n}\n\nkernel.hook({ 'key', 'char', 'paste' }, function(event, eventData)\n\tlocal code = eventData[1]\n\n\t-- maintain global keyboard modifier state\n\tif event == 'key' and modifiers[code] then\n\t\tkeyboard.state[code] = true\n\tend\n\n\t-- and fire hotkeys\n\tlocal hotkey = Input:translate(event, eventData[1], eventData[2])\n\n\tif hotkey and keyboard.hotkeys[hotkey.code] then\n\t\tkeyboard.hotkeys[hotkey.code](event, eventData)\n\t\treturn true\n\tend\nend)\n\nkernel.hook('key_up', function(_, eventData)\n\tlocal code = eventData[1]\n\n\tif modifiers[code] then\n\t\tkeyboard.state[code] = nil\n\tend\nend)\n\nkernel.hook({ 'mouse_click', 'mouse_up', 'mouse_drag' }, function(event, eventData)\n\tlocal button = eventData[1]\n\tif event == 'mouse_click' then\n\t\tmouse.state[button] = true\n\telse\n\t\tif not mouse.state[button] then\n\t\t\treturn true -- ensure mouse ups are only generated if a mouse down was sent\n\t\tend\n\t\tif event == 'mouse_up' then\n\t\t\tmouse.state[button] = nil\n\t\tend\n\tend\nend)\n\nfunction keyboard.addHotkey(code, fn)\n\tkeyboard.hotkeys[code] = fn\nend\n\nfunction keyboard.removeHotkey(code)\n\tkeyboard.hotkeys[code] = nil\nend\n", "sys/boot/tlco.lua": "local run = os.run\nlocal shutdown = os.shutdown\n\nlocal args = {...} -- keep the args so that they can be passed to opus.lua\n\nos.run = function() \n\tos.run = run\nend\n\nos.shutdown = function()\n\tos.shutdown = shutdown\n\n\t_ENV.multishell = nil -- prevent sys/apps/shell.lua erroring for odd reasons\n\n\tlocal success, err = pcall(function()\n\t\trun(_ENV, 'sys/boot/opus.lua', table.unpack(args))\n\tend)\n\tterm.redirect(term.native())\n\tif success then\n\t\tprint(\"Opus OS abruptly stopped.\")\n\telse\n\t\tprintError(\"Opus OS errored.\")\n\t\tprintError(err)\n\tend\n\tprint(\"Press any key to continue.\")\n\tos.pullEvent(\"key\")\n\tshutdown()\nend\n\nshell.exit()", "sys/boot/opus.lua": "local fs = _G.fs\n\n-- override bios function to use the global scope of the current env\nfunction _G.loadstring(string, chunkname)\n\treturn load(string, chunkname, nil, getfenv(2)._G)\nend\n\n-- override bios function to include the actual filename\nfunction _G.loadfile(filename, mode, env)\n    -- Support the previous `loadfile(filename, env)` form instead.\n    if type(mode) == \"table\" and env == nil then\n        mode, env = nil, mode\n    end\n\n    local file = fs.open(filename, \"r\")\n    if not file then return nil, \"File not found\" end\n\n    local func, err = load(file.readAll(), '@' .. filename, mode, env)\n    file.close()\n    return func, err\nend\n\nlocal sandboxEnv = setmetatable({ }, { __index = _G })\nfor k,v in pairs(_ENV) do\n\tsandboxEnv[k] = v\nend\n\n-- Install require shim\n_G.requireInjector = loadfile('sys/modules/opus/injector.lua', _ENV)()\n\nlocal function run(file, ...)\n\tlocal env = setmetatable({ }, { __index = _G })\n\tfor k,v in pairs(sandboxEnv) do\n\t\tenv[k] = v\n\tend\n\n\t_G.requireInjector(env)\n\n\tlocal s, m = loadfile(file, env)\n\tif s then\n\t\treturn s(...)\n\tend\n\terror('Error loading ' .. file .. '\\n' .. m)\nend\n\n_G._syslog = function() end\n_G.OPUS_BRANCH = 'develop-1.8'\n\nlocal s, m = pcall(run, 'sys/apps/shell.lua', 'sys/kernel.lua', ...)\n\nif not s then\n\tprint('\\nError loading Opus OS\\n')\n\t_G.printError(m .. '\\n')\nend\n\nif fs.restore then\n\tfs.restore()\nend\n", "sys/boot/kiosk.lua": "local os         = _G.os\nlocal parallel   = _G.parallel\nlocal peripheral = _G.peripheral\nlocal settings   = _G.settings\nlocal term       = _G.term\n\nlocal name = settings.get('kiosk.monitor')\n\nif not name then\n\tperipheral.find('monitor', function(s)\n\t\tname = s\n\tend)\nend\n\nlocal mon = name and peripheral.wrap(name)\n\nif mon then\n\tprint(\"Opus OS is running in Kiosk mode, and the screen will be redirected to the monitor. To undo this, go to the boot option menu by pressing a key while booting, then select the option 2.\")\n\tterm.redirect(mon)\n\tmon.setTextScale(tonumber(settings.get('kiosk.textscale')) or 1)\n\n\tparallel.waitForAny(\n\t\tfunction()\n\t\t\tos.run(_ENV, '/sys/boot/opus.boot')\n\t\tend,\n\n\t\tfunction()\n\t\t\twhile true do\n\t\t\t\tlocal event, side, x, y = os.pullEventRaw('monitor_touch')\n\n\t\t\t\tif event == 'monitor_touch' and side == name then\n\t\t\t\t\tos.queueEvent('mouse_click', 1, x, y)\n\t\t\t\t\tos.queueEvent('mouse_up',    1, x, y)\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\t)\nelse\n\tos.run(_ENV, '/sys/boot/opus.boot')\nend\n", "sys/autorun/complete.lua": "local fs = _G.fs\n\nlocal function completeMultipleChoice(sText, tOptions, bAddSpaces)\n\tlocal tResults = { }\n\tfor n = 1,#tOptions do\n\t\tlocal sOption = tOptions[n]\n\t\tif #sOption + (bAddSpaces and 1 or 0) > #sText and string.sub(sOption, 1, #sText) == sText then\n\t\t\tlocal sResult = string.sub(sOption, #sText + 1)\n\t\t\tif bAddSpaces then\n\t\t\t\ttable.insert(tResults, sResult .. \" \")\n\t\t\telse\n\t\t\t\ttable.insert(tResults, sResult)\n\t\t\tend\n\t\tend\n\tend\n\treturn tResults\nend\n\n_ENV.shell.setCompletionFunction(\"sys/apps/package.lua\",\n\tfunction(_, index, text)\n\t\tif index == 1 then\n\t\t\treturn completeMultipleChoice(text, { \"install \", \"update \", \"uninstall \", \"updateall \", \"refresh\" })\n\t\tend\n\tend)\n\n_ENV.shell.setCompletionFunction(\"sys/apps/inspect.lua\",\n\tfunction(_, index, text)\n\t\tif index == 1 then\n\t\t\tlocal components = { }\n\t\t\tfor _, f in pairs(fs.list('sys/modules/opus/ui/components')) do\n\t\t\t\ttable.insert(components, (f:gsub(\"%.lua$\", \"\")))\n\t\t\tend\n\t\t\treturn completeMultipleChoice(text, components)\n\t\tend\n\tend)\n", "sys/autorun/clipboard.lua": "local Util = require('opus.util')\n\nlocal kernel    = _G.kernel\nlocal keyboard  = _G.device.keyboard\nlocal os        = _G.os\nlocal textutils = _G.textutils\n\nkernel.hook('clipboard_copy', function(_, args)\n\tkeyboard.clipboard =  args[1]\nend)\n\nlocal function queuePaste()\n\tlocal data = keyboard.clipboard\n\n\tif type(data) == 'table' then\n\t\tlocal s, m = pcall(textutils.serialize, data)\n\t\tdata = s and m or Util.tostring(data)\n\tend\n\n\tif data then\n\t\tos.queueEvent('paste', data)\n\tend\nend\n\nkernel.hook('clipboard_paste', queuePaste)\nkeyboard.addHotkey('shift-paste', queuePaste)\n", "sys/autorun/version.lua": "local Config = require('opus.config')\nlocal Util   = require('opus.util')\n\nlocal fs    = _G.fs\nlocal shell = _ENV.shell\n\nlocal URL = 'https://raw.githubusercontent.com/kepler155c/opus/%s/.opus_version'\n\nif fs.exists('.opus_version') then\n\tlocal f = fs.open('.opus_version', 'r')\n\tlocal date = f.readLine()\n\tf.close()\n\tdate = type(date) == 'string' and Util.split(date)[1]\n\n\tlocal today = os.date('%j')\n\tlocal config = Config.load('version', {\n\t\tpackages = date,\n\t\tchecked = today,\n\t})\n\n\t-- check if packages need an update\n\tif date ~= config.packages then\n\t\tconfig.packages = date\n\t\tConfig.update('version', config)\n\t\tprint('Updating packages')\n\t\tshell.run('package updateall')\n\t\tos.reboot()\n\tend\n\n\tif type(date) == 'string' and #date > 0 then\n\t\tif config.checked ~= today then\n\t\t\tconfig.checked = today\n\t\t\tConfig.update('version', config)\n\t\t\tprint('Checking for new version')\n\t\t\tpcall(function()\n\t\t\t\tlocal c = Util.httpGet(string.format(URL, _G.OPUS_BRANCH))\n\t\t\t\tif c then\n\t\t\t\t\tlocal lines = Util.split(c)\n\t\t\t\t\tlocal revdate = table.remove(lines, 1)\n\t\t\t\t\tif date ~= revdate and config.skip ~= revdate then\n\t\t\t\t\t\tconfig.current = revdate\n\t\t\t\t\t\tconfig.details = table.concat(lines, '\\n')\n\t\t\t\t\t\tConfig.update('version', config)\n\t\t\t\t\t\tprint('New version available')\n\t\t\t\t\t\tif _ENV.multishell then\n\t\t\t\t\t\t\tshell.openForegroundTab('sys/apps/Version.lua')\n\t\t\t\t\t\tend\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\tend)\n\t\tend\n\tend\nend\n", "sys/autorun/log.lua": "--[[\n\tAdds a task and the control-d hotkey to view the kernel log.\n--]]\n\nlocal kernel     = _G.kernel\nlocal keyboard   = _G.device.keyboard\nlocal os         = _G.os\n\nlocal function systemLog()\n\tlocal routine = kernel.getCurrent()\n\n\tkernel.hook('mouse_scroll', function(_, eventData)\n\t\tlocal dir, y = eventData[1], eventData[3]\n\n\t\tif y > 1 then\n\t\t\tlocal currentTab = kernel.getFocused()\n\t\t\tif currentTab == routine then\n\t\t\t\tif currentTab.terminal.scrollUp then\n\t\t\t\t\tif dir == -1 then\n\t\t\t\t\t\tcurrentTab.terminal.scrollUp()\n\t\t\t\t\telse\n\t\t\t\t\t\tcurrentTab.terminal.scrollDown()\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend)\n\n\tkeyboard.addHotkey('control-d', function()\n\t\tlocal current = kernel.getFocused()\n\t\tif current.uid ~= routine.uid then\n\t\t\tkernel.raise(routine.uid)\n\t\telseif kernel.routines[2] then\n\t\t\tkernel.raise(kernel.routines[2].uid)\n\t\tend\n\tend)\n\n\tos.pullEventRaw('terminate')\n\tkeyboard.removeHotkey('control-d')\nend\n\nkernel.run(_ENV, {\n\ttitle = 'System Log',\n\tfn = systemLog,\n\tnoTerminate = true,\n\thidden = true,\n})\n", "sys/autorun/hotkeys.lua": "local Util = require('opus.util')\n\nlocal kernel     = _G.kernel\nlocal keyboard   = _G.device.keyboard\nlocal multishell = _ENV.multishell\n\nif multishell and multishell.getTabs then\n\t-- restart tab\n\tkeyboard.addHotkey('control-backspace', function()\n\t\tlocal tab = kernel.getFocused()\n\t\tif tab and not tab.noTerminate then\n\t\t\tmultishell.terminate(tab.uid)\n\t\t\tmultishell.openTab(tab.env, {\n\t\t\t\tpath = tab.path,\n\t\t\t\targs = tab.args,\n\t\t\t\tfocused = true,\n\t\t\t})\n\t\tend\n\tend)\nend\n\n-- next tab\nkeyboard.addHotkey('control-tab', function()\n\tlocal visibleTabs = { }\n\tlocal currentTab = kernel.getFocused()\n\n\tlocal function compareTab(a, b)\n\t\treturn a.uid < b.uid\n\tend\n\tfor _,tab in Util.spairs(kernel.routines, compareTab) do\n\t\tif not tab.hidden and not tab.noFocus then\n\t\t\ttable.insert(visibleTabs, tab)\n\t\tend\n\tend\n\n\tfor k,tab in ipairs(visibleTabs) do\n\t\tif tab.uid == currentTab.uid then\n\t\t\tif k < #visibleTabs then\n\t\t\t\tkernel.raise(visibleTabs[k + 1].uid)\n\t\t\t\treturn\n\t\t\tend\n\t\tend\n\tend\n\tif #visibleTabs > 0 then\n\t\tkernel.raise(visibleTabs[1].uid)\n\tend\nend)\n", "sys/autorun/welcome.lua": "local Config = require('opus.config')\nlocal Util   = require('opus.util')\n\nlocal fs     = _G.fs\nlocal os     = _G.os\nlocal shell  = _ENV.shell\n\nlocal config = Config.load('os')\nif not config.welcomed then\n\tconfig.welcomed = true\n\tconfig.securityUpdate = true\n\tconfig.readNotes = 1\n\tConfig.update('os', config)\n\tif shell.openForegroundTab then\n\t\tshell.openForegroundTab('Welcome')\n\tend\nend\n\nif not config.securityUpdate then\n\tconfig.securityUpdate = true\n\tconfig.secretKey = nil\n\tconfig.password = nil\n\tconfig.readNotes = 1\n\tConfig.update('os', config)\n\n\tfs.delete('usr/.known_hosts')\n\n\tUtil.writeFile('sys/notes_1.txt', [[\nAn important security update has been applied.\n\nUnfortunately, this update has reset the\npassword on the system. You can set a new\npassword in System->System->Password.\n\nAll computers that you connect to will also\nneed to be updated as well.\n\nAlso, I have changed the location for apis.\nThis will require you to update all installed\npackages. Sorry !\n\nThanks for your patience. And... thanks to\nAnavrins for the much improved security.\n]])\nend\n\nif fs.exists('sys/notes_1.txt') and shell.openForegroundTab then\n\tshell.openForegroundTab('edit sys/notes_1.txt')\n\tos.sleep(2)\n\tfs.delete('sys/notes_1.txt')\nend\n", "sys/etc/fstab": "sys/apps/pain.lua urlfs https://github.com/LDDestroier/CC/raw/master/pain.lua\nsys/apps/update.lua urlfs http://pastebin.com/raw/UzGHLbNC\nsys/apps/Enchat.lua urlfs https://raw.githubusercontent.com/LDDestroier/enchat/master/enchat3.lua\nsys/apps/cloud.lua urlfs https://cloud-catcher.squiddev.cc/cloud.lua\nrom/modules/main/opus linkfs sys/modules/opus", "sys/etc/apps.db": "{\n\t[ \"0a999012ffb87b3edac99adbdfc498b12831a1e2\" ] = {\n\t\ttitle = \"Packages\",\n\t\tcategory = \"System\",\n\t\trun = \"PackageManager.lua\",\n\t\ticonExt = \"\\030c\\0317\\151\\131\\131\\131\\0307\\031c\\148\\010\\030c\\0317\\151\\131\\0310\\143\\0317\\131\\0307\\031c\\148\\010\\0307\\031c\\138\\030 \\0317\\151\\131\\131\\131\",\n\t},\n\t[ \"b2efeaa1a7d6d2185ea02473cf758203dfcea3fe\" ] = {\n\t\ttitle = \"Cloud\",\n\t\tcategory = \"Apps\",\n\t\trun = \"cshell.lua\",\n\t\ticonExt = \"\\0300\\031 \\159\\131\\135\\0310\\128\\128\\031 \\139\\131\\030 \\0310\\144\\010\\0300\\128\\031f\\137\\144\\0310\\128\\030a\\136\\149\\133\\0300\\128\\010\\0300\\031 \\144\\031f\\134\\136\\132\\031a\\142\\138\\138\\030 \\0310\\159\",\n\t},\n\t[ \"53ebc572b4a44802ba114729f07bdaaf5409a9d7\" ] = {\n\t\ttitle = \"Network\",\n\t\tcategory = \"Apps\",\n\t\ticon = \"\\0304  \\030    \\010\\030f \\0304 \\0307 \\030 \\031  \\031f)\\010\\030f \\0304 \\0307 \\030 \\031f)\",\n\t\ticonExt = \"\\030 \\031 \\128\\128\\128\\128\\0305\\140\\030 \\0315\\137\\144\\010\\0314\\131\\131\\0304\\031f\\148\\030 \\031 \\128\\0305\\155\\150\\149\\010\\147\\0300\\031f\\141\\0304\\149\\0307\\0318\\149\\030 \\031 \\128\\128\\128\",\n\t\trun = \"Network.lua\",\n\t},\n\t[ \"c7116629a6a855cb774d9c7c8ad822fd83c71fb5\" ] = {\n\t\ttitle = \"Reboot\",\n\t\tcategory = \"System\",\n\t\ticon = \"\\0304\\031f \\030f\\0310o..\\0304\\031f \\010\\0304\\031f \\030f\\0310.o.\\0304\\031f \\010\\0304\\031f   - \",\n\t\ticonExt = \"\\0307\\031 \\135\\0300\\0317\\159\\0307\\0310\\144\\031 \\139\\010\\0300\\0317\\131\\0307\\0310\\147\\0300\\0317\\156\\131\\010\\030 \\130\\143\\143\\129\",\n\t\trun = \"rom/programs/reboot\",\n\t},\n\t[ \"fb91e24fa52d8d2b32937bf04d843f730319a902\" ] = {\n\t\ttitle = \"Update\",\n\t\tcategory = \"System\",\n\t\ticon = \"\\0301\\03171\\03180\\030 \\031   \\010\\0301\\03181\\030 \\031    \\010\\0301\\03170\\03180\\03171\\0307\\031f>\",\n\t\ticonExt = \"\\030 \\031 \\128\\0313\\152\\131\\131\\132\\031 \\128\\010\\030 \\0313\\139\\159\\129\\0303\\031 \\159\\129\\139\\010\\030 \\031 \\128\\0313\\136\\0303\\031 \\143\\143\\030 \\0313\\134\\031 \\128\",\n\t\trun = \"update update\",\n\t},\n\t[ \"c47ae15370cfe1ed2781eedc1dc2547d12d9e972\" ] = {\n\t\ttitle = \"Help\",\n\t\tcategory = \"Apps\",\n\t\ticon = \"\\030 \\0310  ? \\010\\030 \\0310?   \\010\\030 \\0310\\009 ?\",\n\t\ticonExt = \"\\0300\\031 \\129\\030 \\0310\\131\\0300\\031 \\148\\030 \\0310\\148\\010\\030 \\031 \\128\\0300\\131\\030 \\0310\\142\\129\\010\\030 \\031 \\128\\0300\\131\\030 \\128\\128\",\n\t\trun = \"Help.lua\",\n\t},\n\t[ \"b0832074630eb731d7fbe8074de48a90cd9bb220\" ] = {\n\t\ttitle = \"Lua\",\n\t\tcategory = \"Apps\",\n\t\ticon = \"\\030      \\010\\030 \\0310lua>\\031  \\010\\030      \",\n\t\ticonExt = \"\\0300\\031 \\151\\030 \\128\\0300\\159\\159\\159\\030 \\0310\\144\\0304\\031 \\159\\030 \\128\\010\\0300\\031 \\149\\030 \\128\\0300\\149\\149\\151\\145\\030 \\128\\0314\\153\\010\\030 \\130\\131\\130\\131\\130\\131\\0314\\130\\031 \\128\",\n\t\trun = \"Lua.lua\",\n\t},\n\t[ \"bc0792d8dc81e8aa30b987246a5ce97c40cd6833\" ] = {\n\t\ttitle = \"System\",\n\t\tcategory = \"System\",\n\t\ticon = \"\\030    \\0307\\031f| \\010\\0307\\031f---o\\030 \\031  \\010\\030 \\009 \\0307\\031f| \",\n\t\ticonExt = \"\u001e2\u001f2\u0080\u001e0\u008f\u001e7\u001f0\u0086\u001eb\u009d\u001e0\u001f2\u008b\u001e4\u009f\u008f\u001e2\u001f4\u0090\\\n\u001e0\u001f2\u0097\u001f7\u008e\u001e7\u001f0\u0090\u001f4\u0088\u001e4\u0080\u0080\u0080\u0080\\\n\u001e7\u0081\u0083\u001e0\u001f7\u0084\u001f1\u0083\u001f7\u008b\u001e2\u001f4\u0083\u0083\u0081\",\n\t\t--iconExt = \"\\030 \\0318\\138\\0308\\031 \\130\\0318\\128\\031 \\129\\030 \\0318\\133\\010\\030 \\0318\\143\\0308\\128\\0317\\143\\0318\\128\\030 \\143\\010\\030 \\0318\\138\\135\\143\\139\\133\",\n\t\trun = \"System.lua\",\n\t},\n\t[ \"2a4d562b1d9a9c90bdede6fac8ce4f7402462b86\" ] = {\n\t\ttitle = \"Tasks\",\n\t\tcategory = \"System\",\n\t\ticon = \"\\030 \\031f    \\0315/\\010\\030 \\031f \\0315/\\\\/ \\010\\030 \\0315/\\031f    \",\n\t\ticonExt = \"\\030 \\031 \\128\\128\\0305\\159\\030 \\128\\0305\\159\\030 \\0315\\134\\031 \\128\\010\\030 \\031 \\128\\0315\\152\\129\\137\\0305\\031 \\158\\139\\030 \\128\\010\\030 \\0315\\134\\031 \\128\\128\\128\\128\\0305\\154\\030 \\128\",\n\t\trun = \"Tasks.lua\",\n\t},\n\t[ \"a0365977708b7387ee9ce2c13e5820e6e11732cb\" ] = {\n\t\ttitle = \"Pain\",\n\t\tcategory = \"Apps\",\n\t\ticonExt = \"\\0307\\031 \\159\\030 \\128\\128\\128\\128\\128\\128\\128\\010\\0308\\031 \\135\\0307\\0318\\144\\140\\030 \\0317\\159\\143\\031c\\139\\0302\\135\\030 \\0312\\157\\010\\030 \\0318\\143\\133\\0312\\136\\0302\\031 \\159\\159\\143\\131\\030 \\0312\\132\",\n\t\trun = \"pain\",\n\t},\n\t[ \"6a381ca189cbddd63737cbaf6e8b593844ce467ba52b1c5e5e05d8f29864385d\" ] = {\n\t\ttitle = \"Sniffer\",\n\t\tcategory = \"Apps\",\n\t\ticonExt = \"\\030 \\031 \\128\\128\\128\\128\\0315\\149\\0305\\031 \\154\\030 \\0315\\137\\010\\0304\\031 \\159\\0314\\128\\128\\030 \\144\\0315\\130\\0305\\031 \\155\\140\\010\\0314\\151\\0304\\031f\\148\\030f\\0314\\151\\0304\\031f\\148\\030 \\031 \\128\\128\\128\",\n\t\trun = \"Sniff.lua\",\n\t},\n\t[ \"01c933b2a36ad8ed2d54089cb2903039046c1216\" ] = {\n\t\ttitle = \"Enchat\",\n\t\ticonExt = \"\\030e\\031f\\151\\030f\\031e\\156\\0311\\140\\0314\\140\\0315\\140\\031d\\140\\031b\\140\\031a\\132\\010\\030f\\0314\\128\\030e\\031f\\132\\030f\\031e\\132\\0318nchat\\010\\030f\\031e\\138\\141\\0311\\140\\0314\\140\\0315\\132\\0317v\\03183\\031a\\132\",\n\t\tcategory = \"Apps\",\n\t\trun = \"Enchat\",\n\t},\n\t[ \"6ce6c512ea433a7fc5c8841628e7696cd0ff7f2b\" ] = {\n\t\ttitle = \"Files\",\n\t\tcategory = \"Apps\",\n\t\ticon = \"\\0300\\0317==\\031  \\0307 \\010\\0300\\0317====\\010\\0300\\0317====\",\n\t\ticonExt = \"\\0300\\031f\\136\\140\\132\\0308\\031 \\130\\030 \\0318\\144\\010\\157\\0300\\031f\\147\\030f\\0310\\142\\143\\030 \\149\\010\\0300\\031f\\136\\140\\132\\140\\030 \\0310\\149\",\n\t\trun = \"Files.lua\",\n\t},\n\t[ \"7fddb7d8d1d60b1eeefa9af01082e0811d4b484d\" ] = {\n\t\ttitle = \"Shutdown\",\n\t\tcategory = \"System\",\n\t\ticon = \"\\0304\\031f     \\010\\0304\\031f \\030f\\0310zz\\031   \\010\\0304\\031f \\030f    \",\n\t\ticonExt = \"\\030e\\031 \\135\\030 \\031e\\148\\030e\\128\\031 \\151\\139\\010\\030e\\031e\\128\\030 \\031 \\128\\031e\\143\\031 \\128\\030e\\031e\\128\\010\\030 \\031e\\139\\030e\\031 \\130\\131\\129\\030 \\031e\\135\",\n\t\trun = \"/rom/programs/shutdown\",\n\t},\n\t[ \"bdc1fd5d3c0f3dcfd55d010426e61bf9451e680d\" ] = {\n\t\ttitle = \"Shell\",\n\t\tcategory = \"Apps\",\n\t\ticon = \"\\0304     \\030  \\010\\0304 \\030f\\0314> \\0310_\\031  \\010\\0304 \\030f    \\030  \",\n\t\ticonExt = \"\\030f\\0314\\151\\131\\131\\131\\131\\010\\030f\\0314\\149\\030f\\0314> \\0310_ \\010\\030f\\0314\\149\\030f    \",\n\t\trun = \"shell\",\n\t},\n\t[ \"b77aad5fb24921ef76ac8f3e500ed93fddae8f2a\" ] = {\n\t\ttitle = \"Redirection\",\n\t\tcategory = \"Games\",\n\t\ticon = \"\\0307  \\0308 \\0307 \\010\\0308\\031b> \\030b\\0310>\\0308\\0318 \\010\\0307    \",\n\t\trun = \"rom/programs/fun/advanced/redirection\",\n\t\trequires = 'advanced',\n\t},\n\t[ \"f39d173d91c22348565c20283b89d4d1cabd3b7e\" ] = {\n\t\ttitle = \"Falling\",\n\t\tcategory = \"Games\",\n\t\ticon = \"\\030f \\0302   \\010\\0309  \\0302 \\0301 \\010\\030e \\0309  \\0301 \",\n\t\trun = \"rom/programs/pocket/falling\",\n\t\trequires = 'advancedPocket',\n\t},\n\t[ \"db56e2e1db9f7accfc37f2b132d27505c66ba521\" ] = {\n\t\ttitle = \"Adventure\",\n\t\tcategory = \"Games\",\n\t\ticon = \"\\030f\\0310You \\031 \\010\\030f\\0310Ther\\030 \\031  \\010\\030f\\0314?\\031f \\031   \\030  \",\n\t\trun = \"rom/programs/fun/adventure\",\n\t},\n\t[ \"76b849f460640bc789c433894382fb5acbac42a2\" ] = {\n\t\ttitle = \"Worm\",\n\t\tcategory = \"Games\",\n\t\ticon = \"\\030d \\030  \\030e \\030  \\010\\030d \\030    \\010\\030d    \",\n\t\ticonExt = \"\\0305\\031 \\151\\030 \\0315\\135\\131\\0305\\031 \\146\\010\\030 \\0315\\130\\141\\0305\\031 \\139\\030 \\0315\\130\\010\\0305\\031 \\146\\143\\030 \\0315\\158\\031e\\130\",\n\t\trun = \"/rom/programs/fun/worm\",\n\t},\n\t[ \"9f46ca3ef617166776ef6014a58d4e66859caa62\" ] = {\n\t\ttitle = \"DJ\",\n\t\tcategory = \"Games\",\n\t\ticon = \" \\030f   \\010\\030f  \\0307  \\010\\030f \\0307  \\0300 \",\n\t\ticonExt = \"\\030 \\031 \\128\\0307\\143\\131\\131\\131\\131\\143\\030 \\128\\010\\0307\\031 \\129\\0317\\128\\0319\\136\\0309\\031b\\136\\132\\0307\\0319\\132\\0317\\128\\031 \\130\\010\\030 \\0317\\130\\143\\0307\\128\\128\\128\\128\\030 \\143\\129\",\n\t\trun = \"/rom/programs/fun/dj\",\n\t},\n\t[ \"4dbdd221e957eff27cc47796f3ed8447290f71c7ad8b95e5bd828b31c1858f15\" ] = {\n\t\ttitle = \"Partition\",\n\t\tcategory = \"System\",\n\t\ticonExt = \"\\30\\55\\31\\55\\128\\30\\48\\135\\131\\139\\30\\55\\128\\128\\128\\10\\30\\48\\31\\55\\149\\31\\48\\128\\30\\55\\145\\30\\48\\31\\56\\140\\30\\55\\157\\144\\144\\10\\30\\55\\31\\55\\128\\31\\48\\139\\143\\135\\31\\55\\128\\31\\56\\142\\133\",\n\t\trun = \"Partition\",\n\t}\n}\n", "sys/modules/opus/bulkget.lua": "local Util = require('opus.util')\n\nlocal parallel = _G.parallel\n\nlocal BulkGet = { }\n\nfunction BulkGet.download(list, callback)\n\tlocal t = { }\n\tlocal failed = false\n\n\tfor _ = 1, 5 do\n\t\ttable.insert(t, function()\n\t\t\twhile true do\n\t\t\t\tlocal entry = table.remove(list)\n\t\t\t\tif not entry then\n\t\t\t\t\tbreak\n\t\t\t\tend\n\t\t\t\tlocal s, m = Util.download(entry.url, entry.path)\n\t\t\t\tif not s then\n\t\t\t\t\tfailed = true\n\t\t\t\tend\n\t\t\t\tcallback(entry, s, m)\n\t\t\t\tif failed then\n\t\t\t\t\tbreak\n\t\t\t\tend\n\t\t\tend\n\t\tend)\n\tend\n\n\tparallel.waitForAll(table.unpack(t))\nend\n\nreturn BulkGet\n", "sys/modules/opus/class.lua": "-- From http://lua-users.org/wiki/SimpleLuaClasses\n-- (with some modifications)\n\n-- class.lua\n-- Compatible with Lua 5.1 (not 5.0).\nreturn function(base)\n\tlocal c = { }    -- a new class instance\n\tif type(base) == 'table' then\n\t\t-- our new class is a shallow copy of the base class!\n\t\tif base._preload then\n\t\t\tbase = base._preload(base)\n\t\tend\n\t\tfor i,v in pairs(base) do\n\t\t\tc[i] = v\n\t\tend\n\t\tc._base = base\n\tend\n\t-- the class will be the metatable for all its objects,\n\t-- and they will look up their methods in it.\n\tc.__index = c\n\n\t-- expose a constructor which can be called by <classname>(<args>)\n\tsetmetatable(c, {\n\t\t__call = function(class_tbl, ...)\n\t\t\tlocal obj = { }\n\t\t\tsetmetatable(obj,c)\n\t\t\tif class_tbl.init then\n\t\t\t\tclass_tbl.init(obj, ...)\n\t\t\telse\n\t\t\t\t-- make sure that any stuff from the base class is initialized!\n\t\t\t\tif base and base.init then\n\t\t\t\t\tbase.init(obj, ...)\n\t\t\t\tend\n\t\t\tend\n\t\t\treturn obj\n\t\tend\n\t})\n\n\tc.is_a =\n\t\tfunction(self, klass)\n\t\t\tlocal m = getmetatable(self)\n\t\t\twhile m do\n\t\t\t\tif m == klass then return true end\n\t\t\t\tm = m._base\n\t\t\tend\n\t\t\treturn false\n\t\tend\n\treturn c\nend\n", "sys/modules/opus/event.lua": "local os    = _G.os\nlocal table = _G.table\n\nlocal Event = {\n\tuid       = 1,       -- unique id for handlers\n\troutines  = { },     -- coroutines\n\ttypes     = { },     -- event handlers\n\tterminate = false,\n\tfree      = { },     -- allocated unused coroutines\n}\n\n-- Use a pool of coroutines for event handlers\nlocal function createCoroutine(h)\n\tlocal co = table.remove(Event.free)\n\tif not co then\n\t\tco = coroutine.create(function(_, ...)\n\t\t\tlocal args = { ... }\n\t\t\twhile true do\n\t\t\t\th.fn(table.unpack(args))\n\t\t\t\th.co = nil\n\t\t\t\ttable.insert(Event.free, co)\n\t\t\t\targs = { coroutine.yield() }\n\t\t\t\th = table.remove(args, 1)\n\t\t\t\th.co = co\n\t\t\tend\n\t\tend)\n\tend\n\th.primeCo = true -- TODO: fix...\n\treturn co\nend\n\nlocal Routine = { }\n\nfunction Routine:isDead()\n\tif not self.co then\n\t\treturn true\n\tend\n\treturn coroutine.status(self.co) == 'dead'\nend\n\nfunction Routine:terminate()\n\tif self.co then\n\t\tself:resume('terminate')\n\tend\nend\n\nfunction Routine:resume(event, ...)\n\tif not self.co then\n\t\terror('Cannot resume a dead routine')\n\tend\n\n\tif not self.filter or self.filter == event or event == \"terminate\" then\n\t\tlocal s, m\n\t\tif self.primeCo then\n\t\t\t-- Only need self passed when using a coroutine from the pool\n\t\t\ts, m = coroutine.resume(self.co, self, event, ...)\n\t\t\tself.primeCo = nil\n\t\telse\n\t\t\ts, m = coroutine.resume(self.co, event, ...)\n\t\tend\n\n\t\tif not s and event ~= 'terminate' then\n\t\t\tif m and type(debug) == 'table' and debug.traceback then\n\t\t\t\tlocal t = (debug.traceback(self.co, 1)) or ''\n\t\t\t\tm = m .. '\\n' .. t:match('%d\\n(.+)')\n\t\t\tend\n\t\tend\n\n\t\tif self:isDead() then\n\t\t\tself.co = nil\n\t\t\tself.filter = nil\n\t\t\tEvent.routines[self.uid] = nil\n\t\telse\n\t\t\tself.filter = m\n\t\tend\n\n\t\tif not s and event ~= 'terminate' then\n\t\t\terror(m or 'Error processing event', -1)\n\t\tend\n\n\t\treturn s, m\n\tend\n\n\treturn true, self.filter\nend\n\nlocal function nextUID()\n\tEvent.uid = Event.uid + 1\n\treturn Event.uid - 1\nend\n\nfunction Event.on(events, fn)\n\tevents = type(events) == 'table' and events or { events }\n\n\tlocal handler = setmetatable({\n\t\tuid     = nextUID(),\n\t\tevent   = events,\n\t\tfn      = fn,\n\t}, { __index = Routine })\n\n\tfor _,event in pairs(events) do\n\t\tlocal handlers = Event.types[event]\n\t\tif not handlers then\n\t\t\thandlers = { }\n\t\t\tEvent.types[event] = handlers\n\t\tend\n\n\t\thandlers[handler.uid] = handler\n\tend\n\n\treturn handler\nend\n\nfunction Event.off(h)\n\tif h and h.event then\n\t\tfor _,event in pairs(h.event) do\n\t\t\tlocal handler = Event.types[event][h.uid]\n\t\t\tif handler then\n\t\t\t\thandler:terminate()\n\t\t\tend\n\t\t\tEvent.types[event][h.uid] = nil\n\t\tend\n\telseif h and h.co then\n\t\th:terminate()\n\tend\nend\n\nfunction Event.onInterval(interval, fn)\n\tlocal h = Event.addRoutine(function()\n\t\twhile true do\n\t\t\tos.sleep(interval)\n\t\t\tfn()\n\t\tend\n\tend)\n\tfunction h.updateInterval(i)\n\t\tinterval = i\n\tend\n\treturn h\nend\n\nfunction Event.onTimeout(timeout, fn)\n\tlocal timerId = os.startTimer(timeout)\n\tlocal handler\n\n\thandler = Event.on('timer', function(t, id)\n\t\tif timerId == id then\n\t\t\tfn(t, id)\n\t\t\tEvent.off(handler)\n\t\tend\n\tend)\n\n\treturn handler\nend\n\n-- Set a handler for the terminate event. Within the function, return\n-- true or false to indicate whether the event should be propagated to\n-- all sub-threads\nfunction Event.onTerminate(fn)\n\tEvent.termFn = fn\nend\n\nfunction Event.termFn()\n\tEvent.terminate = true\n\treturn true -- propagate\nend\n\nfunction Event.addRoutine(fn)\n\tlocal r = setmetatable({\n\t\tco  = coroutine.create(fn),\n\t\tuid = nextUID()\n\t}, { __index = Routine })\n\n\tEvent.routines[r.uid] = r\n\tr:resume()\n\n\treturn r\nend\n\nfunction Event.pullEvents(...)\n\tfor _, fn in ipairs({ ... }) do\n\t\tEvent.addRoutine(fn)\n\tend\n\n\trepeat\n\t\tEvent.pullEvent()\n\tuntil Event.terminate\n\n\tEvent.terminate = false\nend\n\nfunction Event.exitPullEvents()\n\tEvent.terminate = true\n\tos.sleep(0)\nend\n\nlocal function processHandlers(event)\n\tlocal handlers = Event.types[event]\n\tif handlers then\n\t\tfor _,h in pairs(handlers) do\n\t\t\tif not h.co then\n\t\t\t\t-- callbacks are single threaded (only 1 co per handler)\n\t\t\t\th.co = createCoroutine(h)\n\t\t\t\tEvent.routines[h.uid] = h\n\t\t\tend\n\t\tend\n\tend\nend\n\nlocal function tokeys(t)\n\tlocal keys = { }\n\tfor k in pairs(t) do\n\t\tkeys[#keys+1] = k\n\tend\n\treturn keys\nend\n\nlocal function processRoutines(...)\n\tlocal keys = tokeys(Event.routines)\n\tfor _,key in ipairs(keys) do\n\t\tlocal r = Event.routines[key]\n\t\tif r then\n\t\t\tr:resume(...)\n\t\tend\n\tend\nend\n\n-- invoke the handlers registered for this event\nfunction Event.trigger(event, ...)\n\tlocal handlers = Event.types[event]\n\tif handlers then\n\t\tfor _,h in pairs(handlers) do\n\t\t\tif not h.co then\n\t\t\t\t-- callbacks are single threaded (only 1 co per handler)\n\t\t\t\th.co = createCoroutine(h)\n\t\t\t\tEvent.routines[h.uid] = h\n\t\t\t\th:resume(event, ...)\n\t\t\tend\n\t\tend\n\tend\nend\n\nfunction Event.processEvent(e)\n\tprocessHandlers(e[1])\n\tprocessRoutines(table.unpack(e))\nend\n\nfunction Event.pullEvent(eventType)\n\twhile true do\n\t\tlocal e = { os.pullEventRaw() }\n\t\tlocal propagate = true           -- don't like this...\n\n\t\tif e[1] == 'terminate' then\n\t\t\tpropagate = Event.termFn()\n\t\tend\n\n\t\tif propagate then\n\t\t\tprocessHandlers(e[1])\n\t\t\tprocessRoutines(table.unpack(e))\n\t\tend\n\n\t\tif Event.terminate then\n\t\t\treturn { 'terminate' }\n\t\tend\n\n\t\tif not eventType or e[1] == eventType then\n\t\t\treturn e\n\t\tend\n\tend\nend\n\nreturn Event\n", "sys/modules/opus/gps.lua": "local Util = require('opus.util')\n\nlocal GPS = { }\nGPS.CHANNEL_GPS = 65534\n\nlocal device = _G.device\nlocal vector = _G.vector\n\nfunction GPS.locate(timeout, debug)\n\tif not device.wireless_modem then\n\t\tif debug then\n\t\t\tprint('No wireless modem attached')\n\t\tend\n\t\treturn nil\n\tend\n\n\tif debug then\n\t\tprint('Finding position...')\n\tend\n\n\tlocal modem = device.wireless_modem\n\tlocal closeChannel = false\n\tif not modem.isOpen(GPS.CHANNEL_GPS) then\n\t\tmodem.open(GPS.CHANNEL_GPS)\n\t\tcloseChannel = true\n\tend\n\n\tmodem.transmit(GPS.CHANNEL_GPS, GPS.CHANNEL_GPS, \"PING\")\n\n\tlocal fixes = {}\n\tlocal pos = nil\n\tlocal timer = os.startTimer(timeout or 1)\n\twhile true do\n\t\tlocal e, side, chan, reply, msg, dist = os.pullEvent()\n\t\tif e == \"modem_message\" then\n\t\t\tif side == modem.side and chan == GPS.CHANNEL_GPS and reply == GPS.CHANNEL_GPS and dist then\n\t\t\t\tif type(msg) == \"table\" and #msg == 3 and tonumber(msg[1]) and tonumber(msg[2]) and tonumber(msg[3]) then\n\t\t\t\t\tlocal fix = {\n\t\t\t\t\t\tposition = vector.new(unpack(msg)),\n\t\t\t\t\t\tdistance = dist,\n\t\t\t\t\t}\n\t\t\t\t\tif debug then\n\t\t\t\t\t\tprint(fix.distance..' meters from '..fix.position:tostring())\n\t\t\t\t\tend\n\t\t\t\t\tif fix.distance == 0 then\n\t\t\t\t\t\tpos = fix.position\n\t\t\t\t\telse\n\t\t\t\t\t\tfixes[#fixes+1] = fix\n\t\t\t\t\t\tif #fixes > 3 then\n\t\t\t\t\t\t\tpos = GPS.trilaterate(fixes)\n\t\t\t\t\t\t\tif pos then break end\n\t\t\t\t\t\tend\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\tend\n\t\telseif e == \"timer\" and side == timer then\n\t\t\tbreak\n\t\tend\n\tend\n\n\tif closeChannel then\n\t\tmodem.close(GPS.CHANNEL_GPS)\n\tend\n\tif debug then\n\t\tprint(\"Position is \"..pos.x..\",\"..pos.y..\",\"..pos.z)\n\tend\n\treturn pos and vector.new(pos.x, pos.y, pos.z)\nend\n\nfunction GPS.isAvailable()\n\treturn device.wireless_modem and GPS.locate()\nend\n\nfunction GPS.getPoint(timeout, debug)\n\tlocal pt = GPS.locate(timeout, debug)\n\tif not pt then\n\t\treturn\n\tend\n\n\tpt.x = math.floor(pt.x)\n\tpt.y = math.floor(pt.y)\n\tpt.z = math.floor(pt.z)\n\n\tif _G.pocket then\n\t\tpt.y = pt.y - 1\n\tend\n\n\treturn pt\nend\n\n-- from stock gps API\nlocal function trilaterate(A, B, C)\n\tlocal a2b = B.position - A.position\n\tlocal a2c = C.position - A.position\n\n\tif math.abs( a2b:normalize():dot( a2c:normalize() ) ) > 0.999 then\n\t\treturn\n\tend\n\n\tlocal d = a2b:length()\n\tlocal ex = a2b:normalize( )\n\tlocal i = ex:dot( a2c )\n\tlocal ey = (a2c - (ex * i)):normalize()\n\tlocal j = ey:dot( a2c )\n\tlocal ez = ex:cross( ey )\n\n\tlocal r1 = A.distance\n\tlocal r2 = B.distance\n\tlocal r3 = C.distance\n\n\tlocal x = (r1*r1 - r2*r2 + d*d) / (2*d)\n\tlocal y = (r1*r1 - r3*r3 - x*x + (x-i)*(x-i) + j*j) / (2*j)\n\n\tlocal result = A.position + (ex * x) + (ey * y)\n\n\tlocal zSquared = r1*r1 - x*x - y*y\n\tif zSquared > 0 then\n\t\tlocal z = math.sqrt( zSquared )\n\t\tlocal result1 = result + (ez * z)\n\t\tlocal result2 = result - (ez * z)\n\n\t\tlocal rounded1, rounded2 = result1:round(0.01), result2:round(0.01)\n\t\tif rounded1.x ~= rounded2.x or rounded1.y ~= rounded2.y or rounded1.z ~= rounded2.z then\n\t\t\treturn rounded1, rounded2\n\t\telse\n\t\t\treturn rounded1\n\t\tend\n\tend\n\treturn result:round(0.01)\nend\n\nlocal function narrow( p1, p2, fix )\n\tlocal dist1 = math.abs( (p1 - fix.position):length() - fix.distance )\n\tlocal dist2 = math.abs( (p2 - fix.position):length() - fix.distance )\n\n\tif math.abs(dist1 - dist2) < 0.01 then\n\t\treturn p1, p2\n\telseif dist1 < dist2 then\n\t\treturn p1:round(0.01)\n\telse\n\t\treturn p2:round(0.01)\n\tend\nend\n-- end stock gps api\n\nfunction GPS.trilaterate(tFixes)\n\tlocal attemps = 0\n\tfor tFixes in Util.permutation(tFixes) do\n\t\tattemps = attemps + 1\n\t\tlocal pos1, pos2 = trilaterate(tFixes[4], tFixes[3], tFixes[2])\n\t\tif pos2 then\n\t\t\tpos1, pos2 = narrow(pos1, pos2, tFixes[1])\n\t\tend\n\t\tif not pos2 and pos1 and not (pos1.x ~= pos1.x) then\n\t\t\treturn pos1, attemps\n\t\tend\n\tend\nend\n\nreturn GPS", "sys/modules/opus/fuzzy.lua": "local find  = string.find\nlocal floor = math.floor\nlocal min   = math.min\nlocal max   = math.max\nlocal sub   = string.sub\n\n-- https://rosettacode.org/wiki/Jaro_distance (ported to lua)\nreturn function(s1, s2)\n\tlocal l1, l2 = #s1, #s2;\n\tif l1 == 0 then\n\t\treturn l2 == 0 and 1.0 or 0.0\n\tend\n\n\tlocal match_distance = max(floor(max(l1, l2) / 2) - 1, 0)\n\tlocal s1_matches = { }\n\tlocal s2_matches = { }\n\tlocal matches = 0\n\n\tfor i = 1, l1 do\n\t\tlocal _end = min(i + match_distance + 1, l2)\n\t\tfor k = max(1, i - match_distance), _end do\n\t\t\tif not s2_matches[k] and sub(s1, i, i) == sub(s2, k, k) then\n\t\t\t\ts1_matches[i] = true\n\t\t\t\ts2_matches[k] = true\n\t\t\t\tmatches = matches + 1\n\t\t\t\tbreak\n\t\t\tend\n\t\tend\n\tend\n\tif matches == 0 then\n\t\treturn 0.0\n\tend\n\n\tlocal t = 0.0\n\tlocal k = 1\n\tfor i = 1, l1 do\n\t\tif s1_matches[i] then\n\t\t\twhile not s2_matches[k] do\n\t\t\t\tk = k + 1\n\t\t\tend\n\t\t\tif sub(s1, i, i) ~= sub(s2, k, k) then\n\t\t\t\tt = t + 0.5\n\t\t\tend\n\t\t\tk = k + 1\n\t\tend\n\tend\n\n\t-- provide a major boost for exact matches\n\tlocal b = 0.0\n\tif find(s1, s2, 1, true) then\n\t\tb = b + .5\n\tend\n\n\tlocal m = matches\n\treturn (m / l1 + m / l2 + (m - t) / m) / 3.0 + b\nend\n", "sys/modules/opus/git.lua": "local json = require('opus.json')\nlocal Util = require('opus.util')\n\nlocal TREE_URL = 'https://api.github.com/repos/%s/%s/git/trees/%s?recursive=1'\nlocal FILE_URL = 'https://raw.githubusercontent.com/%s/%s/%s/%s'\nlocal TREE_HEADERS = {}\nlocal git = { }\n\nif _G._GIT_API_KEY then\n\tTREE_HEADERS.Authorization =  'token ' .. _G._GIT_API_KEY\nend\n\nfunction git.list(repository)\n\tlocal t = Util.split(repository, '(.-)/')\n\n\tlocal user = table.remove(t, 1)\n\tlocal repo = table.remove(t, 1)\n\tlocal branch = table.remove(t, 1) or 'master'\n\tlocal path\n\n\tif not Util.empty(t) then\n\t\tpath = table.concat(t, '/') .. '/'\n\tend\n\n\tlocal function getContents()\n\t\tlocal dataUrl = string.format(TREE_URL, user, repo, branch)\n\t\tlocal contents, msg = Util.httpGet(dataUrl, TREE_HEADERS)\n\t\tif not contents then\n\t\t\terror(string.format('Failed to download %s\\n%s', dataUrl, msg), 2)\n\t\telse\n\t\t\treturn json.decode(contents)\n\t\tend\n\tend\n\n\tlocal data = getContents() or error('Invalid repository')\n\n\tif data.message and data.message:find(\"API rate limit exceeded\") then\n\t\terror(\"Out of API calls, try again later\")\n\tend\n\n\tif data.message and data.message == \"Not found\" then\n\t\terror(\"Invalid repository\")\n\tend\n\n\tlocal list = { }\n\tfor _,v in pairs(data.tree) do\n\t\tif v.type == \"blob\" then\n\t\t\tv.path = v.path:gsub(\"%s\",\"%%20\")\n\t\t\tif not path then\n\t\t\t\tlist[v.path] = {\n\t\t\t\t\turl = string.format(FILE_URL, user, repo, branch, v.path),\n\t\t\t\t\tsize = v.size,\n\t\t\t\t}\n\t\t\telseif Util.startsWith(v.path, path) then\n\t\t\t\tlocal p = string.sub(v.path, #path)\n\t\t\t\tlist[p] = {\n\t\t\t\t\turl = string.format(FILE_URL, user, repo, branch, path .. p),\n\t\t\t\t\tsize = v.size,\n\t\t\t\t}\n\t\t\tend\n\t\tend\n\tend\n\n\treturn list\nend\n\nreturn git\n", "sys/modules/opus/json.lua": "-- Module options:\nlocal register_global_module_table = false\nlocal global_module_name = 'json'\n\n--[==[\nNOTE: Modified to reduce file size.\nSee https://github.com/LuaDist/dkjson/blob/master/dkjson.lua\nfor full version.\n\nDavid Kolf's JSON module for Lua 5.1/5.2\nVersion 2.5\n\nFor the documentation see the corresponding readme.txt or visit\n<http://dkolf.de/src/dkjson-lua.fsl/>.\n\nYou can contact the author by sending an e-mail to 'david' at the\ndomain 'dkolf.de'.\n\nCopyright (C) 2010-2014 David Heiko Kolf\n\nRefer to license located at https://github.com/LuaDist/dkjson/blob/master/dkjson.lua\n\n--]==]\n\n-- global dependencies:\nlocal pairs, type, tostring, tonumber, getmetatable, setmetatable, rawset =\n\t\t\tpairs, type, tostring, tonumber, getmetatable, setmetatable, rawset\nlocal error, require, pcall, select = error, require, pcall, select\nlocal floor, huge = math.floor, math.huge\nlocal strrep, gsub, strsub, strbyte, strchar, strfind, strlen, strformat =\n\t\t\tstring.rep, string.gsub, string.sub, string.byte, string.char,\n\t\t\tstring.find, string.len, string.format\nlocal strmatch = string.match\nlocal concat = table.concat\n\nlocal json = { version = \"dkjson 2.5\" }\n\nif register_global_module_table then\n\t_G[global_module_name] = json\nend\n\nlocal _ENV = nil -- blocking globals in Lua 5.2\n\npcall (function()\n\t-- Enable access to blocked metatables.\n\t-- Don't worry, this module doesn't change anything in them.\n\tlocal debmeta = require \"debug\".getmetatable\n\tif debmeta then getmetatable = debmeta end\nend)\n\njson.null = setmetatable ({}, {\n\t__tojson = function () return \"null\" end\n})\n\nlocal function isarray (tbl)\n\tlocal max, n, arraylen = 0, 0, 0\n\tfor k,v in pairs (tbl) do\n\t\tif k == 'n' and type(v) == 'number' then\n\t\t\tarraylen = v\n\t\t\tif v > max then\n\t\t\t\tmax = v\n\t\t\tend\n\t\telse\n\t\t\tif type(k) ~= 'number' or k < 1 or floor(k) ~= k then\n\t\t\t\treturn false\n\t\t\tend\n\t\t\tif k > max then\n\t\t\t\tmax = k\n\t\t\tend\n\t\t\tn = n + 1\n\t\tend\n\tend\n\tif max > 10 and max > arraylen and max > n * 2 then\n\t\treturn false -- don't create an array with too many holes\n\tend\n\treturn true, max\nend\n\nlocal escapecodes = {\n\t[\"\\\"\"] = \"\\\\\\\"\", [\"\\\\\"] = \"\\\\\\\\\", [\"\\b\"] = \"\\\\b\", [\"\\f\"] = \"\\\\f\",\n\t[\"\\n\"] = \"\\\\n\",  [\"\\r\"] = \"\\\\r\",  [\"\\t\"] = \"\\\\t\"\n}\n\nlocal function escapeutf8 (uchar)\n\tlocal value = escapecodes[uchar]\n\tif value then\n\t\treturn value\n\tend\n\tlocal a, b, c, d = strbyte (uchar, 1, 4)\n\ta, b, c, d = a or 0, b or 0, c or 0, d or 0\n\tif a <= 0x7f then\n\t\tvalue = a\n\telseif 0xc0 <= a and a <= 0xdf and b >= 0x80 then\n\t\tvalue = (a - 0xc0) * 0x40 + b - 0x80\n\telseif 0xe0 <= a and a <= 0xef and b >= 0x80 and c >= 0x80 then\n\t\tvalue = ((a - 0xe0) * 0x40 + b - 0x80) * 0x40 + c - 0x80\n\telseif 0xf0 <= a and a <= 0xf7 and b >= 0x80 and c >= 0x80 and d >= 0x80 then\n\t\tvalue = (((a - 0xf0) * 0x40 + b - 0x80) * 0x40 + c - 0x80) * 0x40 + d - 0x80\n\telse\n\t\treturn \"\"\n\tend\n\tif value <= 0xffff then\n\t\treturn strformat (\"\\\\u%.4x\", value)\n\telseif value <= 0x10ffff then\n\t\t-- encode as UTF-16 surrogate pair\n\t\tvalue = value - 0x10000\n\t\tlocal highsur, lowsur = 0xD800 + floor (value/0x400), 0xDC00 + (value % 0x400)\n\t\treturn strformat (\"\\\\u%.4x\\\\u%.4x\", highsur, lowsur)\n\telse\n\t\treturn \"\"\n\tend\nend\n\nlocal function fsub (str, pattern, repl)\n\t-- gsub always builds a new string in a buffer, even when no match\n\t-- exists. First using find should be more efficient when most strings\n\t-- don't contain the pattern.\n\tif strfind (str, pattern) then\n\t\treturn gsub (str, pattern, repl)\n\telse\n\t\treturn str\n\tend\nend\n\nlocal function quotestring (value)\n\t-- based on the regexp \"escapable\" in https://github.com/douglascrockford/JSON-js\n\tvalue = fsub (value, \"[%z\\1-\\31\\\"\\\\\\127]\", escapeutf8)\n\tif strfind (value, \"[\\194\\216\\220\\225\\226\\239]\") then\n\t\tvalue = fsub (value, \"\\194[\\128-\\159\\173]\", escapeutf8)\n\t\tvalue = fsub (value, \"\\216[\\128-\\132]\", escapeutf8)\n\t\tvalue = fsub (value, \"\\220\\143\", escapeutf8)\n\t\tvalue = fsub (value, \"\\225\\158[\\180\\181]\", escapeutf8)\n\t\tvalue = fsub (value, \"\\226\\128[\\140-\\143\\168-\\175]\", escapeutf8)\n\t\tvalue = fsub (value, \"\\226\\129[\\160-\\175]\", escapeutf8)\n\t\tvalue = fsub (value, \"\\239\\187\\191\", escapeutf8)\n\t\tvalue = fsub (value, \"\\239\\191[\\176-\\191]\", escapeutf8)\n\tend\n\treturn \"\\\"\" .. value .. \"\\\"\"\nend\njson.quotestring = quotestring\n\nlocal function replace(str, o, n)\n\tlocal i, j = strfind (str, o, 1, true)\n\tif i then\n\t\treturn strsub(str, 1, i-1) .. n .. strsub(str, j+1, -1)\n\telse\n\t\treturn str\n\tend\nend\n\n-- locale independent num2str and str2num functions\nlocal decpoint, numfilter\n\nlocal function updatedecpoint ()\n\tdecpoint = strmatch(tostring(0.5), \"([^05+])\")\n\t-- build a filter that can be used to remove group separators\n\tnumfilter = \"[^0-9%-%+eE\" .. gsub(decpoint, \"[%^%$%(%)%%%.%[%]%*%+%-%?]\", \"%%%0\") .. \"]+\"\nend\n\nupdatedecpoint()\n\nlocal function num2str (num)\n\treturn replace(fsub(tostring(num), numfilter, \"\"), decpoint, \".\")\nend\n\nlocal function str2num (str)\n\tlocal num = tonumber(replace(str, \".\", decpoint))\n\tif not num then\n\t\tupdatedecpoint()\n\t\tnum = tonumber(replace(str, \".\", decpoint))\n\tend\n\treturn num\nend\n\nlocal function addnewline2 (level, buffer, buflen)\n\tbuffer[buflen+1] = \"\\n\"\n\tbuffer[buflen+2] = strrep (\"  \", level)\n\tbuflen = buflen + 2\n\treturn buflen\nend\n\nfunction json.addnewline (state)\n\tif state.indent then\n\t\tstate.bufferlen = addnewline2 (state.level or 0,\n\t\t\t\t\t\t\t\t\t\t\t\t\t state.buffer, state.bufferlen or #(state.buffer))\n\tend\nend\n\nlocal encode2 -- forward declaration\n\nlocal function addpair (key, value, prev, indent, level, buffer, buflen, tables, globalorder, state)\n\tlocal kt = type (key)\n\tif kt ~= 'string' and kt ~= 'number' then\n\t\treturn nil, \"type '\" .. kt .. \"' is not supported as a key by JSON.\"\n\tend\n\tif prev then\n\t\tbuflen = buflen + 1\n\t\tbuffer[buflen] = \",\"\n\tend\n\tif indent then\n\t\tbuflen = addnewline2 (level, buffer, buflen)\n\tend\n\tbuffer[buflen+1] = quotestring (key)\n\tbuffer[buflen+2] = \":\"\n\treturn encode2 (value, indent, level, buffer, buflen + 2, tables, globalorder, state)\nend\n\nlocal function appendcustom(res, buffer, state)\n\tlocal buflen = state.bufferlen\n\tif type (res) == 'string' then\n\t\tbuflen = buflen + 1\n\t\tbuffer[buflen] = res\n\tend\n\treturn buflen\nend\n\nlocal function exception(reason, value, state, buffer, buflen, defaultmessage)\n\tdefaultmessage = defaultmessage or reason\n\tlocal handler = state.exception\n\tif not handler then\n\t\treturn nil, defaultmessage\n\telse\n\t\tstate.bufferlen = buflen\n\t\tlocal ret, msg = handler (reason, value, state, defaultmessage)\n\t\tif not ret then return nil, msg or defaultmessage end\n\t\treturn appendcustom(ret, buffer, state)\n\tend\nend\n\nfunction json.encodeexception(reason, value, state, defaultmessage)\n\treturn quotestring(\"<\" .. defaultmessage .. \">\")\nend\n\nencode2 = function (value, indent, level, buffer, buflen, tables, globalorder, state)\n\tlocal valtype = type (value)\n\tlocal valmeta = getmetatable (value)\n\tvalmeta = type (valmeta) == 'table' and valmeta -- only tables\n\tlocal valtojson = valmeta and valmeta.__tojson\n\tif valtojson then\n\t\tif tables[value] then\n\t\t\treturn exception('reference cycle', value, state, buffer, buflen)\n\t\tend\n\t\ttables[value] = true\n\t\tstate.bufferlen = buflen\n\t\tlocal ret, msg = valtojson (value, state)\n\t\tif not ret then return exception('custom encoder failed', value, state, buffer, buflen, msg) end\n\t\ttables[value] = nil\n\t\tbuflen = appendcustom(ret, buffer, state)\n\telseif value == nil then\n\t\tbuflen = buflen + 1\n\t\tbuffer[buflen] = \"null\"\n\telseif valtype == 'number' then\n\t\tlocal s\n\t\tif value ~= value or value >= huge or -value >= huge then\n\t\t\t-- This is the behaviour of the original JSON implementation.\n\t\t\ts = \"null\"\n\t\telse\n\t\t\ts = num2str (value)\n\t\tend\n\t\tbuflen = buflen + 1\n\t\tbuffer[buflen] = s\n\telseif valtype == 'boolean' then\n\t\tbuflen = buflen + 1\n\t\tbuffer[buflen] = value and \"true\" or \"false\"\n\telseif valtype == 'string' then\n\t\tbuflen = buflen + 1\n\t\tbuffer[buflen] = quotestring (value)\n\telseif valtype == 'table' then\n\t\tif tables[value] then\n\t\t\treturn exception('reference cycle', value, state, buffer, buflen)\n\t\tend\n\t\ttables[value] = true\n\t\tlevel = level + 1\n\t\tlocal isa, n = isarray (value)\n\t\tif n == 0 and valmeta and valmeta.__jsontype == 'object' then\n\t\t\tisa = false\n\t\tend\n\t\tlocal msg\n\t\tif isa then -- JSON array\n\t\t\tbuflen = buflen + 1\n\t\t\tbuffer[buflen] = \"[\"\n\t\t\tfor i = 1, n do\n\t\t\t\tbuflen, msg = encode2 (value[i], indent, level, buffer, buflen, tables, globalorder, state)\n\t\t\t\tif not buflen then return nil, msg end\n\t\t\t\tif i < n then\n\t\t\t\t\tbuflen = buflen + 1\n\t\t\t\t\tbuffer[buflen] = \",\"\n\t\t\t\tend\n\t\t\tend\n\t\t\tbuflen = buflen + 1\n\t\t\tbuffer[buflen] = \"]\"\n\t\telse -- JSON object\n\t\t\tlocal prev = false\n\t\t\tbuflen = buflen + 1\n\t\t\tbuffer[buflen] = \"{\"\n\t\t\tlocal order = valmeta and valmeta.__jsonorder or globalorder\n\t\t\tif order then\n\t\t\t\tlocal used = {}\n\t\t\t\tn = #order\n\t\t\t\tfor i = 1, n do\n\t\t\t\t\tlocal k = order[i]\n\t\t\t\t\tlocal v = value[k]\n\t\t\t\t\tif v then\n\t\t\t\t\t\tused[k] = true\n\t\t\t\t\t\tbuflen, msg = addpair (k, v, prev, indent, level, buffer, buflen, tables, globalorder, state)\n\t\t\t\t\t\tprev = true -- add a seperator before the next element\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\tfor k,v in pairs (value) do\n\t\t\t\t\tif not used[k] then\n\t\t\t\t\t\tbuflen, msg = addpair (k, v, prev, indent, level, buffer, buflen, tables, globalorder, state)\n\t\t\t\t\t\tif not buflen then return nil, msg end\n\t\t\t\t\t\tprev = true -- add a seperator before the next element\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\telse -- unordered\n\t\t\t\tfor k,v in pairs (value) do\n\t\t\t\t\tbuflen, msg = addpair (k, v, prev, indent, level, buffer, buflen, tables, globalorder, state)\n\t\t\t\t\tif not buflen then return nil, msg end\n\t\t\t\t\tprev = true -- add a seperator before the next element\n\t\t\t\tend\n\t\t\tend\n\t\t\tif indent then\n\t\t\t\tbuflen = addnewline2 (level - 1, buffer, buflen)\n\t\t\tend\n\t\t\tbuflen = buflen + 1\n\t\t\tbuffer[buflen] = \"}\"\n\t\tend\n\t\ttables[value] = nil\n\telse\n\t\treturn exception ('unsupported type', value, state, buffer, buflen,\n\t\t\t\"type '\" .. valtype .. \"' is not supported by JSON.\")\n\tend\n\treturn buflen\nend\n\nfunction json.encode (value, state)\n\tstate = state or {}\n\tlocal oldbuffer = state.buffer\n\tlocal buffer = oldbuffer or {}\n\tstate.buffer = buffer\n\tupdatedecpoint()\n\tlocal ret, msg = encode2 (value, state.indent, state.level or 0,\n\t\t\t\t\t\t\t\t\t buffer, state.bufferlen or 0, state.tables or {}, state.keyorder, state)\n\tif not ret then\n\t\terror (msg, 2)\n\telseif oldbuffer == buffer then\n\t\tstate.bufferlen = ret\n\t\treturn true\n\telse\n\t\tstate.bufferlen = nil\n\t\tstate.buffer = nil\n\t\treturn concat (buffer)\n\tend\nend\n\nlocal function loc (str, where)\n\tlocal line, pos, linepos = 1, 1, 0\n\twhile true do\n\t\tpos = strfind (str, \"\\n\", pos, true)\n\t\tif pos and pos < where then\n\t\t\tline = line + 1\n\t\t\tlinepos = pos\n\t\t\tpos = pos + 1\n\t\telse\n\t\t\tbreak\n\t\tend\n\tend\n\treturn \"line \" .. line .. \", column \" .. (where - linepos)\nend\n\nlocal function unterminated (str, what, where)\n\treturn nil, strlen (str) + 1, \"unterminated \" .. what .. \" at \" .. loc (str, where)\nend\n\nlocal function scanwhite (str, pos)\n\twhile true do\n\t\tpos = strfind (str, \"%S\", pos)\n\t\tif not pos then return nil end\n\t\tlocal sub2 = strsub (str, pos, pos + 1)\n\t\tif sub2 == \"\\239\\187\" and strsub (str, pos + 2, pos + 2) == \"\\191\" then\n\t\t\t-- UTF-8 Byte Order Mark\n\t\t\tpos = pos + 3\n\t\telseif sub2 == \"//\" then\n\t\t\tpos = strfind (str, \"[\\n\\r]\", pos + 2)\n\t\t\tif not pos then return nil end\n\t\telseif sub2 == \"/*\" then\n\t\t\tpos = strfind (str, \"*/\", pos + 2)\n\t\t\tif not pos then return nil end\n\t\t\tpos = pos + 2\n\t\telse\n\t\t\treturn pos\n\t\tend\n\tend\nend\n\nlocal escapechars = {\n\t[\"\\\"\"] = \"\\\"\", [\"\\\\\"] = \"\\\\\", [\"/\"] = \"/\", [\"b\"] = \"\\b\", [\"f\"] = \"\\f\",\n\t[\"n\"] = \"\\n\", [\"r\"] = \"\\r\", [\"t\"] = \"\\t\"\n}\n\nlocal function unichar (value)\n\tif value < 0 then\n\t\treturn nil\n\telseif value <= 0x007f then\n\t\treturn strchar (value)\n\telseif value <= 0x07ff then\n\t\treturn strchar (0xc0 + floor(value/0x40),\n\t\t\t\t\t\t\t\t\t\t0x80 + (floor(value) % 0x40))\n\telseif value <= 0xffff then\n\t\treturn strchar (0xe0 + floor(value/0x1000),\n\t\t\t\t\t\t\t\t\t\t0x80 + (floor(value/0x40) % 0x40),\n\t\t\t\t\t\t\t\t\t\t0x80 + (floor(value) % 0x40))\n\telseif value <= 0x10ffff then\n\t\treturn strchar (0xf0 + floor(value/0x40000),\n\t\t\t\t\t\t\t\t\t\t0x80 + (floor(value/0x1000) % 0x40),\n\t\t\t\t\t\t\t\t\t\t0x80 + (floor(value/0x40) % 0x40),\n\t\t\t\t\t\t\t\t\t\t0x80 + (floor(value) % 0x40))\n\telse\n\t\treturn nil\n\tend\nend\n\nlocal function scanstring (str, pos)\n\tlocal lastpos = pos + 1\n\tlocal buffer, n = {}, 0\n\twhile true do\n\t\tlocal nextpos = strfind (str, \"[\\\"\\\\]\", lastpos)\n\t\tif not nextpos then\n\t\t\treturn unterminated (str, \"string\", pos)\n\t\tend\n\t\tif nextpos > lastpos then\n\t\t\tn = n + 1\n\t\t\tbuffer[n] = strsub (str, lastpos, nextpos - 1)\n\t\tend\n\t\tif strsub (str, nextpos, nextpos) == \"\\\"\" then\n\t\t\tlastpos = nextpos + 1\n\t\t\tbreak\n\t\telse\n\t\t\tlocal escchar = strsub (str, nextpos + 1, nextpos + 1)\n\t\t\tlocal value\n\t\t\tif escchar == \"u\" then\n\t\t\t\tvalue = tonumber (strsub (str, nextpos + 2, nextpos + 5), 16)\n\t\t\t\tif value then\n\t\t\t\t\tlocal value2\n\t\t\t\t\tif 0xD800 <= value and value <= 0xDBff then\n\t\t\t\t\t\t-- we have the high surrogate of UTF-16. Check if there is a\n\t\t\t\t\t\t-- low surrogate escaped nearby to combine them.\n\t\t\t\t\t\tif strsub (str, nextpos + 6, nextpos + 7) == \"\\\\u\" then\n\t\t\t\t\t\t\tvalue2 = tonumber (strsub (str, nextpos + 8, nextpos + 11), 16)\n\t\t\t\t\t\t\tif value2 and 0xDC00 <= value2 and value2 <= 0xDFFF then\n\t\t\t\t\t\t\t\tvalue = (value - 0xD800)  * 0x400 + (value2 - 0xDC00) + 0x10000\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tvalue2 = nil -- in case it was out of range for a low surrogate\n\t\t\t\t\t\t\tend\n\t\t\t\t\t\tend\n\t\t\t\t\tend\n\t\t\t\t\tvalue = value and unichar (value)\n\t\t\t\t\tif value then\n\t\t\t\t\t\tif value2 then\n\t\t\t\t\t\t\tlastpos = nextpos + 12\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tlastpos = nextpos + 6\n\t\t\t\t\t\tend\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\tend\n\t\t\tif not value then\n\t\t\t\tvalue = escapechars[escchar] or escchar\n\t\t\t\tlastpos = nextpos + 2\n\t\t\tend\n\t\t\tn = n + 1\n\t\t\tbuffer[n] = value\n\t\tend\n\tend\n\tif n == 1 then\n\t\treturn buffer[1], lastpos\n\telseif n > 1 then\n\t\treturn concat (buffer), lastpos\n\telse\n\t\treturn \"\", lastpos\n\tend\nend\n\nlocal scanvalue -- forward declaration\n\nlocal function scantable (what, closechar, str, startpos, nullval, objectmeta, arraymeta)\n\tlocal len = strlen (str)\n\tlocal tbl, n = {}, 0\n\tlocal pos = startpos + 1\n\tif what == 'object' then\n\t\tsetmetatable (tbl, objectmeta)\n\telse\n\t\tsetmetatable (tbl, arraymeta)\n\tend\n\twhile true do\n\t\tpos = scanwhite (str, pos)\n\t\tif not pos then return unterminated (str, what, startpos) end\n\t\tlocal char = strsub (str, pos, pos)\n\t\tif char == closechar then\n\t\t\treturn tbl, pos + 1\n\t\tend\n\t\tlocal val1, err\n\t\tval1, pos, err = scanvalue (str, pos, nullval, objectmeta, arraymeta)\n\t\tif err then return nil, pos, err end\n\t\tpos = scanwhite (str, pos)\n\t\tif not pos then return unterminated (str, what, startpos) end\n\t\tchar = strsub (str, pos, pos)\n\t\tif char == \":\" then\n\t\t\tif val1 == nil then\n\t\t\t\treturn nil, pos, \"cannot use nil as table index (at \" .. loc (str, pos) .. \")\"\n\t\t\tend\n\t\t\tpos = scanwhite (str, pos + 1)\n\t\t\tif not pos then return unterminated (str, what, startpos) end\n\t\t\tlocal val2\n\t\t\tval2, pos, err = scanvalue (str, pos, nullval, objectmeta, arraymeta)\n\t\t\tif err then return nil, pos, err end\n\t\t\ttbl[val1] = val2\n\t\t\tpos = scanwhite (str, pos)\n\t\t\tif not pos then return unterminated (str, what, startpos) end\n\t\t\tchar = strsub (str, pos, pos)\n\t\telse\n\t\t\tn = n + 1\n\t\t\ttbl[n] = val1\n\t\tend\n\t\tif char == \",\" then\n\t\t\tpos = pos + 1\n\t\tend\n\tend\nend\n\nscanvalue = function (str, pos, nullval, objectmeta, arraymeta)\n\tpos = pos or 1\n\tpos = scanwhite (str, pos)\n\tif not pos then\n\t\treturn nil, strlen (str) + 1, \"no valid JSON value (reached the end)\"\n\tend\n\tlocal char = strsub (str, pos, pos)\n\tif char == \"{\" then\n\t\treturn scantable ('object', \"}\", str, pos, nullval, objectmeta, arraymeta)\n\telseif char == \"[\" then\n\t\treturn scantable ('array', \"]\", str, pos, nullval, objectmeta, arraymeta)\n\telseif char == \"\\\"\" then\n\t\treturn scanstring (str, pos)\n\telse\n\t\tlocal pstart, pend = strfind (str, \"^%-?[%d%.]+[eE]?[%+%-]?%d*\", pos)\n\t\tif pstart then\n\t\t\tlocal number = str2num (strsub (str, pstart, pend))\n\t\t\tif number then\n\t\t\t\treturn number, pend + 1\n\t\t\tend\n\t\tend\n\t\tpstart, pend = strfind (str, \"^%a%w*\", pos)\n\t\tif pstart then\n\t\t\tlocal name = strsub (str, pstart, pend)\n\t\t\tif name == \"true\" then\n\t\t\t\treturn true, pend + 1\n\t\t\telseif name == \"false\" then\n\t\t\t\treturn false, pend + 1\n\t\t\telseif name == \"null\" then\n\t\t\t\treturn nullval, pend + 1\n\t\t\tend\n\t\tend\n\t\treturn nil, pos, \"no valid JSON value at \" .. loc (str, pos)\n\tend\nend\n\nlocal function optionalmetatables(...)\n\tif select(\"#\", ...) > 0 then\n\t\treturn ...\n\telse\n\t\treturn {__jsontype = 'object'}, {__jsontype = 'array'}\n\tend\nend\n\nfunction json.decode (str, pos, nullval, ...)\n\tlocal objectmeta, arraymeta = optionalmetatables(...)\n\treturn scanvalue (str, pos, nullval, objectmeta, arraymeta)\nend\n\n-- NOTE: added method - not in original source\nfunction json.decodeFromFile(path)\n\tlocal file = assert(fs.open(path, \"r\"))\n\tlocal decoded = json.decode(file.readAll())\n\tfile.close()\n\treturn decoded\nend\n\nreturn json\n", "sys/modules/opus/terminal.lua": "local Canvas = require('opus.ui.canvas')\n\nlocal colors = _G.colors\nlocal term   = _G.term\nlocal _gsub  = string.gsub\n\nlocal Terminal = { }\n\nlocal mapColorToGray = {\n\t[ colors.white ] = colors.white,\n\t[ colors.orange ] = colors.lightGray,\n\t[ colors.magenta ] = colors.lightGray,\n\t[ colors.lightBlue ] = colors.lightGray,\n\t[ colors.yellow ] = colors.lightGray,\n\t[ colors.lime ] = colors.lightGray,\n\t[ colors.pink ] = colors.lightGray,\n\t[ colors.gray ] = colors.gray,\n\t[ colors.lightGray ] = colors.lightGray,\n\t[ colors.cyan ] = colors.lightGray,\n\t[ colors.purple ] = colors.gray,\n\t[ colors.blue ] = colors.gray,\n\t[ colors.brown ] = colors.gray,\n\t[ colors.green ] = colors.lightGray,\n\t[ colors.red ] = colors.gray,\n\t[ colors.black ] = colors.black,\n}\n\n-- Replacement for window api with scrolling and buffering\nfunction Terminal.window(parent, sx, sy, w, h, isVisible)\n\tisVisible = isVisible ~= false\n\tif not w or not h then\n\t\tw, h = parent.getSize()\n\tend\n\n\tlocal win = { }\n\tlocal maxScroll\n\tlocal cx, cy = 1, 1\n\tlocal blink = false\n\tlocal _bg, _fg = colors.black, colors.white\n\n\twin.canvas = Canvas({\n\t\tx       = sx,\n\t\ty       = sy,\n\t\twidth   = w,\n\t\theight  = h,\n\t\tisColor = parent.isColor(),\n\t\toffy    = 0,\n\t\tbg      = _bg,\n\t\tfg      = _fg,\n\t})\n\n\tlocal function update()\n\t\tif isVisible then\n\t\t\twin.canvas:render(parent)\n\t\t\twin.setCursorPos(cx, cy)\n\t\tend\n\tend\n\n\tlocal function scrollTo(y)\n\t\ty = math.max(0, y)\n\t\ty = math.min(#win.canvas.lines - win.canvas.height, y)\n\n\t\tif y ~= win.canvas.offy then\n\t\t\twin.canvas.offy = y\n\t\t\twin.canvas:dirty()\n\t\t\tupdate()\n\t\tend\n\tend\n\n\tfunction win.write(str)\n\t\tstr = tostring(str) or ''\n\t\twin.canvas:write(cx, cy +  win.canvas.offy, str, win.canvas.bg, win.canvas.fg)\n\t\twin.setCursorPos(cx + #str, cy)\n\t\tupdate()\n\tend\n\n\tfunction win.blit(str, fg, bg)\n\t\twin.canvas:blit(cx, cy + win.canvas.offy, str, bg, fg)\n\t\twin.setCursorPos(cx + #str, cy)\n\t\tupdate()\n\tend\n\n\tfunction win.clear()\n\t\twin.canvas.offy = 0\n\t\tfor i = #win.canvas.lines, win.canvas.height + 1, -1 do\n\t\t\twin.canvas.lines[i] = nil\n\t\tend\n\t\twin.canvas:clear()\n\t\tupdate()\n\tend\n\n\tfunction win.getLine(n)\n\t\tlocal line = win.canvas.lines[n]\n\t\treturn line.text, line.fg, line.bg\n\tend\n\n\tfunction win.clearLine()\n\t\twin.canvas:clearLine(cy + win.canvas.offy)\n\t\twin.setCursorPos(cx, cy)\n\t\tupdate()\n\tend\n\n\tfunction win.getCursorPos()\n\t\treturn cx, cy\n\tend\n\n\tfunction win.setCursorPos(x, y)\n\t\tcx, cy = math.floor(x), math.floor(y)\n\t\tif isVisible then\n\t\t\tparent.setCursorPos(cx + win.canvas.x - 1, cy + win.canvas.y - 1)\n\t\tend\n\tend\n\n\tfunction win.getCursorBlink()\n\t\treturn blink\n\tend\n\n\tfunction win.setCursorBlink(b)\n\t\tblink = b\n\t\tif isVisible then\n\t\t\tparent.setCursorBlink(b)\n\t\tend\n\tend\n\n\tfunction win.isColor()\n\t\treturn win.canvas.isColor\n\tend\n\twin.isColour = win.isColor\n\n\tfunction win.setTextColor(c)\n\t\twin.canvas.fg = c\n\tend\n\twin.setTextColour = win.setTextColor\n\n\tfunction win.getPaletteColor(n)\n\t\tif parent.getPaletteColor then\n\t\t\treturn parent.getPaletteColor(n)\n\t\tend\n\t\treturn 0, 0, 0\n\tend\n\twin.getPaletteColour = win.getPaletteColor\n\n\tfunction win.setPaletteColor(n, r, g, b)\n\t\tif parent.setPaletteColor then\n\t\t\treturn parent.setPaletteColor(n, r, g, b)\n\t\tend\n\tend\n\twin.setPaletteColour = win.setPaletteColor\n\n\tfunction win.setBackgroundColor(c)\n\t\twin.canvas.bg = c\n\tend\n\twin.setBackgroundColour = win.setBackgroundColor\n\n\tfunction win.getSize()\n\t\treturn win.canvas.width, win.canvas.height\n\tend\n\n\tfunction win.scroll(n)\n\t\tn = n or 1\n\t\tif n > 0 then\n\t\t\tlocal lines = #win.canvas.lines\n\t\t\tfor i = 1, n do\n\t\t\t\twin.canvas.lines[lines + i] = { }\n\t\t\t\twin.canvas:clearLine(lines + i)\n\t\t\tend\n\t\t\twhile #win.canvas.lines > (maxScroll or win.canvas.height) do\n\t\t\t\ttable.remove(win.canvas.lines, 1)\n\t\t\tend\n\t\t\tscrollTo(#win.canvas.lines)\n\t\t\twin.canvas:dirty()\n\t\t\tupdate()\n\t\tend\n\tend\n\n\tfunction win.getTextColor()\n\t\treturn win.canvas.fg\n\tend\n\twin.getTextColour = win.getTextColor\n\n\tfunction win.getBackgroundColor()\n\t\treturn win.canvas.bg\n\tend\n\twin.getBackgroundColour = win.getBackgroundColor\n\n\tfunction win.setVisible(visible)\n\t\tif visible ~= isVisible then\n\t\t\tisVisible = visible\n\t\t\tif isVisible then\n\t\t\t\twin.canvas:dirty()\n\t\t\t\tupdate()\n\t\t\tend\n\t\tend\n\tend\n\n\tfunction win.redraw()\n\t\tif isVisible then\n\t\t\twin.canvas:dirty()\n\t\t\tupdate()\n\t\tend\n\tend\n\n\tfunction win.restoreCursor()\n\t\tif isVisible then\n\t\t\twin.setCursorPos(cx, cy)\n\t\t\twin.setTextColor(win.canvas.fg)\n\t\t\twin.setCursorBlink(blink)\n\t\tend\n\tend\n\n\tfunction win.getPosition()\n\t\treturn win.canvas.x, win.canvas.y\n\tend\n\n\tfunction win.reposition(x, y, width, height)\n\t\tif not maxScroll then\n\t\t\twin.canvas:move(x, y)\n\t\t\twin.canvas:resize(width or win.canvas.width, height or win.canvas.height)\n\t\t\treturn\n\t\tend\n\n\t\t-- special processing for scrolling terminal like windows\n\t\tlocal delta = height - win.canvas.height\n\n\t\tif delta > 0 then -- grow\n\t\t\tfor _ = 1, delta do\n\t\t\t\twin.canvas.lines[#win.canvas.lines + 1] = { }\n\t\t\t\twin.canvas:clearLine(#win.canvas.lines)\n\t\t\tend\n\n\t\telseif delta < 0 then -- shrink\n\t\t\tfor _ = delta + 1, 0 do\n\t\t\t\tif cy < win.canvas.height then\n\t\t\t\t\twin.canvas.lines[#win.canvas.lines] = nil\n\t\t\t\telse\n\t\t\t\t\tcy = cy - 1\n\t\t\t\t\twin.canvas.offy = win.canvas.offy + 1\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\n\t\twin.canvas:resizeBuffer(width, #win.canvas.lines)\n\n\t\twin.canvas.height = height\n\t\twin.canvas.width = width\n\t\twin.canvas:move(x, y)\n\n\t\tupdate()\n\tend\n\n\t--[[ Additional methods ]]--\n\tfunction win.scrollDown()\n\t\tscrollTo(win.canvas.offy + 1)\n\tend\n\n\tfunction win.scrollUp()\n\t\tscrollTo(win.canvas.offy - 1)\n\tend\n\n\tfunction win.scrollTop()\n\t\tscrollTo(0)\n\tend\n\n\tfunction win.scrollBottom()\n\t\tscrollTo(#win.canvas.lines)\n\tend\n\n\tfunction win.setMaxScroll(ms)\n\t\tmaxScroll = ms\n\tend\n\n\tfunction win.getCanvas()\n\t\treturn win.canvas\n\tend\n\n\tfunction win.getParent()\n\t\treturn parent\n\tend\n\n\tfunction win.writeX(sText)\n\t\t-- expect(1, sText, \"string\", \"number\")\n\t\tlocal nLinesPrinted = 0\n\t\tlocal function newLine()\n\t\t\tif cy + 1 <= win.canvas.height then\n\t\t\t\tcx, cy = 1, cy + 1\n\t\t\telse\n\t\t\t\tcx, cy = 1, win.canvas.height\n\t\t\t\twin.scroll(1)\n\t\t\tend\n\t\t\tnLinesPrinted = nLinesPrinted + 1\n\t\tend\n\n\t\t-- Print the line with proper word wrapping\n\t\tsText = tostring(sText)\n\t\twhile #sText > 0 do\n\t\t\tlocal whitespace = string.match(sText, \"^[ \\t]+\")\n\t\t\tif whitespace then\n\t\t\t\t-- Print whitespace\n\t\t\t\twin.write(whitespace)\n\t\t\t\tsText = string.sub(sText, #whitespace + 1)\n\t\t\tend\n\n\t\t\tlocal newline = string.match(sText, \"^\\n\")\n\t\t\tif newline then\n\t\t\t\t-- Print newlines\n\t\t\t\tnewLine()\n\t\t\t\tsText = string.sub(sText, 2)\n\t\t\tend\n\n\t\t\tlocal text = string.match(sText, \"^[^ \\t\\n]+\")\n\t\t\tif text then\n\t\t\t\tsText = string.sub(sText, #text + 1)\n\t\t\t\tif #text > win.canvas.width then\n\t\t\t\t\t-- Print a multiline word\n\t\t\t\t\twhile #text > 0 do\n\t\t\t\t\t\tif cx > win.canvas.width then\n\t\t\t\t\t\t\tnewLine()\n\t\t\t\t\t\tend\n\t\t\t\t\t\twin.write(text)\n\t\t\t\t\t\ttext = string.sub(text, win.canvas.width - cx + 2)\n\t\t\t\t\tend\n\t\t\t\telse\n\t\t\t\t\t-- Print a word normally\n\t\t\t\t\tif cx + #text - 1 > win.canvas.width then\n\t\t\t\t\t\tnewLine()\n\t\t\t\t\tend\n\t\t\t\t\twin.write(text)\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\n\t\treturn nLinesPrinted\n\tend\n\n\tfunction win.print(...)\n\t\tlocal vis = isVisible\n\t\tisVisible = false\n\t\tlocal nLinesPrinted = 0\n\t\tlocal nLimit = select(\"#\", ...)\n\t\tfor n = 1, nLimit do\n\t\t\tlocal s = tostring(select(n, ...))\n\t\t\tif n < nLimit then\n\t\t\t\ts = s .. \"\\t\"\n\t\t\tend\n\t\t\tnLinesPrinted = nLinesPrinted + win.writeX(s)\n\t\tend\n\t\tnLinesPrinted = nLinesPrinted + win.writeX(\"\\n\")\n\t\tisVisible = vis\n\t\tupdate()\n\t\treturn nLinesPrinted\n\tend\n\n\twin.canvas:clear()\n\n\treturn win\nend\n\n-- get windows contents\nfunction Terminal.getContents(win)\n\tif not win.getLine then\n\t\terror('window is required')\n\tend\n\n\tlocal lines = { }\n\tlocal _, h = win.getSize()\n\n\tfor i = 1, h do\n\t\tlocal text, fg, bg = win.getLine(i)\n\t\tlines[i] = {\n\t\t\ttext = text,\n\t\t\tfg = fg,\n\t\t\tbg = bg,\n\t\t}\n\tend\n\n\treturn lines\nend\n\nfunction Terminal.colorToGrayscale(c)\n\treturn mapColorToGray[c]\nend\n\nfunction Terminal.toGrayscale(ct)\n\tlocal methods = { 'setBackgroundColor', 'setBackgroundColour',\n\t\t\t\t\t\t\t\t\t\t'setTextColor', 'setTextColour' }\n\tfor _,v in pairs(methods) do\n\t\tlocal fn = ct[v]\n\t\tct[v] = function(c)\n\t\t\tfn(mapColorToGray[c])\n\t\tend\n\tend\n\n\tlocal bcolors = {\n\t\t[ '1' ] = '8',\n\t\t[ '2' ] = '8',\n\t\t[ '3' ] = '8',\n\t\t[ '4' ] = '8',\n\t\t[ '5' ] = '8',\n\t\t[ '6' ] = '8',\n\t\t[ '9' ] = '8',\n\t\t[ 'a' ] = '7',\n\t\t[ 'b' ] = '7',\n\t\t[ 'c' ] = '7',\n\t\t[ 'd' ] = '8',\n\t\t[ 'e' ] = '7',\n\t}\n\n\tlocal function translate(s)\n\t\tif s then\n\t\t\ts = _gsub(s, \"%w\", bcolors)\n\t\tend\n\t\treturn s\n\tend\n\n\tlocal fn = ct.blit\n\tct.blit = function(text, fg, bg)\n\t\tfn(text, translate(fg), translate(bg))\n\tend\nend\n\nfunction Terminal.getNullTerm(ct)\n\tlocal nt = Terminal.copy(ct)\n\n\tlocal methods = { 'blit', 'clear', 'clearLine', 'scroll',\n\t\t\t\t\t\t\t\t\t\t'setCursorBlink', 'setCursorPos', 'write' }\n\tfor _,v in pairs(methods) do\n\t\tnt[v] = function() end\n\tend\n\n\treturn nt\nend\n\nfunction Terminal.copy(it, ot)\n\tot = ot or { }\n\tfor k,v in pairs(it) do\n\t\tif type(v) == 'function' then\n\t\t\tot[k] = v\n\t\tend\n\tend\n\treturn ot\nend\n\nfunction Terminal.mirror(ct, dt)\n\tlocal t = { }\n\tfor k,f in pairs(ct) do\n\t\tt[k] = function(...)\n\t\t\tlocal ret = { f(...) }\n\t\t\tif dt[k] then\n\t\t\t\tdt[k](...)\n\t\t\tend\n\t\t\treturn table.unpack(ret)\n\t\tend\n\tend\n\treturn t\nend\n\nfunction Terminal.readPassword(prompt)\n\tif prompt then\n\t\tterm.write(prompt)\n\tend\n\tlocal fn = term.current().write\n\tterm.current().write = function() end\n\tlocal s\n\tpcall(function() s = _G.read(prompt) end)\n\tterm.current().write = fn\n\n\tif s == '' then\n\t\treturn\n\tend\n\treturn s\nend\n\nreturn Terminal\n", "sys/modules/opus/ansi.lua": "local Ansi = setmetatable({ }, {\n\t__call = function(_, ...)\n\t\tlocal str = '\\027['\n\t\tfor k,v in ipairs({ ...}) do\n\t\t\tif k == 1 then\n\t\t\t\tstr = str .. v\n\t\t\telse\n\t\t\t\tstr = str .. ';' .. v\n\t\t\tend\n\t\tend\n\t\treturn str .. 'm'\n\tend\n})\n\nAnsi.codes = {\n\treset       = 0,\n\twhite       = 1,\n\torange      = 2,\n\tmagenta     = 3,\n\tlightBlue   = 4,\n\tyellow      = 5,\n\tlime        = 6,\n\tpink        = 7,\n\tgray        = 8,\n\tlightGray   = 9,\n\tcyan        = 10,\n\tpurple      = 11,\n\tblue        = 12,\n\tbrown       = 13,\n\tgreen       = 14,\n\tred         = 15,\n\tblack       = 16,\n\tonwhite     = 21,\n\tonorange    = 22,\n\tonmagenta   = 23,\n\tonlightBlue = 24,\n\tonyellow    = 25,\n\tonlime      = 26,\n\tonpink      = 27,\n\tongray      = 28,\n\tonlightGray = 29,\n\toncyan      = 30,\n\tonpurple    = 31,\n\tonblue      = 32,\n\tonbrown     = 33,\n\tongreen     = 34,\n\tonred       = 35,\n\tonblack     = 36,\n}\n\nfor k,v in pairs(Ansi.codes) do\n\tAnsi[k] = Ansi(v)\nend\n\nreturn Ansi\n", "sys/modules/opus/map.lua": "-- convience functions for tables with key/value pairs\nlocal Util = require('opus.util')\n\nlocal Map = { }\n\n-- TODO: refactor\nMap.merge = Util.merge\nMap.shallowCopy = Util.shallowCopy\nMap.find = Util.find\nMap.filter = Util.filter\nMap.transpose = Util.transpose\n\nfunction Map.removeMatches(t, values)\n\tlocal function matchAll(entry)\n\t\tfor k, v in pairs(values) do\n\t\t\tif entry[k] ~= v then\n\t\t\t\treturn\n\t\t\tend\n\t\tend\n\t\treturn true\n\tend\n\n\tfor _, key in pairs(Util.keys(t)) do\n\t\tif matchAll(t[key]) then\n\t\t\tt[key] = nil\n\t\tend\n\tend\nend\n\n-- remove table entries if passed function returns false\nfunction Map.prune(t, fn)\n\tfor _,k in pairs(Util.keys(t)) do\n\t\tlocal v = t[k]\n\t\tif type(v) == 'table' then\n\t\t\tt[k] = Map.prune(v, fn)\n\t\tend\n\t\tif not fn(t[k]) then\n\t\t\tt[k] = nil\n\t\tend\n\tend\n\treturn t\nend\n\nfunction Map.size(list)\n\tlocal length = 0\n\tfor _ in pairs(list) do\n\t\tlength = length + 1\n\tend\n\treturn length\nend\n\nreturn Map\n", "sys/modules/opus/array.lua": "local Util = require('opus.util')\n\nlocal Array = { }\n\nfunction Array.filter(it, f)\n\tlocal ot = { }\n\tfor _,v in pairs(it) do\n\t\tif f(v) then\n\t\t\ttable.insert(ot, v)\n\t\tend\n\tend\n\treturn ot\nend\n\nfunction Array.removeByValue(t, e)\n\tfor k,v in pairs(t) do\n\t\tif v == e then\n\t\t\ttable.remove(t, k)\n\t\t\treturn e\n\t\tend\n\tend\nend\n\nArray.find = Util.find\n\nreturn Array\n", "sys/modules/opus/nft.lua": "local Util = require('opus.util')\n\nlocal colors = _G.colors\n\nlocal NFT = { }\n\n-- largely copied from http://www.computercraft.info/forums2/index.php?/topic/5029-145-npaintpro/\n\nlocal hexToColor = { }\nfor n = 1, 16 do\n\thexToColor[string.sub(\"0123456789abcdef\", n, n)] = 2 ^ (n - 1)\nend\nlocal colorToHex = Util.transpose(hexToColor)\n\nlocal function getColourOf(hex)\n\treturn hexToColor[hex]\nend\n\nfunction NFT.parse(imageText)\n\tlocal image = {\n\t\tfg   = { },\n\t\tbg   = { },\n\t\ttext = { },\n\t}\n\n\tlocal num = 1\n\tlocal lines = Util.split(imageText)\n\twhile #lines[#lines] == 0 do\n\t\ttable.remove(lines, #lines)\n\tend\n\n\tfor _,sLine in ipairs(lines) do\n\t\ttable.insert(image.fg, { })\n\t\ttable.insert(image.bg, { })\n\t\ttable.insert(image.text, { })\n\n\t\t--As we're no longer 1-1, we keep track of what index to write to\n\t\tlocal writeIndex = 1\n\t\t--Tells us if we've hit a 30 or 31 (BG and FG respectively)- next char specifies the curr colour\n\n\t\tlocal tcol, bcol = colors.white,colors.black\n\t\tlocal cx, sx = 1, 0\n\t\twhile sx < #sLine do\n\t\t\tsx = sx + 1\n\t\t\tif sLine:sub(sx,sx) == \"\\30\" then\n\t\t\t\tbcol = getColourOf(sLine:sub(sx+1,sx+1))\n\t\t\t\tsx = sx + 1\n\t\t\telseif sLine:sub(sx,sx) == \"\\31\" then\n\t\t\t\ttcol = getColourOf(sLine:sub(sx+1,sx+1))\n\t\t\t\tsx = sx + 1\n\t\t\telse\n\t\t\t\timage.bg[num][writeIndex] = bcol\n\t\t\t\timage.fg[num][writeIndex] = tcol\n\t\t\t\timage.text[num][writeIndex] = sLine:sub(sx,sx)\n\t\t\t\twriteIndex = writeIndex + 1\n\t\t\t\tcx = cx + 1\n\t\t\tend\n\t\tend\n\t\timage.height = num\n\t\tif not image.width or writeIndex - 1 > image.width then\n\t\t\timage.width = writeIndex - 1\n\t\tend\n\t\tnum = num+1\n\tend\n\treturn image\nend\n\nfunction NFT.transparency(image)\n\tfor y = 1, image.height do\n\t\tfor _,key in pairs(Util.keys(image.fg[y])) do\n\t\t\tif image.fg[y][key] == colors.magenta then\n\t\t\t\timage.fg[y][key] = nil\n\t\t\tend\n\t\tend\n\t\tfor _,key in pairs(Util.keys(image.bg[y])) do\n\t\t\tif image.bg[y][key] == colors.magenta then\n\t\t\t\timage.bg[y][key] = nil\n\t\t\tend\n\t\tend\n\tend\nend\n\nfunction NFT.load(path)\n\tlocal imageText = Util.readFile(path)\n\tif not imageText then\n\t\terror('Unable to read image file')\n\tend\n\treturn NFT.parse(imageText)\nend\n\nfunction NFT.save(image, filename)\n\tlocal bgcode, txcode = '\\30', '\\31'\n\tlocal output = { }\n\n\tfor y = 1, image.height do\n\t\tlocal lastBG, lastFG\n\t\tif image.text[y] then\n\t\t\tfor x = 1, #image.text[y] do\n\t\t\t\tlocal bg = image.bg[y][x] or colors.magenta\n\t\t\t\tif bg ~= lastBG then\n\t\t\t\t\tlastBG = bg\n\t\t\t\t\ttable.insert(output, bgcode .. colorToHex[bg])\n\t\t\t\tend\n\n\t\t\t\tlocal fg = image.fg[y][x] or colors.magenta\n\t\t\t\tif fg ~= lastFG then\n\t\t\t\t\tlastFG = fg\n\t\t\t\t\ttable.insert(output, txcode .. colorToHex[fg])\n\t\t\t\tend\n\n\t\t\t\ttable.insert(output, image.text[y][x])\n\t\t\tend\n\t\tend\n\n\t\tif y < image.height then\n\t\t\ttable.insert(output, '\\n')\n\t\tend\n\tend\n\tUtil.writeFile(filename, table.concat(output))\nend\n\nreturn NFT\n", "sys/modules/opus/peripheral.lua": "local Util   = require('opus.util')\n\nlocal Peripheral = Util.shallowCopy(_G.peripheral)\n\nfunction Peripheral.getList()\n\tif _G.device then\n\t\treturn _G.device\n\tend\n\n\tlocal deviceList = { }\n\tfor _,side in pairs(Peripheral.getNames()) do\n\t\tPeripheral.addDevice(deviceList, side)\n\tend\n\n\treturn deviceList\nend\n\nfunction Peripheral.addDevice(deviceList, side)\n\tlocal name = side\n\tpcall(function()\n\t\tlocal ptype = Peripheral.getType(side)\n\t\tlocal dev = Peripheral.wrap(side)\n\n\t\tif not ptype or not dev then\n\t\t\treturn\n\t\tend\n\n\t\tif ptype == 'modem' then\n\t\t\tif not Peripheral.call(name, 'isWireless') then\n\t--\t\t\tptype = 'wireless_modem'\n\t--\t\telse\n\t\t\t\tptype = 'wired_modem'\n\t\t\t\tif dev.isAccessPoint then\n\t\t\t\t\t-- avoid open computer relays being registered\n\t\t\t\t\t-- as 'wired_modem'\n\t\t\t\t\tptype = dev.getMetadata().name or 'wired_modem'\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\n\t\tlocal sides = {\n\t\t\tfront = true,\n\t\t\tback = true,\n\t\t\ttop = true,\n\t\t\tbottom = true,\n\t\t\tleft = true,\n\t\t\tright = true\n\t\t}\n\n\t\tif sides[name] then\n\t\t\tlocal i = 1\n\t\t\tlocal uniqueName = ptype\n\t\t\twhile deviceList[uniqueName] do\n\t\t\t\tuniqueName = ptype .. '_' .. i\n\t\t\t\ti = i + 1\n\t\t\tend\n\t\t\tname = uniqueName\n\t\tend\n\n\t\t-- this can randomly fail\n\t\tif not deviceList[name] then\n\t\t\t\tdeviceList[name] = dev\n\n\t\t\tif deviceList[name] then\n\t\t\t\tUtil.merge(deviceList[name], {\n\t\t\t\t\tname = name,\n\t\t\t\t\ttype = ptype,\n\t\t\t\t\tside = side,\n\t\t\t\t})\n\t\t\tend\n\t\tend\n\tend)\n\n\treturn deviceList[name]\nend\n\nfunction Peripheral.getBySide(side)\n\treturn Util.find(Peripheral.getList(), 'side', side)\nend\n\nfunction Peripheral.getByType(typeName)\n\treturn Util.find(Peripheral.getList(), 'type', typeName)\nend\n\nfunction Peripheral.getByMethod(method)\n\tfor _,p in pairs(Peripheral.getList()) do\n\t\tif p[method] then\n\t\t\treturn p\n\t\tend\n\tend\nend\n\n-- match any of the passed arguments\nfunction Peripheral.get(args)\n\n\tif type(args) == 'string' then\n\t\targs = { type = args }\n\tend\n\n\tif args.name then\n\t\treturn _G.device[args.name]\n\tend\n\n\tif args.type then\n\t\tlocal p = Peripheral.getByType(args.type)\n\t\tif p then\n\t\t\treturn p\n\t\tend\n\tend\n\n\tif args.method then\n\t\tlocal p = Peripheral.getByMethod(args.method)\n\t\tif p then\n\t\t\treturn p\n\t\tend\n\tend\n\n\tif args.side then\n\t\tlocal p = Peripheral.getBySide(args.side)\n\t\tif p then\n\t\t\treturn p\n\t\tend\n\tend\nend\n\nreturn Peripheral\n", "sys/modules/opus/sound.lua": "local peripheral  = _G.peripheral\n\nlocal Sound = {\n\t_volume = 1,\n}\n\nfunction Sound.play(sound, vol)\n\tperipheral.find('speaker', function(_, s)\n\t\ts.playSound('minecraft:' .. sound, vol or Sound._volume)\n\tend)\nend\n\nfunction Sound.setVolume(volume)\n\tSound._volume = math.max(0, math.min(volume, 1))\nend\n\nreturn Sound\n", "sys/modules/opus/config.lua": "local Util = require('opus.util')\n\nlocal fs    = _G.fs\n\nlocal Config = { }\n\nfunction Config.load(fname, data)\n\tlocal filename = 'usr/config/' .. fname\n\tdata = data or { }\n\n\tif not fs.exists('usr/config') then\n\t\tfs.makeDir('usr/config')\n\tend\n\n\tif not fs.exists(filename) then\n\t\tUtil.writeTable(filename, data)\n\telse\n\t\tlocal contents = Util.readTable(filename) or\n\t\t\terror('Configuration file is corrupt:' .. filename)\n\n\t\tUtil.merge(data, contents)\n\tend\n\n\treturn data\nend\n\nfunction Config.update(fname, data)\n\tlocal filename = 'usr/config/' .. fname\n\tUtil.writeTable(filename, data)\nend\n\nreturn Config\n", "sys/modules/opus/point.lua": "local Util = require('opus.util')\n\nlocal Point = { }\n\nPoint.directions = {\n\t[ 0 ] = { xd =  1, zd =  0, yd =  0, heading = 0, direction = 'east'  },\n\t[ 1 ] = { xd =  0, zd =  1, yd =  0, heading = 1, direction = 'south' },\n\t[ 2 ] = { xd = -1, zd =  0, yd =  0, heading = 2, direction = 'west'  },\n\t[ 3 ] = { xd =  0, zd = -1, yd =  0, heading = 3, direction = 'north' },\n\t[ 4 ] = { xd =  0, zd =  0, yd =  1, heading = 4, direction = 'up'    },\n\t[ 5 ] = { xd =  0, zd =  0, yd = -1, heading = 5, direction = 'down'  },\n}\n\nPoint.facings = {\n\t[ 0 ] = Point.directions[0],\n\t[ 1 ] = Point.directions[1],\n\t[ 2 ] = Point.directions[2],\n\t[ 3 ] = Point.directions[3],\n\teast  = Point.directions[0],\n\tsouth = Point.directions[1],\n\twest  = Point.directions[2],\n\tnorth = Point.directions[3],\n}\n\nPoint.headings = {\n\t[ 0 ] = Point.directions[0],\n\t[ 1 ] = Point.directions[1],\n\t[ 2 ] = Point.directions[2],\n\t[ 3 ] = Point.directions[3],\n\t[ 4 ] = Point.directions[4],\n\t[ 5 ] = Point.directions[5],\n\teast  = Point.directions[0],\n\tsouth = Point.directions[1],\n\twest  = Point.directions[2],\n\tnorth = Point.directions[3],\n\tup    = Point.directions[4],\n\tdown  = Point.directions[5],\n}\n\nPoint.EAST  = 0\nPoint.SOUTH = 1\nPoint.WEST  = 2\nPoint.NORTH = 3\nPoint.UP    = 4\nPoint.DOWN  = 5\n\nfunction Point.copy(pt)\n\treturn { x = pt.x, y = pt.y, z = pt.z }\nend\n\nfunction Point.round(pt)\n\tpt.x = Util.round(pt.x)\n\tpt.y = Util.round(pt.y)\n\tpt.z = Util.round(pt.z)\n\treturn pt\nend\n\nfunction Point.same(pta, ptb)\n\treturn pta.x == ptb.x and\n\t\t\t\t pta.y == ptb.y and\n\t\t\t\t pta.z == ptb.z\nend\n\nfunction Point.above(pt)\n\treturn { x = pt.x, y = pt.y + 1, z = pt.z, heading = pt.heading }\nend\n\nfunction Point.below(pt)\n\treturn { x = pt.x, y = pt.y - 1, z = pt.z, heading = pt.heading }\nend\n\nfunction Point.subtract(a, b)\n\ta.x = a.x - b.x\n\ta.y = a.y - b.y\n\ta.z = a.z - b.z\nend\n\n-- Euclidian distance\nfunction Point.distance(a, b)\n\treturn math.sqrt(\n\t\t\t\t\t math.pow(a.x - b.x, 2) +\n\t\t\t\t\t math.pow(a.y - b.y, 2) +\n\t\t\t\t\t math.pow(a.z - b.z, 2))\nend\n\n-- turtle distance (manhattan)\nfunction Point.turtleDistance(a, b)\n\tif a.y and b.y then\n\t\treturn math.abs(a.x - b.x) +\n\t\t\t\t\t math.abs(a.y - b.y) +\n\t\t\t\t\t math.abs(a.z - b.z)\n\telse\n\t\treturn math.abs(a.x - b.x) +\n\t\t\t\t\t math.abs(a.z - b.z)\n\tend\nend\n\nfunction Point.calculateTurns(ih, oh)\n\tif ih == oh then\n\t\treturn 0\n\tend\n\tif (ih % 2) == (oh % 2) then\n\t\treturn 2\n\tend\n\treturn 1\nend\n\nfunction Point.calculateHeading(pta, ptb)\n\tlocal heading\n\tlocal xd, zd = pta.x - ptb.x, pta.z - ptb.z\n\n\tif (pta.heading % 2) == 0 and zd ~= 0 then\n\t\theading = zd < 0 and 1 or 3\n\telseif (pta.heading % 2) == 1 and xd ~= 0 then\n\t\theading = xd < 0 and 0 or 2\n\telseif pta.heading == 0 and xd > 0 then\n\t\theading = 2\n\telseif pta.heading == 2 and xd < 0 then\n\t\theading = 0\n\telseif pta.heading == 1 and zd > 0 then\n\t\theading = 3\n\telseif pta.heading == 3 and zd < 0 then\n\t\theading = 1\n\tend\n\n\treturn heading or pta.heading\nend\n\n-- Calculate distance to location including turns\n-- also returns the resulting heading\nfunction Point.calculateMoves(pta, ptb, distance)\n\tlocal heading = pta.heading\n\tlocal moves = distance or Point.turtleDistance(pta, ptb)\n\tlocal weighted = moves\n\n\tif (pta.heading % 2) == 0 and pta.z ~= ptb.z then\n\t\tmoves = moves + 1\n\t\tweighted = weighted + .9\n\t\tif ptb.heading and (ptb.heading % 2 == 1) then\n\t\t\theading = ptb.heading\n\t\telseif ptb.z > pta.z then\n\t\t\theading = 1\n\t\telse\n\t\t\theading = 3\n\t\tend\n\telseif (pta.heading % 2) == 1 and pta.x ~= ptb.x then\n\t\tmoves = moves + 1\n\t\tweighted = weighted + .9\n\t\tif ptb.heading and (ptb.heading % 2 == 0) then\n\t\t\theading = ptb.heading\n\t\telseif ptb.x > pta.x then\n\t\t\theading = 0\n\t\telse\n\t\t\theading = 2\n\t\tend\n\tend\n\n\tif not ptb.heading then\n\t\treturn moves, heading, weighted\n\tend\n\n\t-- need to know if we are in digging mode\n\t-- if so, we need to face blocks -- need a no-backwards flag\n\n\t-- calc turns as slightly less than moves\n\t-- local weighted = moves\n\tif heading ~= ptb.heading then\n\t\tlocal turns = Point.calculateTurns(heading, ptb.heading)\n\t\tmoves = moves + turns\n\t\tlocal wturns = { [0] = 0, [1] = .9, [2] = 1.8 }\n\t\tweighted = weighted + wturns[turns]\n\t\theading = ptb.heading\n\tend\n\n\treturn moves, heading, weighted\nend\n\n-- given a set of points, find the one taking the least moves\nfunction Point.closest(reference, pts)\n\tif #pts == 1 then\n\t\treturn pts[1]\n\tend\n\n\tlocal lm, lpt = math.huge\n\tfor _,pt in pairs(pts) do\n\t\tlocal distance = Point.turtleDistance(reference, pt)\n\t\tif not reference.heading then\n\t\t\tif distance < lm then\n\t\t\t\tlpt = pt\n\t\t\t\tlm = distance\n\t\t\tend\n\t\telseif distance < lm then\n\t\t\tlocal _, _, m = Point.calculateMoves(reference, pt, distance)\n\t\t\tif m < lm then\n\t\t\t\tlpt = pt\n\t\t\t\tlm = m\n\t\t\tend\n\t\tend\n\tend\n\treturn lpt\nend\n\nfunction Point.eachClosest(spt, ipts, fn)\n\tif not ipts then error('Point.eachClosest: invalid points', 2) end\n\n\tlocal pts = Util.shallowCopy(ipts)\n\twhile #pts > 0 do\n\t\tlocal pt = Point.closest(spt, pts)\n\t\tlocal r = fn(pt)\n\t\tif r then\n\t\t\treturn r\n\t\tend\n\t\tUtil.removeByValue(pts, pt)\n\tend\nend\n\nfunction Point.iterateClosest(spt, ipts)\n\tlocal pts = Util.shallowCopy(ipts)\n\treturn function()\n\t\tlocal pt = Point.closest(spt, pts)\n\t\tif pt then\n\t\t\tUtil.removeByValue(pts, pt)\n\t\t\treturn pt\n\t\tend\n\tend\nend\n\nfunction Point.adjacentPoints(pt)\n\tlocal pts = { }\n\n\tfor i = 0, 5 do\n\t\tlocal hi = Point.headings[i]\n\t\ttable.insert(pts, { x = pt.x + hi.xd, y = pt.y + hi.yd, z = pt.z + hi.zd })\n\tend\n\n\treturn pts\nend\n\n-- get the point nearest A that is in the direction of B\nfunction Point.nearestTo(pta, ptb)\n\tlocal heading\n\n\tif pta.x < ptb.x then\n\t\theading = 0\n\telseif pta.z < ptb.z then\n\t\theading = 1\n\telseif pta.x > ptb.x then\n\t\theading = 2\n\telseif pta.z > ptb.z then\n\t\theading = 3\n\telseif pta.y < ptb.y then\n\t\theading = 4\n\telseif pta.y > ptb.y then\n\t\theading = 5\n\tend\n\n\tif heading then\n\t\treturn {\n\t\t\tx = pta.x + Point.headings[heading].xd,\n\t\t\ty = pta.y + Point.headings[heading].yd,\n\t\t\tz = pta.z + Point.headings[heading].zd,\n\t\t}\n\tend\n\n\treturn pta -- error ?\nend\n\nfunction Point.rotate(pt, facing)\n\tlocal x, z = pt.x, pt.z\n\tif facing == 1 then\n\t\tpt.x = z\n\t\tpt.z = -x\n\telseif facing == 2 then\n\t\tpt.x = -x\n\t\tpt.z = -z\n\telseif facing == 3 then\n\t\tpt.x = -z\n\t\tpt.z = x\n\tend\nend\n\nfunction Point.makeBox(pt1, pt2)\n\treturn {\n\t\tx = pt1.x,\n\t\ty = pt1.y,\n\t\tz = pt1.z,\n\t\tex = pt2.x,\n\t\tey = pt2.y,\n\t\tez = pt2.z,\n\t}\nend\n\n-- expand box to include point\nfunction Point.expandBox(box, pt)\n\tif pt.x < box.x then\n\t\tbox.x = pt.x\n\telseif pt.x > box.ex then\n\t\tbox.ex = pt.x\n\tend\n\tif pt.y < box.y then\n\t\tbox.y = pt.y\n\telseif pt.y > box.ey then\n\t\tbox.ey = pt.y\n\tend\n\tif pt.z < box.z then\n\t\tbox.z = pt.z\n\telseif pt.z > box.ez then\n\t\tbox.ez = pt.z\n\tend\nend\n\nfunction Point.normalizeBox(box)\n\treturn {\n\t\tx = math.min(box.x, box.ex),\n\t\ty = math.min(box.y, box.ey),\n\t\tz = math.min(box.z, box.ez),\n\t\tex = math.max(box.x, box.ex),\n\t\tey = math.max(box.y, box.ey),\n\t\tez = math.max(box.z, box.ez),\n\t}\nend\n\nfunction Point.inBox(pt, box)\n\treturn pt.x >= box.x and\n\t\t\t\t pt.y >= box.y and\n\t\t\t\t pt.z >= box.z and\n\t\t\t\t pt.x <= box.ex and\n\t\t\t\t pt.y <= box.ey and\n\t\t\t\t pt.z <= box.ez\nend\n\nfunction Point.closestPointInBox(pt, box)\n\tlocal cpt = {\n\t\tx = math.abs(pt.x - box.x) < math.abs(pt.x - box.ex) and box.x or box.ex,\n\t\ty = math.abs(pt.y - box.y) < math.abs(pt.y - box.ey) and box.y or box.ey,\n\t\tz = math.abs(pt.z - box.z) < math.abs(pt.z - box.ez) and box.z or box.ez,\n\t}\n\tcpt.x = pt.x > box.x and pt.x < box.ex and pt.x or cpt.x\n\tcpt.y = pt.y > box.y and pt.y < box.ey and pt.y or cpt.y\n\tcpt.z = pt.z > box.z and pt.z < box.ez and pt.z or cpt.z\n\n\treturn cpt\nend\n\nreturn Point\n", "sys/modules/opus/entry.lua": "local class = require('opus.class')\n\nlocal os = _G.os\n\n-- convert value to a string (supporting nils or numbers in value)\nlocal function _val(a)\n\treturn a and tostring(a) or ''\nend\n\nlocal Entry = class()\n\nfunction Entry:init(args)\n\tself.pos = 0\n\tself.scroll = 0\n\tself.value = args.value\n\tself.width = args.width or 256\n\tself.limit = args.limit or 1024\n\tself.mark = { }\n\tself.offset = args.offset or 1\n\tself.transform = args.transform or function(a) return a end\nend\n\nfunction Entry:reset()\n\tself.pos = 0\n\tself.scroll = 0\n\tself.value = nil\n\tself.mark = { }\nend\n\nfunction Entry:nextWord()\n\tlocal value = _val(self.value)\n\treturn select(2, value:find(\"[%s%p]?%w[%s%p]\", self.pos + 1)) or #value\nend\n\nfunction Entry:prevWord()\n\tlocal value = _val(self.value)\n\tlocal x = #value - (self.pos - 1)\n\tlocal _, n = value:reverse():find(\"[%s%p]?%w[%s%p]\", x)\n\treturn n and #value - n + 1 or 0\nend\n\nfunction Entry:updateScroll()\n\tlocal ps = self.scroll\n\tlocal len = #_val(self.value)\n\tif self.pos > len then\n\t\tself.pos = len\n\t\tself.scroll = 0 -- ??\n\tend\n\tif self.pos - self.scroll > self.width then\n\t\tself.scroll = math.max(0, self.pos - self.width)\n\telseif self.pos < self.scroll then\n\t\tself.scroll = self.pos\n\tend\n\tif self.scroll > 0 then\n\t\tif self.scroll + self.width  > len then\n\t\t\tself.scroll = math.max(0, len - self.width)\n\t\tend\n\tend\n\tif ps ~= self.scroll then\n\t\tself.textChanged = true\n\tend\nend\n\nfunction Entry:copyText(cx, ex)\n\t-- this should be transformed (ie. if number)\n\treturn _val(self.value):sub(cx + 1, ex)\nend\n\nfunction Entry:insertText(x, text)\n\ttext = tostring(self.transform(text) or '')\n\tif #text > 0 then\n\t\tlocal value = _val(self.value)\n\t\tif #value + #text > self.limit then\n\t\t\ttext = text:sub(1, self.limit-#value)\n\t\tend\n\t\tself.value = self.transform(value:sub(1, x) .. text .. value:sub(x + 1))\n\t\tself.pos = self.pos + #text\n\tend\nend\n\nfunction Entry:deleteText(sx, ex)\n\tlocal value = _val(self.value)\n\tlocal front = value:sub(1, sx)\n\tlocal back = value:sub(ex + 1, #value)\n\tself.value = self.transform(front .. back)\n\tself.pos = sx\nend\n\nfunction Entry:moveLeft()\n\tif self.pos > 0 then\n\t\tself.pos = self.pos - 1\n\t\treturn true\n\tend\nend\n\nfunction Entry:moveRight()\n\tif self.pos < #_val(self.value) then\n\t\tself.pos = self.pos + 1\n\t\treturn true\n\tend\nend\n\nfunction Entry:moveHome()\n\tif self.pos ~= 0 then\n\t\tself.pos = 0\n\t\treturn true\n\tend\nend\n\nfunction Entry:moveEnd()\n\tif self.pos ~= #_val(self.value) then\n\t\tself.pos = #_val(self.value)\n\t\treturn true\n\tend\nend\n\nfunction Entry:moveTo(ie)\n\tself.pos = math.max(0, math.min(ie.x + self.scroll - self.offset, #_val(self.value)))\nend\n\nfunction Entry:backspace()\n\tif self.mark.active then\n\t\tself:delete()\n\telseif self:moveLeft() then\n\t\tself:delete()\n\tend\nend\n\nfunction Entry:moveWordRight()\n\tif self.pos < #_val(self.value) then\n\t\tself.pos = self:nextWord(self.value, self.pos + 1)\n\t\treturn true\n\tend\nend\n\nfunction Entry:moveWordLeft()\n\tif self.pos > 0 then\n\t\tself.pos = self:prevWord(self.value, self.pos - 1) or 0\n\t\treturn true\n\tend\nend\n\nfunction Entry:delete()\n\tif self.mark.active then\n\t\tself:deleteText(self.mark.x, self.mark.ex)\n\telseif self.pos < #_val(self.value) then\n\t\tself:deleteText(self.pos, self.pos + 1)\n\tend\nend\n\nfunction Entry:cutFromStart()\n\tif self.pos > 0 then\n\t\tlocal text = self:copyText(1, self.pos)\n\t\tself:deleteText(1, self.pos)\n\t\tos.queueEvent('clipboard_copy', text)\n\tend\nend\n\nfunction Entry:cutToEnd()\n\tlocal value = _val(self.value)\n\tif self.pos < #value then\n\t\tlocal text = self:copyText(self.pos, #value)\n\t\tself:deleteText(self.pos, #value)\n\t\tos.queueEvent('clipboard_copy', text)\n\tend\nend\n\nfunction Entry:cutNextWord()\n\tif self.pos < #_val(self.value) then\n\t\tlocal ex = self:nextWord(self.value, self.pos)\n\t\tlocal text = self:copyText(self.pos, ex)\n\t\tself:deleteText(self.pos, ex)\n\t\tos.queueEvent('clipboard_copy', text)\n\tend\nend\n\nfunction Entry:cutPrevWord()\n\tif self.pos > 0 then\n\t\tlocal sx = self:prevWord(self.value, self.pos)\n\t\tlocal text = self:copyText(sx, self.pos)\n\t\tself:deleteText(sx, self.pos)\n\t\tos.queueEvent('clipboard_copy', text)\n\tend\nend\n\nfunction Entry:insertChar(ie)\n\tif self.mark.active then\n\t\tself:delete()\n\tend\n\tself:insertText(self.pos, ie.ch)\nend\n\nfunction Entry:copy()\n\tif #_val(self.value) > 0 then\n\t\tself.mark.continue = true\n\t\tif self.mark.active then\n\t\t\tself:copyMarked()\n\t\telse\n\t\t\tos.queueEvent('clipboard_copy', self.value)\n\t\tend\n\tend\nend\n\nfunction Entry:cut()\n\tif self.mark.active then\n\t\tself:copyMarked()\n\t\tself:delete()\n\tend\nend\n\nfunction Entry:copyMarked()\n\tlocal text = self:copyText(self.mark.x, self.mark.ex)\n\tos.queueEvent('clipboard_copy', text)\nend\n\nfunction Entry:paste(ie)\n\tif #ie.text > 0 then\n\t\tif self.mark.active then\n\t\t\tself:delete()\n\t\tend\n\t\tself:insertText(self.pos, ie.text)\n\tend\nend\n\nfunction Entry.forcePaste()\n\tos.queueEvent('clipboard_paste')\nend\n\nfunction Entry:clearLine()\n\tif #_val(self.value) > 0 then\n\t\tself:reset()\n\tend\nend\n\nfunction Entry:markBegin()\n\tif not self.mark.active then\n\t\tif #_val(self.value) > 0 then\n\t\t\tself.mark.active = true\n\t\tend\n\t\tself.mark.anchor = { x = self.pos }\n\tend\nend\n\nfunction Entry:markFinish()\n\tif self.pos == self.mark.anchor.x then\n\t\tself.mark.active = false\n\telse\n\t\tself.mark.x = math.min(self.mark.anchor.x, self.pos)\n\t\tself.mark.ex = math.max(self.mark.anchor.x, self.pos)\n\tend\n\tself.textChanged = true\n\tself.mark.continue = self.mark.active\nend\n\nfunction Entry:unmark()\n\tif self.mark.active then\n\t\tself.textChanged = true\n\t\tself.mark.active = false\n\tend\nend\n\nfunction Entry:markAnchor(ie)\n\tlocal wasMarking = self.mark.active\n\tself:unmark()\n\tself:moveTo(ie)\n\tself:markBegin()\n\tself:markFinish()\n\n\tself.textChanged = wasMarking\nend\n\nfunction Entry:markLeft()\n\tself:markBegin()\n\tif self:moveLeft() then\n\t\tself:markFinish()\n\telse\n\t\tself.mark.continue = self.mark.active\n\tend\nend\n\nfunction Entry:markRight()\n\tself:markBegin()\n\tif self:moveRight() then\n\t\tself:markFinish()\n\telse\n\t\tself.mark.continue = self.mark.active\n\tend\nend\n\nfunction Entry:markWord(ie)\n\tlocal index = 1\n\tself:moveTo(ie)\n\twhile true do\n\t\tlocal s, e = _val(self.value):find('%w+', index)\n\t\tif not s or s - 1 > self.pos then\n\t\t\tbreak\n\t\tend\n\t\tif self.pos >= s - 1 and self.pos < e then\n\t\t\tself.pos = s - 1\n\t\t\tself:markBegin()\n\t\t\tself.pos = e\n\t\t\tself:markFinish()\n\t\t\tself:moveTo(ie)\n\t\t\tbreak\n\t\tend\n\t\tindex = e + 1\n\tend\nend\n\nfunction Entry:markNextWord()\n\tself:markBegin()\n\tif self:moveWordRight() then\n\t\tself:markFinish()\n\telse\n\t\tself.mark.continue = self.mark.active\n\tend\nend\n\nfunction Entry:markPrevWord()\n\tself:markBegin()\n\tif self:moveWordLeft() then\n\t\tself:markFinish()\n\telse\n\t\tself.mark.continue = self.mark.active\n\tend\nend\n\nfunction Entry:markAll()\n\tif #_val(self.value) > 0 then\n\t\tself.mark.anchor = { x = 1 }\n\t\tself.mark.active = true\n\t\tself.mark.continue = true\n\t\tself.mark.x = 0\n\t\tself.mark.ex = #_val(self.value)\n\t\tself.textChanged = true\n\tend\nend\n\nfunction Entry:markHome()\n\tself:markBegin()\n\tif self:moveHome() then\n\t\tself:markFinish()\n\telse\n\t\tself.mark.continue = self.mark.active\n\tend\nend\n\nfunction Entry:markEnd()\n\tself:markBegin()\n\tif self:moveEnd() then\n\t\tself:markFinish()\n\telse\n\t\tself.mark.continue = self.mark.active\n\tend\nend\n\nfunction Entry:markTo(ie)\n\tself:markBegin()\n\tself:moveTo(ie)\n\tself:markFinish()\nend\n\nlocal mappings = {\n\t[ 'left'                ] = Entry.moveLeft,\n\t[ 'control-b'           ] = Entry.moveLeft,\n\t[ 'right'               ] = Entry.moveRight,\n\t[ 'control-f'           ] = Entry.moveRight,\n\t[ 'home'                ] = Entry.moveHome,\n\t[ 'end'                 ] = Entry.moveEnd,\n\t[ 'control-e'           ] = Entry.moveEnd,\n\t[ 'mouse_click'         ] = Entry.moveTo,\n\t[ 'control-right'       ] = Entry.moveWordRight,\n\t[ 'alt-f'               ] = Entry.moveWordRight,\n\t[ 'control-left'        ] = Entry.moveWordLeft,\n\t[ 'alt-b'               ] = Entry.moveWordLeft,\n\n\t[ 'backspace'           ] = Entry.backspace,\n\t[ 'delete'              ] = Entry.delete,\n\t[ 'char'                ] = Entry.insertChar,\n\t[ 'mouse_rightclick'    ] = Entry.clearLine,\n\n\t[ 'control-c'           ] = Entry.copy,\n\t[ 'control-u'           ] = Entry.cutFromStart,\n\t[ 'control-k'           ] = Entry.cutToEnd,\n\t[ 'control-w'           ] = Entry.cutPrevWord,\n\t--[ 'control-d'           ] = Entry.cutNextWord,\n\t[ 'control-x'           ] = Entry.cut,\n\t[ 'paste'               ] = Entry.paste,\n\t[ 'control-y'           ] = Entry.forcePaste,  -- well this won't work...\n\n\t[ 'mouse_doubleclick'   ] = Entry.markWord,\n\t[ 'mouse_tripleclick'   ] = Entry.markAll,\n\t[ 'shift-left'          ] = Entry.markLeft,\n\t[ 'shift-right'         ] = Entry.markRight,\n\t[ 'mouse_down'          ] = Entry.markAnchor,\n\t[ 'mouse_drag'          ] = Entry.markTo,\n\t[ 'shift-mouse_click'   ] = Entry.markTo,\n\t[ 'control-a'           ] = Entry.markAll,\n\t[ 'control-shift-right' ] = Entry.markNextWord,\n\t[ 'control-shift-left'  ] = Entry.markPrevWord,\n\t[ 'shift-end'           ] = Entry.markEnd,\n\t[ 'shift-home'          ] = Entry.markHome,\n}\n\nfunction Entry:process(ie)\n\tlocal action = mappings[ie.code]\n\n\tself.textChanged = false\n\n\tif action then\n\t\tlocal pos = self.pos\n\t\tlocal line = self.value\n\n\t\tlocal wasMarking = self.mark.continue\n\t\tself.mark.continue = false\n\n\t\taction(self, ie)\n\n\t\tif not self.value or #_val(self.value) == 0 then\n\t\t\tself.value = nil\n\t\tend\n\n\t\tself.textChanged = self.textChanged or self.value ~= line\n\t\tself.posChanged = pos ~= self.pos\n\t\tself:updateScroll()\n\n\t\tif not self.mark.continue and wasMarking then\n\t\t\tself:unmark()\n\t\tend\n\n\t\treturn true\n\tend\nend\n\nreturn Entry\n", "sys/modules/opus/trace.lua": "-- stack trace by SquidDev (MIT License)\n-- https://raw.githubusercontent.com/SquidDev-CC/mbs/master/lib/stack_trace.lua\n\nlocal type = type\nlocal debug_traceback = type(debug) == \"table\" and type(debug.traceback) == \"function\" and debug.traceback\n\nlocal function traceback(x)\n\t-- Attempt to detect error() and error(\"xyz\", 0).\n\t-- This probably means they're erroring the program intentionally and so we\n\t-- shouldn't display anything.\n\tif x == nil or (type(x) == \"string\" and not x:find(\":%d+:\")) then\n\t\treturn x\n\tend\n\n\tif x and x:match(':%d+: 0$') then\n\t\treturn x\n\tend\n\n\tif debug_traceback then\n\t\t-- The parens are important, as they prevent a tail call occuring, meaning\n\t\t-- the stack level is preserved. This ensures the code behaves identically\n\t\t-- on LuaJ and PUC Lua.\n\t\treturn (debug_traceback(tostring(x), 2))\n\telse\n\t\tlocal level = 3\n\t\tlocal out = { tostring(x), \"stack traceback:\" }\n\t\twhile true do\n\t\t\tlocal _, msg = pcall(error, \"\", level)\n\t\t\tif msg == \"\" then break end\n\n\t\t\tout[#out + 1] = \"  \" .. msg\n\t\t\tlevel = level + 1\n\t\tend\n\n\t\treturn table.concat(out, \"\\n\")\n\tend\nend\n\nlocal function trim_traceback(stack)\n\tlocal trace = { }\n\tlocal filters = {\n\t\t\"%[C%]: in function 'xpcall'\",\n\t\t\"(...tail calls...)\",\n\t\t\"xpcall: $\",\n\t\t\"trace.lua:%d+:\",\n\t\t\"stack traceback:\",\n\t}\n\n\tfor line in stack:gmatch(\"([^\\n]*)\\n?\") do table.insert(trace, line) end\n\n\tlocal err = { }\n\twhile true do\n\t\tlocal line = table.remove(trace, 1)\n\t\tif not line or line == 'stack traceback:' then\n\t\t\tbreak\n\t\tend\n\t\ttable.insert(err, line)\n\tend\n\terr = table.concat(err, '\\n')\n\n\tlocal function matchesFilter(line)\n\t\tfor _, filter in pairs(filters) do\n\t\t\tif line:match(filter) then\n\t\t\t\treturn true\n\t\t\tend\n\t\tend\n\tend\n\n\tlocal t = { }\n\tfor _, line in pairs(trace) do\n\t\tif not matchesFilter(line) then\n\t\t\tline = line:gsub(\"in function\", \"in\"):gsub('%w+/', '')\n\t\t\ttable.insert(t, line)\n\t\tend\n\tend\n\n\treturn err, t\nend\n\nreturn function (fn, ...)\n\tlocal args = { ... }\n\tlocal res = table.pack(xpcall(function()\n\t\treturn fn(table.unpack(args))\n\tend, traceback))\n\n\tif not res[1] and res[2] ~= nil then\n\t\tlocal err, trace = trim_traceback(res[2])\n\n\t\tif err:match(':%d+: 0$') then\n\t\t\treturn true\n\t\tend\n\n\t\tif #trace > 0 then\n\t\t\t_G._syslog('\\n' .. err .. '\\n' .. 'stack traceback:')\n\t\t\tfor _, v in ipairs(trace) do\n\t\t\t\t_G._syslog(v)\n\t\t\tend\n\t\tend\n\n\t\treturn res[1], err, trace\n\tend\n\n\treturn table.unpack(res, 1, res.n)\nend\n", "sys/modules/opus/history.lua": "local Util = require('opus.util')\n\nlocal History    = { }\nlocal History_mt = { __index = History }\n\nfunction History.load(filename, limit)\n\n\tlocal self = setmetatable({\n\t\tlimit = limit,\n\t\tfilename = filename,\n\t}, History_mt)\n\n\tself.entries = Util.readLines(filename) or { }\n\tself.pos = #self.entries + 1\n\n\treturn self\nend\n\nfunction History:add(line)\n\tif line ~= self.entries[#self.entries] then\n\t\ttable.insert(self.entries, line)\n\t\tif self.limit then\n\t\t\twhile #self.entries > self.limit do\n\t\t\t\ttable.remove(self.entries, 1)\n\t\t\tend\n\t\tend\n\t\tUtil.writeLines(self.filename, self.entries)\n\t\tself.pos = #self.entries + 1\n\tend\nend\n\nfunction History:reset()\n\tself.pos = #self.entries + 1\nend\n\nfunction History:back()\n\tif self.pos > 1 then\n\t\tself.pos = self.pos - 1\n\t\treturn self.entries[self.pos]\n\tend\nend\n\nfunction History:forward()\n\tif self.pos <= #self.entries then\n\t\tself.pos = self.pos + 1\n\t\treturn self.entries[self.pos]\n\tend\nend\n\nreturn History\n", "sys/modules/opus/packages.lua": "local Util = require('opus.util')\n\nlocal fs        = _G.fs\nlocal textutils = _G.textutils\n\nlocal PACKAGE_DIR = 'packages'\n\nlocal Packages = { }\n\nfunction Packages:installed()\n\tlocal list = { }\n\n\tif fs.exists(PACKAGE_DIR) then\n\t\tfor _, dir in pairs(fs.list(PACKAGE_DIR)) do\n\t\t\tlocal path = fs.combine(fs.combine(PACKAGE_DIR, dir), '.package')\n\t\t\tlist[dir] = Util.readTable(path)\n\t\tend\n\tend\n\n\treturn list\nend\n\nfunction Packages:installedSorted()\n\tlocal list = { }\n\n\tfor k, v in pairs(self.installed()) do\n\t\tv.name = k\n\t\tv.deps = { }\n\t\ttable.insert(list, v)\n\t\tfor _, v2 in pairs(v.required or { }) do\n\t\t\tv.deps[v2] = true\n\t\tend\n\tend\n\n\ttable.sort(list, function(a, b)\n\t\treturn not not (b.deps and b.deps[a.name])\n\tend)\n\n\ttable.sort(list, function(a, b)\n\t\treturn not (a.deps and a.deps[b.name])\n\tend)\n\n\treturn list\nend\n\nfunction Packages:list()\n\tif not fs.exists('usr/config/packages') then\n\t\tself:downloadList()\n\tend\n\treturn Util.readTable('usr/config/packages') or { }\nend\n\nfunction Packages:isInstalled(package)\n\treturn self:installed()[package]\nend\n\nfunction Packages:downloadList()\n\tlocal packages = {\n\t\t[ 'develop-1.8' ] = 'https://raw.githubusercontent.com/kepler155c/opus-apps/develop-1.8/packages.list',\n\t\t[ 'master-1.8' ] = 'https://pastebin.com/raw/pexZpAxt',\n\t}\n\n\tif packages[_G.OPUS_BRANCH] then\n\t\tUtil.download(packages[_G.OPUS_BRANCH], 'usr/config/packages')\n\tend\nend\n\nfunction Packages:downloadManifest(package)\n\tlocal list = self:list()\n\tlocal url = list and list[package]\n\n\tif url then\n\t\tlocal c = Util.httpGet(url)\n\t\tif c then\n\t\t\tc = textutils.unserialize(c)\n\t\t\tif c then\n\t\t\t\tc.repository = c.repository:gsub('{{OPUS_BRANCH}}', _G.OPUS_BRANCH)\n\t\t\t\treturn c\n\t\t\tend\n\t\tend\n\tend\nend\n\nfunction Packages:getManifest(package)\n\tlocal fname = 'packages/' .. package .. '/.package'\n\tif fs.exists(fname) then\n\t\tlocal c = Util.readTable(fname)\n\t\tif c and c.repository then\n\t\t\tc.repository = c.repository:gsub('{{OPUS_BRANCH}}', _G.OPUS_BRANCH)\n\t\t\treturn c\n\t\tend\n\tend\n\treturn self:downloadManifest(package)\nend\n\nreturn Packages\n", "sys/modules/opus/socket.lua": "local Crypto   = require('opus.crypto.chacha20')\nlocal ECC      = require('opus.crypto.ecc')\nlocal Security = require('opus.security')\nlocal SHA      = require('opus.crypto.sha2')\nlocal Util     = require('opus.util')\n\nlocal device    = _G.device\nlocal os        = _G.os\n\nlocal socketClass = { }\n\nfunction socketClass:read(timeout)\n\tlocal data, distance = _G.network.getTransport().read(self)\n\tif data then\n\t\treturn data, distance\n\tend\n\n\tif not self.connected then\n\t\treturn\n\tend\n\n\tlocal timerId = os.startTimer(timeout or 5)\n\n\twhile true do\n\t\tlocal e, id = os.pullEvent()\n\n\t\tif e == 'transport_' .. self.uid then\n\t\t\tdata, distance = _G.network.getTransport().read(self)\n\t\t\tif data then\n\t\t\t\tos.cancelTimer(timerId)\n\t\t\t\treturn data, distance\n\t\t\tend\n\t\t\tif not self.connected then\n\t\t\t\tbreak\n\t\t\tend\n\n\t\telseif e == 'timer' and id == timerId then\n\t\t\tif timeout or not self.connected then\n\t\t\t\tbreak\n\t\t\tend\n\t\t\ttimerId = os.startTimer(5)\n\t\t\tself:ping()\n\t\tend\n\tend\nend\n\nfunction socketClass:write(data)\n\tif self.connected then\n\t\t_G.network.getTransport().write(self, {\n\t\t\ttype = 'DATA',\n\t\t\tseq = self.wseq,\n\t\t\tdata = data,\n\t\t})\n\t\treturn true\n\tend\nend\n\nfunction socketClass:ping()\n\tif self.connected then\n\t\t_G.network.getTransport().ping(self)\n\t\treturn true\n\tend\nend\n\nfunction socketClass:close()\n\tif self.connected then\n\t\tself.transmit(self.dport, self.dhost, {\n\t\t\ttype = 'DISC',\n\t\t\tseq = self.wseq,\n\t\t})\n\t\tself.connected = false\n\tend\n\tdevice.wireless_modem.close(self.sport)\n\t_G.network.getTransport().close(self)\nend\n\nlocal Socket = { }\n\nlocal function loopback(port, sport, msg)\n\tos.queueEvent('modem_message', 'loopback', port, sport, msg, 0)\nend\n\nlocal function newSocket(isLoopback)\n\tfor _ = 16384, 32767 do\n\t\tlocal i = math.random(16384, 32767)\n\t\tif not device.wireless_modem.isOpen(i) then\n\t\t\tlocal socket = {\n\t\t\t\tshost = os.getComputerID(),\n\t\t\t\tsport = i,\n\t\t\t\ttransmit = device.wireless_modem.transmit,\n\t\t\t\ttimers = { },\n\t\t\t\tmessages = { },\n\t\t\t}\n\t\t\tsetmetatable(socket, { __index = socketClass })\n\n\t\t\tdevice.wireless_modem.open(socket.sport)\n\n\t\t\tif isLoopback then\n\t\t\t\tsocket.transmit = loopback\n\t\t\tend\n\t\t\treturn socket\n\t\tend\n\tend\n\terror('No ports available')\nend\n\nlocal function setupCrypto(socket, isClient)\n\tsocket.sharedKey = ECC.exchange(socket.privKey, socket.remotePubKey)\n\tsocket.enckey  = SHA.pbkdf2(socket.sharedKey, \"1enc\", 1)\n\t--self.hmackey  = SHA.pbkdf2(self.sharedKey, \"2hmac\", 1)\n\n\tsocket.rrng  = Crypto.newRNG(\n\t\tSHA.pbkdf2(socket.sharedKey, isClient and \"3rseed\" or \"4sseed\", 1))\n\tsocket.wrng  = Crypto.newRNG(\n\t\tSHA.pbkdf2(socket.sharedKey, isClient and \"4sseed\" or \"3rseed\", 1))\n\n\tsocket.rseq  = socket.rrng:nextInt(5)\n\tsocket.wseq  = socket.wrng:nextInt(5)\nend\n\nfunction Socket.connect(host, port, options)\n\tif not device.wireless_modem then\n\t\treturn false, 'Wireless modem not found', 'NOMODEM'\n\tend\n\n\tlocal socket = newSocket(host == os.getComputerID())\n\tsocket.dhost = tonumber(host)\n\tif options and options.keypair then\n\t\tsocket.privKey, socket.pubKey = table.unpack(options.keypair)\n\telse\n\t\tsocket.privKey, socket.pubKey = _G.network.getKeyPair()\n\tend\n\tlocal identifier = options and options.identifier or Security.getIdentifier()\n\n\tsocket.transmit(port, socket.sport, {\n\t\ttype = 'OPEN',\n\t\tshost = socket.shost,\n\t\tdhost = socket.dhost,\n\t\tt = Crypto.encrypt({ -- this is not that much data...\n\t\t\tts = os.epoch('utc'),\n\t\t\tpk = socket.pubKey:toHex(),\n\t\t}, Util.hexToByteArray(identifier)),\n\t})\n\n\tlocal timerId = os.startTimer(3)\n\trepeat\n\t\tlocal e, id, sport, dport, msg = os.pullEvent()\n\t\tif e == 'modem_message' and\n\t\t\t sport == socket.sport and\n\t\t\t type(msg) == 'table' and\n\t\t\t msg.dhost == socket.shost then\n\n\t\t\tos.cancelTimer(timerId)\n\n\t\t\tif msg.type == 'CONN' and type(msg.pk) == 'string' then\n\t\t\t\tsocket.dport = dport\n\t\t\t\tsocket.connected = true\n\t\t\t\tsocket.remotePubKey = Util.hexToByteArray(msg.pk)\n\t\t\t\tsocket.options = msg.options or { }\n\t\t\t\tsetupCrypto(socket, true)\n\t\t\t\t_G.network.getTransport().open(socket)\n\t\t\t\treturn socket\n\n\t\t\telseif msg.type == 'NOPASS' then\n\t\t\t\tsocket:close()\n\t\t\t\treturn false, 'Password not set on target', 'NOPASS'\n\n\t\t\telseif msg.type == 'REJE' then\n\t\t\t\tsocket:close()\n\t\t\t\treturn false, 'Trust not established', 'NOTRUST'\n\t\t\tend\n\t\tend\n\tuntil e == 'timer' and id == timerId\n\n\tsocket:close()\n\treturn false, 'Connection timed out', 'TIMEOUT'\nend\n\nlocal function trusted(socket, msg, options)\n\tlocal function getIdentifier()\n\t\tlocal trustList = Util.readTable('usr/.known_hosts') or { }\n\t\treturn trustList[msg.shost]\n\tend\n\n\tlocal identifier = options and options.identifier or getIdentifier()\n\n\tlocal  s, m = pcall(function()\n\t\tif identifier and type(msg.t) == 'table' then\n\t\t\tlocal data = Crypto.decrypt(msg.t, Util.hexToByteArray(identifier))\n\n\t\t\tif data and data.ts and tonumber(data.ts) then\n\t\t\t\tif math.abs(os.epoch('utc') - data.ts) < 4096 then\n\t\t\t\t\tsocket.remotePubKey = Util.hexToByteArray(data.pk)\n\t\t\t\t\tsocket.privKey, socket.pubKey = _G.network.getKeyPair()\n\t\t\t\t\tsetupCrypto(socket)\n\t\t\t\t\treturn true\n\t\t\t\tend\n\t\t\t\t_G._syslog('time diff ' .. math.abs(os.epoch('utc') - data.ts))\n\t\t\tend\n\t\tend\n\tend)\n\tif not s and m then\n\t\t_G._syslog('trust failure')\n\t\t_G._syslog(m)\n\tend\n\treturn s and m\nend\n\nfunction Socket.server(port, options)\n\tdevice.wireless_modem.open(port)\n\n\twhile true do\n\t\tlocal _, _, sport, dport, msg = os.pullEvent('modem_message')\n\n\t\tif sport == port and\n\t\t\t type(msg) == 'table' and\n\t\t\t msg.dhost == os.getComputerID() and\n\t\t\t msg.type == 'OPEN' then\n\n\t\t\tlocal socket = newSocket(msg.shost == os.getComputerID())\n\t\t\tsocket.dport = dport\n\t\t\tsocket.dhost = msg.shost\n\t\t\tsocket.options = options or { }\n\n\t\t\tif not Security.hasPassword() then\n\t\t\t\tsocket.transmit(socket.dport, socket.sport, {\n\t\t\t\t\ttype = 'NOPASS',\n\t\t\t\t\tdhost = socket.dhost,\n\t\t\t\t\tshost = socket.shost,\n\t\t\t\t})\n\t\t\t\tsocket:close()\n\n\t\t\telseif trusted(socket, msg, options) then\n\t\t\t\tsocket.connected = true\n\t\t\t\tsocket.transmit(socket.dport, socket.sport, {\n\t\t\t\t\ttype = 'CONN',\n\t\t\t\t\tdhost = socket.dhost,\n\t\t\t\t\tshost = socket.shost,\n\t\t\t\t\tpk = socket.pubKey:toHex(),\n\t\t\t\t\toptions = socket.options.ENCRYPT and { ENCRYPT = true },\n\t\t\t\t})\n\n\t\t\t\t_G.network.getTransport().open(socket)\n\t\t\t\treturn socket\n\n\t\t\telse\n\t\t\t\tsocket.transmit(socket.dport, socket.sport, {\n\t\t\t\t\ttype = 'REJE',\n\t\t\t\t\tdhost = socket.dhost,\n\t\t\t\t\tshost = socket.shost,\n\t\t\t\t})\n\t\t\t\tsocket:close()\n\t\t\tend\n\t\tend\n\tend\nend\n\nreturn Socket\n", "sys/modules/opus/sync.lua": "local Sync = {\n\tsyncLocks = { }\n}\n\nlocal os = _G.os\n\nfunction Sync.sync(obj, fn)\n\tlocal key = tostring(obj)\n\tif Sync.syncLocks[key] then\n\t\tlocal cos = tostring(coroutine.running())\n\t\ttable.insert(Sync.syncLocks[key], cos)\n\t\trepeat\n\t\t\tlocal _, co = os.pullEvent('sync_lock')\n\t\tuntil co == cos\n\telse\n\t\tSync.syncLocks[key] = { }\n\tend\n\tlocal s, m = pcall(fn)\n\tlocal co = table.remove(Sync.syncLocks[key], 1)\n\tif co then\n\t\tos.queueEvent('sync_lock', co)\n\telse\n\t\tSync.syncLocks[key] = nil\n\tend\n\tif not s then\n\t\terror(m)\n\tend\nend\n\nfunction Sync.lock(obj)\n\tlocal key = tostring(obj)\n\tif Sync.syncLocks[key] then\n\t\tlocal cos = tostring(coroutine.running())\n\t\ttable.insert(Sync.syncLocks[key], cos)\n\t\trepeat\n\t\t\tlocal _, co = os.pullEvent('sync_lock')\n\t\tuntil co == cos\n\telse\n\t\tSync.syncLocks[key] = { }\n\tend\nend\n\nfunction Sync.release(obj)\n\tlocal key = tostring(obj)\n\tif not Sync.syncLocks[key] then\n\t\terror('Sync.release: Lock was not obtained', 2)\n\tend\n\tlocal co = table.remove(Sync.syncLocks[key], 1)\n\tif co then\n\t\tos.queueEvent('sync_lock', co)\n\telse\n\t\tSync.syncLocks[key] = nil\n\tend\nend\n\nfunction Sync.isLocked(obj)\n\tlocal key = tostring(obj)\n\treturn not not Sync.syncLocks[key]\nend\n\nreturn Sync\n", "sys/modules/opus/cbor.lua": "-- Concise Binary Object Representation (CBOR)\n-- RFC 7049\n\nlocal function softreq(pkg, field)\n\tlocal ok, mod = pcall(require, pkg);\n\tif not ok then return end\n\tif field then return mod[field]; end\n\treturn mod;\nend\nlocal dostring = function (s)\n\tlocal ok, f = pcall(loadstring or load, s); -- luacheck: read globals loadstring\n\tif ok and f then return f(); end\nend\n\nlocal setmetatable = setmetatable;\nlocal getmetatable = getmetatable;\nlocal dbg_getmetatable = debug and debug.getmetatable;\nlocal assert = assert;\nlocal error = error;\nlocal type = type;\nlocal pairs = pairs;\nlocal ipairs = ipairs;\nlocal tostring = tostring;\nlocal s_char = string.char;\nlocal t_concat = table.concat;\nlocal t_sort = table.sort;\nlocal m_floor = math.floor;\nlocal m_abs = math.abs;\nlocal m_huge = math.huge;\nlocal m_max = math.max;\nlocal maxint = math.maxinteger or 9007199254740992;\nlocal minint = math.mininteger or -9007199254740992;\nlocal NaN = 0/0;\nlocal m_frexp = math.frexp;\nlocal m_ldexp = math.ldexp or function (x, exp) return x * 2.0 ^ exp; end;\nlocal m_type = math.type or function (n) return n % 1 == 0 and n <= maxint and n >= minint and \"integer\" or \"float\" end;\nlocal s_pack = string.pack or softreq(\"struct\", \"pack\");\nlocal s_unpack = string.unpack or softreq(\"struct\", \"unpack\");\nlocal b_rshift = softreq(\"bit32\", \"rshift\") or softreq(\"bit\", \"rshift\") or\n\tdostring \"return function(a,b) return a >> b end\" or\n\tfunction (a, b) return m_max(0, m_floor(a / (2 ^ b))); end;\n\n-- sanity check\nif s_pack and s_pack(\">I2\", 0) ~= \"\\0\\0\" then\n\ts_pack = nil;\nend\nif s_unpack and s_unpack(\">I2\", \"\\1\\2\\3\\4\") ~= 0x102 then\n\ts_unpack = nil;\nend\n\nlocal _ENV = nil; -- luacheck: ignore 211\n\nlocal encoder = {};\n\nlocal function encode(obj, opts)\n\treturn encoder[type(obj)](obj, opts);\nend\n\n-- Major types 0, 1 and length encoding for others\nlocal function integer(num, m)\n\tif m == 0 and num < 0 then\n\t\t-- negative integer, major type 1\n\t\tnum, m = - num - 1, 32;\n\tend\n\tif num < 24 then\n\t\treturn s_char(m + num);\n\telseif num < 2 ^ 8 then\n\t\treturn s_char(m + 24, num);\n\telseif num < 2 ^ 16 then\n\t\treturn s_char(m + 25, b_rshift(num, 8), num % 0x100);\n\telseif num < 2 ^ 32 then\n\t\treturn s_char(m + 26,\n\t\t\tb_rshift(num, 24) % 0x100,\n\t\t\tb_rshift(num, 16) % 0x100,\n\t\t\tb_rshift(num, 8) % 0x100,\n\t\t\tnum % 0x100);\n\telseif num < 2 ^ 64 then\n\t\tlocal high = m_floor(num / 2 ^ 32);\n\t\tnum = num % 2 ^ 32;\n\t\treturn s_char(m + 27,\n\t\t\tb_rshift(high, 24) % 0x100,\n\t\t\tb_rshift(high, 16) % 0x100,\n\t\t\tb_rshift(high, 8) % 0x100,\n\t\t\thigh % 0x100,\n\t\t\tb_rshift(num, 24) % 0x100,\n\t\t\tb_rshift(num, 16) % 0x100,\n\t\t\tb_rshift(num, 8) % 0x100,\n\t\t\tnum % 0x100);\n\tend\n\terror \"int too large\";\nend\n\nif s_pack then\n\tfunction integer(num, m)\n\t\tlocal fmt;\n\t\tm = m or 0;\n\t\tif num < 24 then\n\t\t\tfmt, m = \">B\", m + num;\n\t\telseif num < 256 then\n\t\t\tfmt, m = \">BB\", m + 24;\n\t\telseif num < 65536 then\n\t\t\tfmt, m = \">BI2\", m + 25;\n\t\telseif num < 4294967296 then\n\t\t\tfmt, m = \">BI4\", m + 26;\n\t\telse\n\t\t\tfmt, m = \">BI8\", m + 27;\n\t\tend\n\t\treturn s_pack(fmt, m, num);\n\tend\nend\n\nlocal simple_mt = {};\nfunction simple_mt:__tostring() return self.name or (\"simple(%d)\"):format(self.value); end\nfunction simple_mt:__tocbor() return self.cbor or integer(self.value, 224); end\n\nlocal function simple(value, name, cbor)\n\tassert(value >= 0 and value <= 255, \"bad argument #1 to 'simple' (integer in range 0..255 expected)\");\n\treturn setmetatable({ value = value, name = name, cbor = cbor }, simple_mt);\nend\n\nlocal tagged_mt = {};\nfunction tagged_mt:__tostring() return (\"%d(%s)\"):format(self.tag, tostring(self.value)); end\nfunction tagged_mt:__tocbor() return integer(self.tag, 192) .. encode(self.value); end\n\nlocal function tagged(tag, value)\n\tassert(tag >= 0, \"bad argument #1 to 'tagged' (positive integer expected)\");\n\treturn setmetatable({ tag = tag, value = value }, tagged_mt);\nend\n\nlocal null = simple(22, \"null\"); -- explicit null\nlocal undefined = simple(23, \"undefined\"); -- undefined or nil\nlocal BREAK = simple(31, \"break\", \"\\255\");\n\n-- Number types dispatch\nfunction encoder.number(num)\n\treturn encoder[m_type(num)](num);\nend\n\n-- Major types 0, 1\nfunction encoder.integer(num)\n\tif num < 0 then\n\t\treturn integer(-1 - num, 32);\n\tend\n\treturn integer(num, 0);\nend\n\n-- Major type 7\nfunction encoder.float(num)\n\tif num ~= num then -- NaN shortcut\n\t\treturn \"\\251\\127\\255\\255\\255\\255\\255\\255\\255\";\n\tend\n\tlocal sign = (num > 0 or 1 / num > 0) and 0 or 1;\n\tnum = m_abs(num)\n\tif num == m_huge then\n\t\treturn s_char(251, sign * 128 + 128 - 1) .. \"\\240\\0\\0\\0\\0\\0\\0\";\n\tend\n\tlocal fraction, exponent = m_frexp(num)\n\tif fraction == 0 then\n\t\treturn s_char(251, sign * 128) .. \"\\0\\0\\0\\0\\0\\0\\0\";\n\tend\n\tfraction = fraction * 2;\n\texponent = exponent + 1024 - 2;\n\tif exponent <= 0 then\n\t\tfraction = fraction * 2 ^ (exponent - 1)\n\t\texponent = 0;\n\telse\n\t\tfraction = fraction - 1;\n\tend\n\treturn s_char(251,\n\t\tsign * 2 ^ 7 + m_floor(exponent / 2 ^ 4) % 2 ^ 7,\n\t\texponent % 2 ^ 4 * 2 ^ 4 +\n\t\tm_floor(fraction * 2 ^ 4 % 0x100),\n\t\tm_floor(fraction * 2 ^ 12 % 0x100),\n\t\tm_floor(fraction * 2 ^ 20 % 0x100),\n\t\tm_floor(fraction * 2 ^ 28 % 0x100),\n\t\tm_floor(fraction * 2 ^ 36 % 0x100),\n\t\tm_floor(fraction * 2 ^ 44 % 0x100),\n\t\tm_floor(fraction * 2 ^ 52 % 0x100)\n\t)\nend\n\nif s_pack then\n\tfunction encoder.float(num)\n\t\treturn s_pack(\">Bd\", 251, num);\n\tend\nend\n\n\n-- Major type 2 - byte strings\nfunction encoder.bytestring(s)\n\treturn integer(#s, 64) .. s;\nend\n\n-- Major type 3 - UTF-8 strings\nfunction encoder.utf8string(s)\n\treturn integer(#s, 96) .. s;\nend\n\n-- Lua strings are byte strings\nencoder.string = encoder.bytestring;\n\nfunction encoder.boolean(bool)\n\treturn bool and \"\\245\" or \"\\244\";\nend\n\nencoder[\"nil\"] = function() return \"\\246\"; end\n\nfunction encoder.userdata(ud, opts)\n\tlocal mt = dbg_getmetatable(ud);\n\tif mt then\n\t\tlocal encode_ud = opts and opts[mt] or mt.__tocbor;\n\t\tif encode_ud then\n\t\t\treturn encode_ud(ud, opts);\n\t\tend\n\tend\n\terror \"can't encode userdata\";\nend\n\nfunction encoder.table(t, opts)\n\tlocal mt = getmetatable(t);\n\tif mt then\n\t\tlocal encode_t = opts and opts[mt] or mt.__tocbor;\n\t\tif encode_t then\n\t\t\treturn encode_t(t, opts);\n\t\tend\n\tend\n\t-- the table is encoded as an array iff when we iterate over it,\n\t-- we see successive integer keys starting from 1.  The lua\n\t-- language doesn't actually guarantee that this will be the case\n\t-- when we iterate over a table with successive integer keys, but\n\t-- due an implementation detail in PUC Rio Lua, this is what we\n\t-- usually observe.  See the Lua manual regarding the # (length)\n\t-- operator.  In the case that this does not happen, we will fall\n\t-- back to a map with integer keys, which becomes a bit larger.\n\tlocal array, map, i, p = { integer(#t, 128) }, { \"\\191\" }, 1, 2;\n\tlocal is_array = true;\n\tfor k, v in pairs(t) do\n\t\tis_array = is_array and i == k;\n\t\ti = i + 1;\n\n\t\tlocal encoded_v = encode(v, opts);\n\t\tarray[i] = encoded_v;\n\n\t\tmap[p], p = encode(k, opts), p + 1;\n\t\tmap[p], p = encoded_v, p + 1;\n\tend\n\t-- map[p] = \"\\255\";\n\tmap[1] = integer(i - 1, 160);\n\treturn t_concat(is_array and array or map);\nend\n\n-- Array or dict-only encoders, which can be set as __tocbor metamethod\nfunction encoder.array(t, opts)\n\tlocal array = { };\n\tfor i, v in ipairs(t) do\n\t\tarray[i] = encode(v, opts);\n\tend\n\treturn integer(#array, 128) .. t_concat(array);\nend\n\nfunction encoder.map(t, opts)\n\tlocal map, p, len = { \"\\191\" }, 2, 0;\n\tfor k, v in pairs(t) do\n\t\tmap[p], p = encode(k, opts), p + 1;\n\t\tmap[p], p = encode(v, opts), p + 1;\n\t\tlen = len + 1;\n\tend\n\t-- map[p] = \"\\255\";\n\tmap[1] = integer(len, 160);\n\treturn t_concat(map);\nend\nencoder.dict = encoder.map; -- COMPAT\n\nfunction encoder.ordered_map(t, opts)\n\tlocal map = {};\n\tif not t[1] then -- no predefined order\n\t\tlocal i = 0;\n\t\tfor k in pairs(t) do\n\t\t\ti = i + 1;\n\t\t\tmap[i] = k;\n\t\tend\n\t\tt_sort(map);\n\tend\n\tfor i, k in ipairs(t[1] and t or map) do\n\t\tmap[i] = encode(k, opts) .. encode(t[k], opts);\n\tend\n\treturn integer(#map, 160) .. t_concat(map);\nend\n\nencoder[\"function\"] = function ()\n\terror \"can't encode function\";\nend\n\n-- Decoder\n-- Reads from a file-handle like object\nlocal function read_bytes(fh, len)\n\treturn fh:read(len);\nend\n\nlocal function read_byte(fh)\n\treturn fh:read(1):byte();\nend\n\nlocal function read_length(fh, mintyp)\n\tif mintyp < 24 then\n\t\treturn mintyp;\n\telseif mintyp < 28 then\n\t\tlocal out = 0;\n\t\tfor _ = 1, 2 ^ (mintyp - 24) do\n\t\t\tout = out * 256 + read_byte(fh);\n\t\tend\n\t\treturn out;\n\telse\n\t\terror \"invalid length\";\n\tend\nend\n\nlocal decoder = {};\n\nlocal function read_type(fh)\n\tlocal byte = read_byte(fh);\n\treturn b_rshift(byte, 5), byte % 32;\nend\n\nlocal function read_object(fh, opts)\n\tlocal typ, mintyp = read_type(fh);\n\treturn decoder[typ](fh, mintyp, opts);\nend\n\nlocal function read_integer(fh, mintyp)\n\treturn read_length(fh, mintyp);\nend\n\nlocal function read_negative_integer(fh, mintyp)\n\treturn -1 - read_length(fh, mintyp);\nend\n\nlocal function read_string(fh, mintyp)\n\tif mintyp ~= 31 then\n\t\treturn read_bytes(fh, read_length(fh, mintyp));\n\tend\n\tlocal out = {};\n\tlocal i = 1;\n\tlocal v = read_object(fh);\n\twhile v ~= BREAK do\n\t\tout[i], i = v, i + 1;\n\t\tv = read_object(fh);\n\tend\n\treturn t_concat(out);\nend\n\nlocal function read_unicode_string(fh, mintyp)\n\treturn read_string(fh, mintyp);\n\t-- local str = read_string(fh, mintyp);\n\t-- if have_utf8 and not utf8.len(str) then\n\t\t-- TODO How to handle this?\n\t-- end\n\t-- return str;\nend\n\nlocal function read_array(fh, mintyp, opts)\n\tlocal out = {};\n\tif mintyp == 31 then\n\t\tlocal i = 1;\n\t\tlocal v = read_object(fh, opts);\n\t\twhile v ~= BREAK do\n\t\t\tout[i], i = v, i + 1;\n\t\t\tv = read_object(fh, opts);\n\t\tend\n\telse\n\t\tlocal len = read_length(fh, mintyp);\n\t\tfor i = 1, len do\n\t\t\tout[i] = read_object(fh, opts);\n\t\tend\n\tend\n\treturn out;\nend\n\nlocal function read_map(fh, mintyp, opts)\n\tlocal out = {};\n\tlocal k;\n\tif mintyp == 31 then\n\t\tlocal i = 1;\n\t\tk = read_object(fh, opts);\n\t\twhile k ~= BREAK do\n\t\t\tout[k], i = read_object(fh, opts), i + 1;\n\t\t\tk = read_object(fh, opts);\n\t\tend\n\telse\n\t\tlocal len = read_length(fh, mintyp);\n\t\tfor _ = 1, len do\n\t\t\tk = read_object(fh, opts);\n\t\t\tout[k] = read_object(fh, opts);\n\t\tend\n\tend\n\treturn out;\nend\n\nlocal tagged_decoders = {};\n\nlocal function read_semantic(fh, mintyp, opts)\n\tlocal tag = read_length(fh, mintyp);\n\tlocal value = read_object(fh, opts);\n\tlocal postproc = opts and opts[tag] or tagged_decoders[tag];\n\tif postproc then\n\t\treturn postproc(value);\n\tend\n\treturn tagged(tag, value);\nend\n\nlocal function read_half_float(fh)\n\tlocal exponent = read_byte(fh);\n\tlocal fraction = read_byte(fh);\n\tlocal sign = exponent < 128 and 1 or -1; -- sign is highest bit\n\n\tfraction = fraction + (exponent * 256) % 1024; -- copy two(?) bits from exponent to fraction\n\texponent = b_rshift(exponent, 2) % 32; -- remove sign bit and two low bits from fraction;\n\n\tif exponent == 0 then\n\t\treturn sign * m_ldexp(fraction, -24);\n\telseif exponent ~= 31 then\n\t\treturn sign * m_ldexp(fraction + 1024, exponent - 25);\n\telseif fraction == 0 then\n\t\treturn sign * m_huge;\n\telse\n\t\treturn NaN;\n\tend\nend\n\nlocal function read_float(fh)\n\tlocal exponent = read_byte(fh);\n\tlocal fraction = read_byte(fh);\n\tlocal sign = exponent < 128 and 1 or -1; -- sign is highest bit\n\texponent = exponent * 2 % 256 + b_rshift(fraction, 7);\n\tfraction = fraction % 128;\n\tfraction = fraction * 256 + read_byte(fh);\n\tfraction = fraction * 256 + read_byte(fh);\n\n\tif exponent == 0 then\n\t\treturn sign * m_ldexp(exponent, -149);\n\telseif exponent ~= 0xff then\n\t\treturn sign * m_ldexp(fraction + 2 ^ 23, exponent - 150);\n\telseif fraction == 0 then\n\t\treturn sign * m_huge;\n\telse\n\t\treturn NaN;\n\tend\nend\n\nlocal function read_double(fh)\n\tlocal exponent = read_byte(fh);\n\tlocal fraction = read_byte(fh);\n\tlocal sign = exponent < 128 and 1 or -1; -- sign is highest bit\n\n\texponent = exponent %  128 * 16 + b_rshift(fraction, 4);\n\tfraction = fraction % 16;\n\tfraction = fraction * 256 + read_byte(fh);\n\tfraction = fraction * 256 + read_byte(fh);\n\tfraction = fraction * 256 + read_byte(fh);\n\tfraction = fraction * 256 + read_byte(fh);\n\tfraction = fraction * 256 + read_byte(fh);\n\tfraction = fraction * 256 + read_byte(fh);\n\n\tif exponent == 0 then\n\t\treturn sign * m_ldexp(exponent, -149);\n\telseif exponent ~= 0xff then\n\t\treturn sign * m_ldexp(fraction + 2 ^ 52, exponent - 1075);\n\telseif fraction == 0 then\n\t\treturn sign * m_huge;\n\telse\n\t\treturn NaN;\n\tend\nend\n\n\nif s_unpack then\n\tfunction read_float(fh) return s_unpack(\">f\", read_bytes(fh, 4)) end\n\tfunction read_double(fh) return s_unpack(\">d\", read_bytes(fh, 8)) end\nend\n\nlocal function read_simple(fh, value, opts)\n\tif value == 24 then\n\t\tvalue = read_byte(fh);\n\tend\n\tif value == 20 then\n\t\treturn false;\n\telseif value == 21 then\n\t\treturn true;\n\telseif value == 22 then\n\t\treturn null;\n\telseif value == 23 then\n\t\treturn undefined;\n\telseif value == 25 then\n\t\treturn read_half_float(fh);\n\telseif value == 26 then\n\t\treturn read_float(fh);\n\telseif value == 27 then\n\t\treturn read_double(fh);\n\telseif value == 31 then\n\t\treturn BREAK;\n\tend\n\tif opts and opts.simple then\n\t\treturn opts.simple(value);\n\tend\n\treturn simple(value);\nend\n\ndecoder[0] = read_integer;\ndecoder[1] = read_negative_integer;\ndecoder[2] = read_string;\ndecoder[3] = read_unicode_string;\ndecoder[4] = read_array;\ndecoder[5] = read_map;\ndecoder[6] = read_semantic;\ndecoder[7] = read_simple;\n\n-- opts.more(n) -> want more data\n-- opts.simple -> decode simple value\n-- opts[int] -> tagged decoder\nlocal function decode(s, opts)\n\tlocal fh = {};\n\tlocal pos = 1;\n\n\tlocal more;\n\tif type(opts) == \"function\" then\n\t\tmore = opts;\n\telseif type(opts) == \"table\" then\n\t\tmore = opts.more;\n\telseif opts ~= nil then\n\t\terror((\"bad argument #2 to 'decode' (function or table expected, got %s)\"):format(type(opts)));\n\tend\n\tif type(more) ~= \"function\" then\n\t\tfunction more()\n\t\t\terror \"input too short\";\n\t\tend\n\tend\n\n\tfunction fh:read(bytes)\n\t\tlocal ret = s:sub(pos, pos + bytes - 1);\n\t\tif #ret < bytes then\n\t\t\tret = more(bytes - #ret, fh, opts);\n\t\t\tif ret then self:write(ret); end\n\t\t\treturn self:read(bytes);\n\t\tend\n\t\tpos = pos + bytes;\n\t\treturn ret;\n\tend\n\n\tfunction fh:write(bytes) -- luacheck: no self\n\t\ts = s .. bytes;\n\t\tif pos > 256 then\n\t\t\ts = s:sub(pos + 1);\n\t\t\tpos = 1;\n\t\tend\n\t\treturn #bytes;\n\tend\n\n\treturn read_object(fh, opts);\nend\n\nreturn {\n\t-- en-/decoder functions\n\tencode = encode;\n\tdecode = decode;\n\tdecode_file = read_object;\n\n\t-- tables of per-type en-/decoders\n\ttype_encoders = encoder;\n\ttype_decoders = decoder;\n\n\t-- special treatment for tagged values\n\ttagged_decoders = tagged_decoders;\n\n\t-- constructors for annotated types\n\tsimple = simple;\n\ttagged = tagged;\n\n\t-- pre-defined simple values\n\tnull = null;\n\tundefined = undefined;\n}\n", "sys/modules/opus/input.lua": "local Util = require('opus.util')\n\nlocal keyboard = _G.device and _G.device.keyboard\nlocal keys     = _G.keys\nlocal os       = _G.os\n\nlocal modifiers = Util.transpose {\n\tkeys.leftCtrl,  keys.rightCtrl,\n\tkeys.leftShift, keys.rightShift,\n\tkeys.leftAlt,   keys.rightAlt,\n}\n\nif not keyboard then -- not running under Opus OS\n\tkeyboard = { state = { } }\n\n\tlocal Event = require('opus.event')\n\tEvent.on({ 'key', 'key_up' }, function(event, code)\n\t\tif modifiers[code] then\n\t\t\tkeyboard.state[code] = event == 'key'\n\t\tend\n\tend)\nend\n\nlocal input = { }\n\nfunction input:modifierPressed()\n\treturn keyboard.state[keys.leftCtrl] or\n\t\t\t\t keyboard.state[keys.rightCtrl] or\n\t\t\t\t keyboard.state[keys.leftAlt] or\n\t\t\t\t keyboard.state[keys.rightAlt]\nend\n\nfunction input:toCode(ch, code)\n\tlocal result = { }\n\n\tif not ch and code == 1 then\n\t\tch = 'escape'\n\tend\n\n\tif keyboard.state[keys.leftCtrl] or keyboard.state[keys.rightCtrl] or\n\t\t code == keys.leftCtrl or code == keys.rightCtrl then\n\t\ttable.insert(result, 'control')\n\tend\n\n\t-- the key-up event for alt keys is not generated if the minecraft\n\t-- window loses focus\n\n\t if keyboard.state[keys.leftAlt] or keyboard.state[keys.rightAlt] or\n\t    code == keys.leftAlt or code == keys.rightAlt then\n\t   table.insert(result, 'alt')\n\tend\n\n\tif ch then -- some weird things happen with control/command on mac\n\t\tif keyboard.state[keys.leftShift] or keyboard.state[keys.rightShift] or\n\t\t\tcode == keys.leftShift or code == keys.rightShift then\n\t\t\tif code and modifiers[code] then\n\t\t\t\ttable.insert(result, 'shift')\n\t\t\telseif #ch == 1 then\n\t\t\t\ttable.insert(result, ch:upper())\n\t\t\telse\n\t\t\t\ttable.insert(result, 'shift')\n\t\t\t\ttable.insert(result, ch)\n\t\t\tend\n\t\telseif not code or not modifiers[code] then\n\t\t\ttable.insert(result, ch)\n\t\tend\n\tend\n\n\treturn table.concat(result, '-')\nend\n\nfunction input:reset()\n\tself.state = { }\n\n\tself.timer = nil\n\tself.mch = nil\n\tself.mfired = nil\nend\n\nlocal function isCombo()\n\t-- allow control-alt combinations for certain keyboards\n\treturn (keyboard.state[keys.leftAlt] or keyboard.state[keys.rightAlt]) and\n\t\t\t\t (keyboard.state[keys.leftCtrl] or keyboard.state[keys.rightCtrl])\nend\n\nfunction input:translate(event, code, p1, p2)\n\tif event == 'key' then\n\t\tif p1 then -- key is held down\n\t\t\tif not modifiers[code] then\n\t\t\t\tlocal ch = input:toCode(keys.getName(code), code)\n\t\t\t\tif #ch == 1 then\n\t\t\t\t\treturn {\n\t\t\t\t\t\tcode = 'char',\n\t\t\t\t\t\tch = ch,\n\t\t\t\t\t}\n\t\t\t\tend\n\t\t\t\treturn { code = ch }\n\t\t\tend\n\t\telseif code then\n\t\t\tlocal ch = input:toCode(keys.getName(code), code)\n\t\t\tif #ch ~= 1 then\n\t\t\t\treturn { code = ch }\n\t\t\tend\n\t\tend\n\n\telseif event == 'char' then\n\t\tlocal combo = isCombo()\n\t\tif combo or not (keyboard.state[keys.leftCtrl] or keyboard.state[keys.rightCtrl]) then\n\t\t\treturn { code = event, ch = code }\n\t\tend\n\n\telseif event == 'paste' then\n\t\tif keyboard.state[keys.leftShift] or keyboard.state[keys.rightShift] then\n\t\t\treturn { code = 'shift-paste', text = code }\n\t\telse\n\t\t\treturn { code = 'paste', text = code }\n\t\tend\n\n\telseif event == 'mouse_click' then\n\t\tlocal buttons = { 'mouse_click', 'mouse_rightclick' }\n\t\tself.mch = buttons[code]\n\t\tself.mfired = nil\n\t\tself.anchor = { x = p1, y = p2 }\n\t\treturn {\n\t\t\tcode = input:toCode('mouse_down', 255),\n\t\t\tbutton = code,\n\t\t\tx = p1,\n\t\t\ty = p2,\n\t\t}\n\n\telseif event == 'mouse_drag' then\n\t\tself.mfired = true\n\t\treturn {\n\t\t\tcode = input:toCode('mouse_drag', 255),\n\t\t\tbutton = code,\n\t\t\tx = p1,\n\t\t\ty = p2,\n\t\t\tdx = p1 - self.anchor.x,\n\t\t\tdy = p2 - self.anchor.y,\n\t\t}\n\n\telseif event == 'mouse_up' then\n\t\tif not self.mfired then\n\t\t\tlocal clock = os.clock()\n\t\t\tif self.timer and\n\t\t\t\t p1 == self.x and p2 == self.y and\n\t\t\t\t (clock - self.timer < .5) then\n\n\t\t\t\tself.clickCount = self.clickCount + 1\n\t\t\t\tif self.clickCount == 3 then\n\t\t\t\t\tself.mch = 'mouse_tripleclick'\n\t\t\t\t\tself.timer = nil\n\t\t\t\t\tself.clickCount = 1\n\t\t\t\telse\n\t\t\t\t\tself.mch = 'mouse_doubleclick'\n\t\t\t\tend\n\t\t\telse\n\t\t\t\tself.timer = os.clock()\n\t\t\t\tself.x = p1\n\t\t\t\tself.y = p2\n\t\t\t\tself.clickCount = 1\n\t\t\tend\n\t\t\tself.mfired = input:toCode(self.mch, 255)\n\t\telse\n\t\t\tself.mch = 'mouse_up'\n\t\t\tself.mfired = input:toCode(self.mch, 255)\n\t\tend\n\n\t\treturn {\n\t\t\tcode = self.mfired,\n\t\t\tbutton = code,\n\t\t\tx = p1,\n\t\t\ty = p2,\n\t\t}\n\n\telseif event == \"mouse_scroll\" then\n\t\tlocal directions = {\n\t\t\t[ -1 ] = 'scroll_up',\n\t\t\t[  1 ] = 'scroll_down'\n\t\t}\n\t\treturn {\n\t\t\tcode = input:toCode(directions[code], 255),\n\t\t\tx = p1,\n\t\t\ty = p2,\n\t\t}\n\n\telseif event == 'terminate' then\n\t\treturn { code = 'terminate' }\n\tend\nend\n\nif not ({ ...})[1] then\n\tlocal colors = _G.colors\n\tlocal term = _G.term\n\n\twhile true do\n\t\tlocal e = { os.pullEvent() }\n\t\tlocal ch = input:translate(table.unpack(e))\n\t\tif ch then\n\t\t\tterm.setTextColor(colors.white)\n\t\t\tprint(table.unpack(e))\n\t\t\tterm.setTextColor(colors.lime)\n\t\t\tlocal t = { }\n\t\t\tfor k,v in pairs(ch) do\n\t\t\t\ttable.insert(t, k .. ':' .. v)\n\t\t\tend\n\t\t\tprint('--> ' .. table.concat(t, ' ') .. '\\n')\n\t\tend\n\tend\nend\n\nreturn input\n", "sys/modules/opus/util.lua": "local Util = { }\n\nlocal fs        = _G.fs\nlocal http      = _G.http\nlocal os        = _G.os\nlocal term      = _G.term\nlocal textutils = _G.textutils\n\nlocal _sformat  = string.format\nlocal _srep     = string.rep\nlocal _ssub     = string.sub\nlocal _unpack   = table.unpack\nlocal _bor      = bit32.bor\nlocal _bxor     = bit32.bxor\n\n-- support multiple simultaneous gets for same url\nif not http.safeGet then -- really no good place to put this hack\n\tlocal reqs = { }\n\n\tlocal function wrapRequest(_url, ...)\n\t\tlocal ok, err = http.request(...)\n\t\tif ok then\n\t\t\twhile true do\n\t\t\t\tlocal event, param1, param2, param3 = os.pullEvent()\n\n\t\t\t\tif event == \"http_success\"\n\t\t\t\t\tand param1 == _url\n\t\t\t\t\tand not reqs[tostring(param2)] then\n\n\t\t\t\t\treqs[tostring(param2)] = true\n\t\t\t\t\treturn param2\n\n\t\t\t\telseif event == \"http_failure\" and param1 == _url then\n\t\t\t\t\treturn nil, param2, param3\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\t\treturn nil, err\n\tend\n\n\thttp.safeGet = function(_url, _headers, _binary)\n\t\treturn wrapRequest(_url, _url, nil, _headers, _binary)\n\tend\nend\n\nlocal byteArrayMT\nbyteArrayMT = {\n\t__tostring = function(a) return string.char(_unpack(a)) end,\n\t__index = {\n\t\ttoHex = function(self) return (\"%02x\"):rep(#self):format(_unpack(self)) end,\n\t\tisEqual = function(self, t)\n\t\t\tif type(t) ~= \"table\" then return false end\n\t\t\tif #self ~= #t then return false end\n\t\t\tlocal ret = 0\n\t\t\tfor i = 1, #self do\n\t\t\t\tret = _bor(ret, _bxor(self[i], t[i]))\n\t\t\tend\n\t\t\treturn ret == 0\n\t\tend,\n\t\tsub = function(self, a, b)\n\t\t\tlocal len = #self+1\n\t\t\tlocal start = a%len\n\t\t\tlocal stop = (b or len-1)%len\n\t\t\tlocal ret = {}\n\t\t\tlocal i = 1\n\t\t\tfor j = start, stop, start<stop and 1 or -1 do\n\t\t\t\tret[i] = self[j]\n\t\t\t\ti = i+1\n\t\t\tend\n\t\t\treturn setmetatable(ret, byteArrayMT)\n\t\tend\n\t}\n}\n\nUtil.byteArrayMT = byteArrayMT\n\nfunction Util.hexToByteArray(str)\n\tlocal r = {}\n\tstr = tostring(str)\n\tfor b in str:gmatch(\"%x%x?\") do\n\t\t\tr[#r+1] = tonumber(b, 16)\n\tend\n\treturn setmetatable(r, byteArrayMT)\nend\n\nfunction Util.byteArrayToHex(tbl)\n\tif not tbl then error('byteArrayToHex: invalid table', 2) end\n\treturn (\"%02x\"):rep(#tbl):format(_unpack(tbl))\nend\n\nfunction Util.tryTimed(timeout, f, ...)\n\tlocal c = os.clock()\n\trepeat\n\t\tlocal ret = f(...)\n\t\tif ret then\n\t\t\treturn ret\n\t\tend\n\tuntil os.clock()-c >= timeout\nend\n\nfunction Util.tryTimes(attempts, f, ...)\n\tlocal result\n\tfor _ = 1, attempts do\n\t\tresult = { f(...) }\n\t\tif result[1] then\n\t\t\treturn _unpack(result)\n\t\tend\n\tend\n\treturn _unpack(result)\nend\n\nfunction Util.timer()\n\tlocal ct = os.clock()\n\treturn function()\n\t\treturn os.clock() - ct\n\tend\nend\n\nUtil.Timer = Util.timer -- deprecate\n\nfunction Util.throttle(fn)\n\tlocal ts = os.clock()\n\tlocal timeout = .295\n\treturn function(...)\n\t\tlocal nts = os.clock()\n\t\tif nts > ts + timeout then\n\t\t\tos.sleep(0)\n\t\t\tts = os.clock()\n\t\t\tif fn then\n\t\t\t\tfn(...)\n\t\t\tend\n\t\tend\n\tend\nend\n\nfunction Util.tostring(pattern, ...)\n\n\tlocal function serialize(tbl, width)\n\t\tlocal str = '{\\n'\n\t\tfor k, v in pairs(tbl) do\n\t\t\tlocal value\n\t\t\tif type(v) == 'table' then\n\t\t\t\tvalue = _sformat('table: %d', Util.size(v))\n\t\t\telse\n\t\t\t\tvalue = tostring(v)\n\t\t\tend\n\t\t\tstr = str .. _sformat(' %s: %s\\n', k, value)\n\t\tend\n\t\t--if #str < width then\n\t\t\t--str = str:gsub('\\n', '') .. ' }'\n\t\t--else\n\t\t\tstr = str .. '}'\n\t\t--end\n\t\treturn str\n\tend\n\n\tif type(pattern) == 'string' then\n\t\tif select('#', ...) == 0 then\n\t\t\treturn pattern\n\t\tend\n\t\treturn _sformat(pattern, ...)\n\telseif type(pattern) == 'table' then\n\t\treturn serialize(pattern, term.current().getSize())\n\tend\n\treturn tostring(pattern)\nend\n\nfunction Util.print(pattern, ...)\n\tprint(Util.tostring(pattern, ...))\nend\n\nfunction Util.getVersion()\n\tlocal version\n\n\tif _G._CC_VERSION then\n\t\tversion = tonumber(_G._CC_VERSION:match('[%d]+%.?[%d][%d]'))\n\tend\n\tif not version and _G._HOST then\n\t\tversion = tonumber(_G._HOST:match('[%d]+%.?[%d][%d]'))\n\tend\n\n\treturn version or 1.7\nend\n\nfunction Util.getMinecraftVersion()\n\tlocal mcVersion = _G._MC_VERSION or 'unknown'\n\tif _G._HOST then\n\t\tlocal version = _G._HOST:match('%S+ %S+ %((%S.+)%)')\n\t\tif version then\n\t\t\tmcVersion = version:match('Minecraft (%S+)') or version\n\t\tend\n\tend\n\treturn mcVersion\nend\n\nfunction Util.checkMinecraftVersion(minVersion)\n\tlocal version = Util.getMinecraftVersion()\n\tlocal function convert(v)\n\t\tlocal m1, m2, m3 = v:match('(%d)%.(%d)%.?(%d?)')\n\t\treturn tonumber(m1) * 10000 + tonumber(m2) * 100 + (tonumber(m3) or 0)\n\tend\n\n\treturn convert(version) >= convert(tostring(minVersion))\nend\n\nfunction Util.signum(num)\n\tif num > 0 then\n\t\treturn 1\n\telseif num < 0 then\n\t\treturn -1\n\telse\n\t\treturn 0\n\tend\nend\n\nfunction Util.clamp(num, low, high)\n\treturn num < low and low or num > high and high or num\nend\n\n-- http://lua-users.org/wiki/SimpleRound\nfunction Util.round(num, idp)\n\tlocal mult = 10^(idp or 0)\n\treturn Util.signum(num) * math.floor(math.abs(num) * mult + 0.5) / mult\nend\n\nfunction Util.randomFloat(max, min)\n\tmin = min or 0\n\tmax = max or 1\n\treturn (max-min) * math.random() + min\nend\n\n--[[ Table functions ]] --\nfunction Util.clear(t)\n\tlocal keys = Util.keys(t)\n\tfor _,k in pairs(keys) do\n\t\tt[k] = nil\n\tend\nend\n\nfunction Util.empty(t)\n\treturn not next(t)\nend\n\nfunction Util.key(t, value)\n\tfor k,v in pairs(t) do\n\t\tif v == value then\n\t\t\treturn k\n\t\tend\n\tend\nend\n\nfunction Util.keys(t)\n\tlocal keys = { }\n\tfor k in pairs(t) do\n\t\tkeys[#keys+1] = k\n\tend\n\treturn keys\nend\n\nfunction Util.merge(obj, args)\n\tif args then\n\t\tfor k,v in pairs(args) do\n\t\t\tobj[k] = v\n\t\tend\n\tend\n\treturn obj\nend\n\nfunction Util.deepMerge(obj, args)\n\tif args then\n\t\tfor k,v in pairs(args) do\n\t\t\tif type(v) == 'table' then\n\t\t\t\tif not obj[k] then\n\t\t\t\t\tobj[k] = { }\n\t\t\t\tend\n\t\t\t\tUtil.deepMerge(obj[k], v)\n\t\t\telse\n\t\t\t\tobj[k] = v\n\t\t\tend\n\t\tend\n\tend\nend\n\nfunction Util.transpose(t)\n\tlocal tt = { }\n\tfor k,v in pairs(t) do\n\t\ttt[v] = k\n\tend\n\treturn tt\nend\n\nfunction Util.contains(t, value)\n\tfor k,v in pairs(t) do\n\t\tif v == value then\n\t\t\treturn k\n\t\tend\n\tend\nend\n\nfunction Util.find(t, name, value)\n\tfor k,v in pairs(t) do\n\t\tif v[name] == value then\n\t\t\treturn v, k\n\t\tend\n\tend\nend\n\nfunction Util.findAll(t, name, value)\n\tlocal rt = { }\n\tfor _,v in pairs(t) do\n\t\tif v[name] == value then\n\t\t\ttable.insert(rt, v)\n\t\tend\n\tend\n\treturn rt\nend\n\nfunction Util.shallowCopy(t)\n\tif not t then error('Util.shallowCopy: invalid table', 2) end\n\tlocal t2 = { }\n\tfor k,v in pairs(t) do\n\t\tt2[k] = v\n\tend\n\treturn t2\nend\n\nfunction Util.deepCopy(t)\n\tif type(t) ~= 'table' then\n\t\treturn t\n\tend\n\t--local mt = getmetatable(t)\n\tlocal res = {}\n\tfor k,v in pairs(t) do\n\t\tif type(v) == 'table' then\n\t\t\tv = Util.deepCopy(v)\n\t\tend\n\t\tres[k] = v\n\tend\n\t--setmetatable(res,mt)\n\treturn res\nend\n\n-- http://snippets.luacode.org/?p=snippets/Filter_a_table_in-place_119\nfunction Util.filterInplace(t, predicate)\n\tlocal j = 1\n\n\tfor i = 1,#t do\n\t\tlocal v = t[i]\n\t\tif predicate(v) then\n\t\t\tt[j] = v\n\t\t\tj = j + 1\n\t\tend\n\tend\n\n\twhile t[j] ~= nil do\n\t\tt[j] = nil\n\t\tj = j + 1\n\tend\n\n\treturn t\nend\n\nfunction Util.filter(it, f)\n\tlocal ot = { }\n\tfor k,v in pairs(it) do\n\t\tif f(v) then\n\t\t\tot[k] = v\n\t\tend\n\tend\n\treturn ot\nend\n\nfunction Util.reduce(t, fn, acc)\n\tacc = acc or 0\n\tfor _, v in pairs(t) do\n\t\tacc = fn(acc, v)\n\tend\n\treturn acc\nend\n\nfunction Util.size(list)\n\tif type(list) == 'table' then\n\t\tlocal length = 0\n\t\tfor _ in pairs(list) do\n\t\t\tlength = length + 1\n\t\tend\n\t\treturn length\n\tend\n\treturn 0\nend\n\nlocal function isArray(value)\n\t-- dubious\n\treturn type(value) == \"table\" and (value[1] or next(value) == nil)\nend\n\nfunction Util.removeByValue(t, e)\n\tfor k,v in pairs(t) do\n\t\tif v == e then\n\t\t\tif isArray(t) then\n\t\t\t\ttable.remove(t, k)\n\t\t\telse\n\t\t\t\tt[k] = nil\n\t\t\tend\n\t\t\tbreak\n\t\tend\n\tend\nend\n\nfunction Util.any(t, fn)\n\tfor _,v in pairs(t) do\n\t\tif fn(v) then\n\t\t\treturn true\n\t\tend\n\tend\nend\n\nfunction Util.every(t, fn)\n\tfor _,v in pairs(t) do\n\t\tif not fn(v) then\n\t\t\treturn false\n\t\tend\n\tend\n\treturn true\nend\n\nfunction Util.each(list, func)\n\tfor index, value in pairs(list) do\n\t\tfunc(value, index, list)\n\tend\nend\n\nfunction Util.rpairs(t)\n\tlocal tkeys = Util.keys(t)\n\tlocal i = #tkeys\n\treturn function()\n\t\tlocal key = tkeys[i]\n\t\tlocal k,v = key, t[key]\n\t\ti = i - 1\n\t\tif v then\n\t\t\treturn k, v\n\t\tend\n\tend\nend\n\n-- http://stackoverflow.com/questions/15706270/sort-a-table-in-lua\nfunction Util.spairs(t, order)\n\tlocal keys = Util.keys(t)\n\n\t-- if order function given, sort by it by passing the table and keys a, b,\n\t-- otherwise just sort the keys\n\tif order then\n\t\ttable.sort(keys, function(a,b) return order(t[a], t[b]) end)\n\telse\n\t\ttable.sort(keys)\n\tend\n\n\t-- return the iterator function\n\tlocal i = 0\n\treturn function()\n\t\ti = i + 1\n\t\tif keys[i] then\n\t\t\treturn keys[i], t[keys[i]]\n\t\tend\n\tend\nend\n\nfunction Util.first(t, order)\n\tlocal keys = Util.keys(t)\n\tif order then\n\t\ttable.sort(keys, function(a,b) return order(t[a], t[b]) end)\n\telse\n\t\ttable.sort(keys)\n\tend\n\treturn keys[1], t[keys[1]]\nend\n\n--[[ File functions ]]--\nfunction Util.readFile(fname, flags)\n\tlocal f = fs.open(fname, flags or \"r\")\n\tif f then\n\t\tlocal t = f.readAll()\n\t\tf.close()\n\t\treturn t\n\tend\nend\n\nfunction Util.backup(fname)\n\tlocal backup = fname .. '.bak'\n\tif backup then\n\t\tfs.delete(backup)\n\tend\n\tfs.copy(fname, backup)\nend\n\nfunction Util.writeFile(fname, data, flags)\n\tif not fname or not data then error('Util.writeFile: invalid parameters', 2) end\n\n\tif fs.exists(fname) then\n\t\tlocal diff = #data - fs.getSize(fname)\n\t\tif diff > 0 then\n\t\t\tif fs.getFreeSpace(fs.getDir(fname)) < diff then\n\t\t\t\terror('Insufficient disk space for ' .. fname)\n\t\t\tend\n\t\tend\n\tend\n\n\tlocal file = io.open(fname, flags or \"w\")\n\tif not file then\n\t\terror('Unable to open ' .. fname, 2)\n\tend\n\tfile:write(data)\n\tfile:close()\nend\n\nfunction Util.readLines(fname)\n\tlocal file = fs.open(fname, \"r\")\n\tif file then\n\t\tlocal t = {}\n\t\tlocal line = file.readLine()\n\t\twhile line do\n\t\t\ttable.insert(t, line)\n\t\t\tline = file.readLine()\n\t\tend\n\t\tfile.close()\n\t\treturn t\n\tend\nend\n\nfunction Util.writeLines(fname, lines)\n\tlocal file = fs.open(fname, 'w')\n\tif file then\n\t\tfor _,line in ipairs(lines) do\n\t\t\tfile.writeLine(line)\n\t\tend\n\t\tfile.close()\n\t\treturn true\n\tend\nend\n\nfunction Util.readTable(fname)\n\tlocal t = Util.readFile(fname)\n\tif t then\n\t\treturn textutils.unserialize(t)\n\tend\nend\n\nfunction Util.writeTable(fname, data)\n\tUtil.writeFile(fname, textutils.serialize(data))\nend\n\nfunction Util.loadTable(fname)\n\tlocal fc = Util.readFile(fname)\n\tif not fc then\n\t\treturn false, 'Unable to read file'\n\tend\n\tlocal s, m = loadstring('return ' .. fc, fname)\n\tif s then\n\t\ts, m = pcall(s)\n\t\tif s then\n\t\t\treturn m\n\t\tend\n\tend\n\treturn s, m\nend\n\n--[[ loading and running functions ]] --\nfunction Util.httpGet(url, headers, isBinary)\n\tlocal h, msg = http.safeGet(url, headers, isBinary)\n\tif h then\n\t\tlocal contents = h.readAll()\n\t\th.close()\n\t\treturn contents\n\tend\n\treturn h, msg\nend\n\nfunction Util.download(url, filename)\n\tlocal contents, msg = Util.httpGet(url)\n\tif not contents then\n\t\terror(_sformat('Failed to download %s\\n%s', url, msg), 2)\n\tend\n\n\tif filename then\n\t\tUtil.writeFile(filename, contents)\n\tend\n\treturn contents\nend\n\nfunction Util.loadUrl(url, env)  -- loadfile equivalent\n\tlocal c, msg = Util.httpGet(url)\n\tif not c then\n\t\treturn c, msg\n\tend\n\treturn load(c, url, nil, env)\nend\n\nfunction Util.runUrl(env, url, ...)   -- os.run equivalent\n\tlocal fn, m = Util.loadUrl(url, env)\n\tif fn then\n\t\treturn pcall(fn, ...)\n\tend\n\treturn fn, m\nend\n\nfunction Util.run(env, path, ...)\n\tif type(env) ~= 'table' then error('Util.run: env must be a table', 2) end\n\tlocal fn, m = loadfile(path, env)\n\tif fn then\n\t\treturn pcall(fn, ...)\n\tend\n\treturn fn, m\nend\n\nfunction Util.runFunction(env, fn, ...)\n\tsetfenv(fn, env)\n\treturn pcall(fn, ...)\nend\n\n--[[ String functions ]] --\nfunction Util.toBytes(n)\n\tif not tonumber(n) then error('Util.toBytes: n must be a number', 2) end\n\tif n >= 1000000 or n <= -1000000 then\n\t\treturn _sformat('%sM', math.floor(n/1000000 * 10) / 10)\n\telseif n >= 10000 or n <= -10000 then\n\t\treturn _sformat('%sK', math.floor(n/1000))\n\telseif n >= 1000 or n <= -1000 then\n\t\treturn _sformat('%sK', math.floor(n/1000 * 10) / 10)\n\tend\n\treturn tostring(n)\nend\n\nfunction Util.insertString(str, istr, pos)\n\treturn str:sub(1, pos - 1) .. istr .. str:sub(pos)\nend\n\nfunction Util.split(str, pattern)\n\tif not str or type(str) ~= 'string' then error('Util.split: Invalid parameters', 2) end\n\tpattern = pattern or \"(.-)\\n\"\n\tlocal t = {}\n\tlocal function helper(line) table.insert(t, line) return \"\" end\n\thelper((str:gsub(pattern, helper)))\n\treturn t\nend\n\nfunction Util.matches(str, pattern)\n\tpattern = pattern or '%S+'\n\tlocal t = { }\n\tfor s in str:gmatch(pattern) do\n\t\t table.insert(t, s)\n\tend\n\treturn t\nend\n\nfunction Util.startsWith(s, match)\n\treturn _ssub(s, 1, #match) == match\nend\n\n-- return a fixed length string using specified alignment\nfunction Util.widthify(s, len, align)\n\ts = s or ''\n\tlocal slen = #s\n\n\tif slen > len then\n\t\treturn _ssub(s, 1, len)\n\n\telseif slen == len then\n\t\treturn s\n\n\telseif align == 'center' then\n\t\tlocal space = math.floor((len - slen) / 2)\n\t\ts = _srep(' ', space) .. s\n\t\treturn s .. _srep(' ', len - #s)\n\n\telseif align == 'right' then\n\t\treturn _srep(' ', len - slen) .. s\n\n\tend\n\n\treturn s .. _srep(' ', len - slen)\nend\n\n-- http://snippets.luacode.org/?p=snippets/trim_whitespace_from_string_76\nfunction Util.trim(s)\n\treturn s:find('^%s*$') and '' or s:match('^%s*(.*%S)')\nend\n\n-- trim whitespace from left end of string\nfunction Util.triml(s)\n\treturn s:match('^%s*(.*)')\nend\n\n-- trim whitespace from right end of string\nfunction Util.trimr(s)\n\treturn s:find('^%s*$') and '' or s:match('^(.*%S)')\nend\n-- end http://snippets.luacode.org/?p=snippets/trim_whitespace_from_string_76\n\nlocal function wrap(text, max, lines)\n\tlocal index = 1\n\trepeat\n\t\tif #text <= max then\n\t\t\ttable.insert(lines, text)\n\t\t\ttext = ''\n\t\telseif text:sub(max+1, max+1) == ' ' then\n\t\t\ttable.insert(lines, text:sub(index, max))\n\t\t\ttext = text:sub(max + 2)\n\t\telse\n\t\t\tlocal x = text:sub(1, max)\n\t\t\tlocal s = x:match('(.*) ') or x\n\t\t\ttext = text:sub(#s + 1)\n\t\t\ttable.insert(lines, s)\n\t\tend\n\t\ttext = text:match('^%s*(.*)')\n\tuntil not text or #text == 0\n\treturn lines\nend\n\nfunction Util.wordWrap(str, limit)\n\tlocal lines = { }\n\n\tfor _,line in ipairs(Util.split(str)) do\n\t\twrap(line, limit, lines)\n\tend\n\n\treturn lines\nend\n\n-- https://github.com/MightyPirates/OpenComputers\nfunction Util.parse(...)\n\tlocal params = table.pack(...)\n\tlocal args = {}\n\tlocal options = {}\n\tlocal doneWithOptions = false\n\tfor i = 1, params.n do\n\t\tlocal param = params[i]\n\t\tif not doneWithOptions and type(param) == \"string\" then\n\t\t\tif param == \"--\" then\n\t\t\t\tdoneWithOptions = true -- stop processing options at `--`\n\t\t\telseif param:sub(1, 2) == \"--\" then\n\t\t\t\tlocal key, value = param:match(\"%-%-(.-)=(.*)\")\n\t\t\t\tif not key then\n\t\t\t\t\tkey, value = param:sub(3), true\n\t\t\t\tend\n\t\t\t\toptions[key] = value\n\t\t\telseif param:sub(1, 1) == \"-\" and param ~= \"-\" then\n\t\t\t\tfor j = 2, string.len(param) do\n\t\t\t\t\toptions[string.sub(param, j, j)] = true\n\t\t\t\tend\n\t\t\telse\n\t\t\t\ttable.insert(args, param)\n\t\t\tend\n\t\telse\n\t\t\ttable.insert(args, param)\n\t\tend\n\tend\n\treturn args, options\nend\n\n-- http://lua-users.org/wiki/AlternativeGetOpt\nlocal function getopt( arg, options )\n\tlocal tab = {}\n\tfor k, v in ipairs(arg) do\n\t\tif type(v) == 'string' then\n\t\t\tif _ssub( v, 1, 2) == \"--\" then\n\t\t\t\tlocal x = string.find( v, \"=\", 1, true )\n\t\t\t\tif x then tab[ _ssub( v, 3, x-1 ) ] = _ssub( v, x+1 )\n\t\t\t\telse      tab[ _ssub( v, 3 ) ] = true\n\t\t\t\tend\n\t\t\telseif _ssub( v, 1, 1 ) == \"-\" then\n\t\t\t\tlocal y = 2\n\t\t\t\tlocal l = string.len(v)\n\t\t\t\tlocal jopt\n\t\t\t\twhile ( y <= l ) do\n\t\t\t\t\tjopt = _ssub( v, y, y )\n\t\t\t\t\tif string.find( options, jopt, 1, true ) then\n\t\t\t\t\t\tif y < l then\n\t\t\t\t\t\t\ttab[ jopt ] = _ssub( v, y+1 )\n\t\t\t\t\t\t\ty = l\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\ttab[ jopt ] = arg[ k + 1 ]\n\t\t\t\t\t\tend\n\t\t\t\t\telse\n\t\t\t\t\t\ttab[ jopt ] = true\n\t\t\t\t\tend\n\t\t\t\t\ty = y + 1\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\treturn tab\nend\n\nfunction Util.showOptions(options)\n\tprint('Arguments: ')\n\tfor _, v in pairs(options) do\n\t\tprint(_sformat('-%s  %s', v.arg, v.desc))\n\tend\nend\n\nfunction Util.getOptions(options, args, ignoreInvalid)\n\tlocal argLetters = ''\n\tfor _,o in pairs(options) do\n\t\tif o.type ~= 'flag' then\n\t\t\targLetters = argLetters .. o.arg\n\t\tend\n\tend\n\tlocal rawOptions = getopt(args, argLetters)\n\n\tfor k,ro in pairs(rawOptions) do\n\t\tlocal found = false\n\t\tfor _,o in pairs(options) do\n\t\t\tif o.arg == k then\n\t\t\t\tfound = true\n\t\t\t\tif o.type == 'number' then\n\t\t\t\t\to.value = tonumber(ro)\n\t\t\t\telseif o.type == 'help' then\n\t\t\t\t\tUtil.showOptions(options)\n\t\t\t\t\treturn false\n\t\t\t\telse\n\t\t\t\t\to.value = ro\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\t\tif not found and not ignoreInvalid then\n\t\t\tprint('Invalid argument')\n\t\t\tUtil.showOptions(options)\n\t\t\treturn false\n\t\tend\n\tend\n\treturn true, Util.size(rawOptions)\nend\n\n-- https://www.lua.org/pil/9.3.html\nfunction Util.permutation(tbl)\n\tlocal function permgen(a, n)\n\t\tif n == 0 then\n\t\t\tcoroutine.yield(a)\n\t\telse\n\t\t\tfor i=1,n do\n\t\t\t\ta[n], a[i] = a[i], a[n]\n\t\t\t\tpermgen(a, n - 1)\n\t\t\t\ta[n], a[i] = a[i], a[n]\n\t\t\tend\n\t\tend\n\tend\n\n\tlocal co = coroutine.create(function() permgen(tbl, #tbl) end)\n\treturn function()\n\t\tlocal _, res = coroutine.resume(co)\n\t\treturn res\n\tend\nend\n\nreturn Util\n", "sys/modules/opus/ui.lua": "local Array      = require('opus.array')\nlocal Blit       = require('opus.ui.blit')\nlocal Canvas     = require('opus.ui.canvas')\nlocal class      = require('opus.class')\nlocal Event      = require('opus.event')\nlocal Input      = require('opus.input')\nlocal Transition = require('opus.ui.transition')\nlocal Util       = require('opus.util')\n\nlocal _rep       = string.rep\nlocal colors     = _G.colors\nlocal device     = _G.device\nlocal fs         = _G.fs\nlocal os         = _G.os\nlocal term       = _G.term\nlocal textutils  = _G.textutils\n\n--[[\n\tUsing the shorthand window definition, elements are created from\n\tthe bottom up. Once reaching the top, setParent is called top down.\n\n\tOn :init(), elements do not know the parent or can calculate sizing.\n\n\tCalling order:\n\twindow:postInit()\n\t\tat this point, the window has all default values set\n\twindow:setParent()\n\t\tparent has been assigned\n\t\tfollowing are called:\n\t\twindow:layout()\n\t\t\tsizing / positioning is performed\n\t\twindow:initChildren()\n\t\t\teach child of window will get initialized\n]]\n\n--[[-- Top Level Manager --]]--\nlocal UI = { }\nfunction UI:init()\n\tself.devices = { }\n\tself.theme = {\n\t\tcolors = {\n\t\t\tprimary = colors.green,\n\t\t\tsecondary = colors.lightGray,\n\t\t\ttertiary = colors.gray,\n\t\t}\n\t}\n\tself.extChars = Util.getVersion() >= 1.76\n\n\tlocal function keyFunction(event, code, held)\n\t\tlocal ie = Input:translate(event, code, held)\n\n\t\tlocal currentPage = self:getActivePage()\n\t\tif ie and currentPage then\n\t\t\tlocal target = currentPage.focused or currentPage\n\t\t\ttarget:emit({ type = 'key', key = ie.code == 'char' and ie.ch or ie.code, element = target, ie = ie })\n\t\t\tcurrentPage:sync()\n\t\tend\n\tend\n\n\tlocal function resize(_, side)\n\t\tlocal dev = self.devices[side or 'terminal']\n\t\tif dev and dev.currentPage then\n\t\t\tdev:resize()\n\n\t\t\tdev.currentPage:resize()\n\t\t\tdev.currentPage:draw()\n\t\t\tdev.currentPage:sync()\n\t\tend\n\tend\n\n\tlocal handlers = {\n\t\tchar = keyFunction,\n\t\tkey_up = keyFunction,\n\t\tkey = keyFunction,\n\t\tterm_resize = resize,\n\t\tmonitor_resize = resize,\n\n\t\tmouse_scroll = function(_, direction, x, y, side)\n\t\t\tlocal ie = Input:translate('mouse_scroll', direction, x, y)\n\n\t\t\tlocal currentPage = self:getActivePage()\n\t\t\tif currentPage and currentPage.parent.device.side == side then\n\t\t\t\tlocal event = currentPage:pointToChild(x, y)\n\t\t\t\tevent.type = ie.code\n\t\t\t\tevent.ie = { code = ie.code, x = event.x, y = event.y }\n\t\t\t\tevent.element:emit(event)\n\t\t\t\tcurrentPage:sync()\n\t\t\tend\n\t\tend,\n\n\t\tmonitor_touch = function(_, side, x, y)\n\t\t\tlocal dev = self.devices[side]\n\t\t\tif dev and dev.currentPage then\n\t\t\t\tInput:translate('mouse_click', 1, x, y)\n\t\t\t\tlocal ie = Input:translate('mouse_up', 1, x, y)\n\t\t\t\tself:click(dev.currentPage, ie)\n\t\t\tend\n\t\tend,\n\n\t\tmouse_click = function(_, button, x, y, side)\n\t\t\tlocal ie = Input:translate('mouse_click', button, x, y)\n\n\t\t\tlocal currentPage = self:getActivePage()\n\t\t\tif currentPage and currentPage.parent.device.side == side then\n\t\t\t\tlocal event = currentPage:pointToChild(x, y)\n\t\t\t\tif event.element.focus and not event.element.inactive then\n\t\t\t\t\tcurrentPage:setFocus(event.element)\n\t\t\t\t\tcurrentPage:sync()\n\t\t\t\tend\n\t\t\t\tself:click(currentPage, ie)\n\t\t\tend\n\t\tend,\n\n\t\tmouse_up = function(_, button, x, y, side)\n\t\t\tlocal ie = Input:translate('mouse_up', button, x, y)\n\t\t\tlocal currentPage = self:getActivePage()\n\n\t\t\tif ie.code == 'control-shift-mouse_click' then -- hack\n\t\t\t\tlocal event = currentPage:pointToChild(x, y)\n\t\t\t\t_ENV.multishell.openTab(_ENV, {\n\t\t\t\t\tpath = 'sys/apps/Lua.lua',\n\t\t\t\t\targs = { event.element, self, _ENV },\n\t\t\t\t\tfocused = true })\n\n\t\t\telseif ie and currentPage and currentPage.parent.device.side == side then\n\t\t\t\tself:click(currentPage, ie)\n\t\t\tend\n\t\tend,\n\n\t\tmouse_drag = function(_, button, x, y, side)\n\t\t\tlocal ie = Input:translate('mouse_drag', button, x, y)\n\t\t\tlocal currentPage = self:getActivePage()\n\n\t\t\tif ie and currentPage and currentPage.parent.device.side == side then\n\t\t\t\tself:click(currentPage, ie)\n\t\t\tend\n\t\tend,\n\n\t\tpaste = function(_, text)\n\t\t\tlocal ie = Input:translate('paste', text)\n\t\t\tself:emitEvent({ type = 'paste', text = text, ie = ie })\n\t\t\tself:getActivePage():sync()\n\t\tend,\n\t}\n\n\t-- use 1 handler to single thread all events\n\tEvent.on({\n\t\t'char', 'key_up', 'key', 'term_resize', 'monitor_resize',\n\t\t'mouse_scroll', 'monitor_touch', 'mouse_click',\n\t\t'mouse_up', 'mouse_drag', 'paste' },\n\t\tfunction(event, ...)\n\t\t\thandlers[event](event, ...)\n\t\tend)\nend\n\nfunction UI:configure(appName, ...)\n\tlocal defaults = Util.loadTable('usr/config/' .. appName) or { }\n\tif not defaults.device then\n\t\tdefaults.device = { }\n\tend\n\n\t-- starting a program: gpsServer --display=monitor_3148 --scale=.5 gps\n\tlocal _, options = Util.parse(...)\n\tlocal optionValues = {\n\t\tname = options.display,\n\t\ttextScale = tonumber(options.scale),\n\t}\n\n\tUtil.merge(defaults.device, optionValues)\n\n\tif defaults.device.name then\n\t\tlocal dev\n\n\t\tif defaults.device.name == 'terminal' then\n\t\t\tdev = term.current()\n\t\telse\n\t\t\tdev = device[defaults.device.name]\n\t\tend\n\n\t\tif not dev then\n\t\t\terror('Invalid display device')\n\t\tend\n\t\tself:setDefaultDevice(self.Device({\n\t\t\tdevice = dev,\n\t\t\ttextScale = defaults.device.textScale,\n\t\t}))\n\tend\n\n\tif defaults.theme then\n\t\tUtil.deepMerge(self.theme, defaults.theme)\n\tend\nend\n\nfunction UI:disableEffects()\n\tself.term.effectsEnabled = false\nend\n\nfunction UI:loadTheme(filename)\n\tif fs.exists(filename) then\n\t\tlocal theme, err = Util.loadTable(filename)\n\t\tif not theme then\n\t\t\terror(err)\n\t\tend\n\t\tUtil.deepMerge(self.theme, theme)\n\tend\n\tfor k,v in pairs(self.theme.colors) do\n\t\tCanvas.colorPalette[k] = Canvas.colorPalette[v]\n\t\tCanvas.grayscalePalette[k] = Canvas.grayscalePalette[v]\n\tend\nend\n\nfunction UI:generateTheme(filename)\n\tlocal t = { }\n\n\tlocal function getName(d)\n\t\tif type(d) == 'string' then\n\t\t\treturn string.format(\"'%s'\", d)\n\t\tend\n\t\tfor c, n in pairs(colors) do\n\t\t\tif n == d then\n\t\t\t\treturn 'colors.' .. c\n\t\t\tend\n\t\tend\n\tend\n\n\tfor k,v in pairs(self) do\n\t\tif type(v) == 'table' then\n\t\t\tif v._preload then\n\t\t\t\tv._preload()\n\t\t\t\tv = self[k]\n\t\t\tend\n\t\t\tif v.defaults and v.defaults.UIElement ~= 'Device' then\n\t\t\t\tfor p,d in pairs(v.defaults) do\n\t\t\t\t\tif p:find('olor') then\n\t\t\t\t\t\tif not t[k] then\n\t\t\t\t\t\t\tt[k] = { }\n\t\t\t\t\t\tend\n\t\t\t\t\t\tt[k][p] = getName(d)\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\tt.colors = {\n\t\tprimary = getName(self.colors.primary),\n\t\tsecondary = getName(self.colors.secondary),\n\t\ttertiary = getName(self.colors.tertiary),\n\t}\n\tUtil.writeFile(filename, textutils.serialize(t):gsub('(\")', ''))\nend\n\nfunction UI:emitEvent(event)\n\tlocal currentPage = self:getActivePage()\n\tif currentPage and currentPage.focused then\n\t\treturn currentPage.focused:emit(event)\n\tend\nend\n\nfunction UI:click(target, ie)\n\tlocal clickEvent\n\n\tif ie.code == 'mouse_drag' then\n\t\tlocal function getPosition(element, x, y)\n\t\t\trepeat\n\t\t\t\tx = x - element.x + 1\n\t\t\t\ty = y - element.y + 1\n\t\t\t\telement = element.parent\n\t\t\tuntil not element\n\t\t\treturn x, y\n\t\tend\n\n\t\tlocal x, y = getPosition(self.lastClicked, ie.x, ie.y)\n\n\t\tclickEvent = {\n\t\t\telement = self.lastClicked,\n\t\t\tx = x,\n\t\t\ty = y,\n\t\t\tdx = ie.dx,\n\t\t\tdy = ie.dy,\n\t\t}\n\telse\n\t\tclickEvent = target:pointToChild(ie.x, ie.y)\n\tend\n\n\t-- hack for dropdown menus\n\tif ie.code == 'mouse_click' and not clickEvent.element.focus then\n\t\tself:emitEvent({ type = 'mouse_out' })\n\tend\n\n\tif ie.code == 'mouse_doubleclick' then\n\t\tif self.lastClicked ~= clickEvent.element then\n\t\t\treturn\n\t\tend\n\telse\n\t\tself.lastClicked = clickEvent.element\n\tend\n\n\tclickEvent.button = ie.button\n\tclickEvent.type = ie.code\n\tclickEvent.key = ie.code\n\tclickEvent.ie = { code = ie.code, x = clickEvent.x, y = clickEvent.y }\n\tclickEvent.raw = ie\n\n\tif clickEvent.element.focus then\n\t\ttarget:setFocus(clickEvent.element)\n\tend\n\tclickEvent.element:emit(clickEvent)\n\n\ttarget:sync()\nend\n\nfunction UI:setDefaultDevice(dev)\n\tself.term = dev\nend\n\nfunction UI:addPage(name, page)\n\tif not self.pages then\n\t\tself.pages = { }\n\tend\n\tself.pages[name] = page\nend\n\nfunction UI:setPages(pages)\n\tself.pages = pages\nend\n\nfunction UI:getPage(pageName)\n\tlocal page = self.pages[pageName]\n\n\tif not page then\n\t\terror('UI:getPage: Invalid page: ' .. tostring(pageName), 2)\n\tend\n\n\treturn page\nend\n\nfunction UI:getActivePage(page)\n\tif page then\n\t\treturn page.parent.currentPage\n\tend\n\treturn self.term.currentPage\nend\n\nfunction UI:setActivePage(page)\n\tpage.parent.currentPage = page\nend\n\nfunction UI:setPage(pageOrName, ...)\n\tlocal page = pageOrName\n\n\tif type(pageOrName) == 'string' then\n\t\tpage = self.pages[pageOrName] or error('Invalid page: ' .. pageOrName)\n\tend\n\n\tlocal currentPage = self:getActivePage(page)\n\tif page == currentPage then\n\t\tpage:draw()\n\telse\n\t\tif currentPage then\n\t\t\tif currentPage.focused then\n\t\t\t\tcurrentPage.focused.focused = false\n\t\t\t\tcurrentPage.focused:focus()\n\t\t\tend\n\t\t\tcurrentPage:disable()\n\t\t\tpage.previousPage = currentPage\n\t\tend\n\t\tself:setActivePage(page)\n\t\tpage:enable(...)\n\t\tpage:draw()\n\t\tif page.focused then\n\t\t\tpage.focused.focused = true\n\t\t\tpage.focused:focus()\n\t\tend\n\t\tpage:sync()\n\tend\nend\n\nfunction UI:getCurrentPage()\n\treturn self.term.currentPage\nend\n\nfunction UI:setPreviousPage()\n\tif self.term.currentPage.previousPage then\n\t\tlocal previousPage = self.term.currentPage.previousPage.previousPage\n\t\tself:setPage(self.term.currentPage.previousPage)\n\t\tself.term.currentPage.previousPage = previousPage\n\tend\nend\n\nfunction UI:getDefaults(element, args)\n\tlocal defaults = Util.deepCopy(element.defaults)\n\tif args then\n\t\tUI:mergeProperties(defaults, args)\n\tend\n\treturn defaults\nend\n\nfunction UI:mergeProperties(obj, args)\n\tif args then\n\t\tfor k,v in pairs(args) do\n\t\t\tif k == 'accelerators' then\n\t\t\t\tif obj.accelerators then\n\t\t\t\t\tUtil.merge(obj.accelerators, args.accelerators)\n\t\t\t\telse\n\t\t\t\t\tobj[k] = v\n\t\t\t\tend\n\t\t\telse\n\t\t\t\tobj[k] = v\n\t\t\tend\n\t\tend\n\tend\nend\n\nfunction UI:pullEvents(...)\n\tlocal s, m = pcall(Event.pullEvents, ...)\n\tself.term:reset()\n\tif not s and m then\n\t\terror(m, -1)\n\tend\nend\n\nUI.exitPullEvents = Event.exitPullEvents\nUI.quit = Event.exitPullEvents\nUI.start = UI.pullEvents\n\nUI:init()\n\n--[[-- Basic drawable area --]]--\nUI.Window = class(Canvas)\nUI.Window.uid = 1\nUI.Window.docs = { }\nUI.Window.defaults = {\n\tUIElement = 'Window',\n\tx = 1,\n\ty = 1,\n\toffx = 0,\n\toffy = 0,\n\tcursorX = 1,\n\tcursorY = 1,\n}\nfunction UI.Window:init(args)\n\t-- merge defaults for all subclasses\n\tlocal defaults = args\n\tlocal m = getmetatable(self)  -- get the class for this instance\n\trepeat\n\t\tif m ~= Canvas then\n\t\t\tdefaults = UI:getDefaults(m, defaults)\n\t\tend\n\t\tm = m._base\n\tuntil not m\n\tUI:mergeProperties(self, defaults)\n\n\t-- each element has a unique ID\n\tself.uid = UI.Window.uid\n\tUI.Window.uid = UI.Window.uid + 1\n\n\t-- at this time, the object has all the properties set\n\n\t-- postInit is a special constructor. the element does not need to implement\n\t-- the method. But we need to guarantee that each subclass which has this\n\t-- method is called.\n\tm = self\n\tlocal lpi\n\trepeat\n\t\tif m.postInit and m.postInit ~= lpi then\n\t\t\tm.postInit(self)\n\t\t\tlpi = m.postInit\n\t\tend\n\t\tm = m._base\n\tuntil not m\nend\n\nUI.Window.docs.postInit = [[postInit(VOID)\nCalled once the window has all the properties set.\nOverride to calculate properties or to dynamically add children]]\nfunction UI.Window:postInit()\n\tif self.parent then\n\t\t-- this will cascade down the whole tree of elements starting at the\n\t\t-- top level window (which has a device as a parent)\n\t\tself:setParent()\n\tend\nend\n\nfunction UI.Window:initChildren()\n\tlocal children = self.children\n\n\t-- insert any UI elements created using the shorthand\n\t-- window definition into the children array\n\tfor k,child in pairs(self) do\n\t\tif k ~= 'parent' then -- reserved\n\t\t\tif type(child) == 'table' and child.UIElement and not child.parent then\n\t\t\t\tif not children then\n\t\t\t\t\tchildren = { }\n\t\t\t\tend\n\t\t\t\ttable.insert(children, child)\n\t\t\tend\n\t\tend\n\tend\n\tif children then\n\t\tfor _,child in pairs(children) do\n\t\t\tif not child.parent then\n\t\t\t\tchild.parent = self\n\t\t\t\tchild:setParent()\n\t\t\t\tif self.enabled then\n\t\t\t\t\tchild:enable()\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\t\tself.children = children\n\tend\nend\n\nfunction UI.Window:layout()\n\tlocal function calc(p, max)\n\t\tp = tonumber(p:match('(%d+)%%'))\n\t\treturn p and math.floor(max * p / 100) or 1\n\tend\n\n\tif type(self.x) == 'string' then\n\t\tself.x = calc(self.x, self.parent.width) + 1\n\t\t-- +1 in order to allow both x and ex to use the same %\n\tend\n\tif type(self.ex) == 'string' then\n\t\tself.ex = calc(self.ex, self.parent.width)\n\tend\n\tif type(self.y) == 'string' then\n\t\tself.y = calc(self.y, self.parent.height) + 1\n\tend\n\tif type(self.ey) == 'string' then\n\t\tself.ey = calc(self.ey, self.parent.height)\n\tend\n\n\tif self.x < 0 then\n\t\tself.x = self.parent.width + self.x + 1\n\tend\n\tif self.y < 0 then\n\t\tself.y = self.parent.height + self.y + 1\n\tend\n\n\tif self.ex then\n\t\tlocal ex = self.ex\n\t\tif self.ex <= 1 then\n\t\t\tex = self.parent.width + self.ex + 1\n\t\tend\n\t\tif self.width then\n\t\t\tself.x = ex - self.width + 1\n\t\telse\n\t\t\tself.width = ex - self.x + 1\n\t\tend\n\tend\n\tif self.ey then\n\t\tlocal ey = self.ey\n\t\tif self.ey <= 1 then\n\t\t\tey = self.parent.height + self.ey + 1\n\t\tend\n\t\tif self.height then\n\t\t\tself.y = ey - self.height + 1\n\t\telse\n\t\t\tself.height = ey - self.y + 1\n\t\tend\n\tend\n\n\tif not self.width then\n\t\tself.width = self.parent.width - self.x + 1\n\tend\n\tif not self.height then\n\t\tself.height = self.parent.height - self.y + 1\n\tend\n\n\tself.width = math.max(self.width, 1)\n\tself.height = math.max(self.height, 1)\n\n\tself:reposition(self.x, self.y, self.width, self.height)\nend\n\n-- Called when the window's parent has be assigned\nfunction UI.Window:setParent()\n\tself.oh, self.ow = self.height, self.width\n\tself.ox, self.oy = self.x, self.y\n\tself.oex, self.oey = self.ex, self.ey\n\n\tself:layout()\n\tself:initChildren()\nend\n\nfunction UI.Window:resize()\n\tself.height, self.width = self.oh, self.ow\n\tself.x, self.y = self.ox, self.oy\n\tself.ex, self.ey = self.oex, self.oey\n\n\tself:layout()\n\n\tif self.children then\n\t\tfor child in self:eachChild() do\n\t\t\tchild:resize()\n\t\tend\n\tend\nend\n\nfunction UI.Window:reposition(x, y, w, h)\n\tif not self.lines then\n\t\tCanvas.init(self, {\n\t\t\tx = x,\n\t\t\ty = y,\n\t\t\twidth = w,\n\t\t\theight = h,\n\t\t\tisColor = self.parent.isColor,\n\t\t})\n\telse\n\t\tself:move(x, y)\n\t\tCanvas.resize(self, w, h)\n\tend\nend\n\nUI.Window.docs.raise = [[raise(VOID)\nRaise this window to the top]]\nfunction UI.Window:raise()\n\tArray.removeByValue(self.parent.children, self)\n\ttable.insert(self.parent.children, self)\n\tself:dirty(true)\nend\n\nUI.Window.docs.add = [[add(TABLE)\nAdd element(s) to a window. Example:\npage:add({\n\ttext = UI.Text {\n\t  x=5,value='help'\n\t}\n})]]\nfunction UI.Window:add(children)\n\tUI:mergeProperties(self, children)\n\tself:initChildren()\nend\n\nfunction UI.Window:eachChild()\n\tlocal c = self.children and Util.shallowCopy(self.children)\n\tlocal i = 0\n\treturn function()\n\t\ti = i + 1\n\t\treturn c and c[i]\n\tend\nend\n\nfunction UI.Window:remove()\n\tArray.removeByValue(self.parent.children, self)\n\tself.parent:dirty(true)\nend\n\nfunction UI.Window:getCursorPos()\n\treturn self.cursorX, self.cursorY\nend\n\nfunction UI.Window:setCursorPos(x, y)\n\tself.cursorX = x\n\tself.cursorY = y\n\tself.parent:setCursorPos(self.x + x - 1, self.y + y - 1)\nend\n\nfunction UI.Window:setCursorBlink(blink)\n\tself.cursorBlink = blink\nend\n\nUI.Window.docs.draw = [[draw(VOID)\nRedraws the window in the internal buffer.]]\nfunction UI.Window:draw()\n\tself:clear()\n\tself:drawChildren()\nend\n\nfunction UI.Window:drawChildren()\n\tfor child in self:eachChild() do\n\t\tif child.enabled then\n\t\t\tchild:draw()\n\t\tend\n\tend\nend\n\nUI.Window.docs.getDoc = [[getDoc(STRING method)\nGet the documentation for a method.]]\nfunction UI.Window:getDoc(method)\n\tlocal m = getmetatable(self)  -- get the class for this instance\n\trepeat\n\t\tif m.docs and m.docs[method] then\n\t\t\treturn m.docs[method]\n\t\tend\n\t\tm = m._base\n\tuntil not m\nend\n\nUI.Window.docs.sync = [[sync(VOID)\nInvoke a screen update. Automatically called at top level after an input event.\nCall to force a screen update.]]\nfunction UI.Window:sync()\n\tif self.parent then\n\t\tself.parent:sync()\n\tend\nend\n\nfunction UI.Window:enable(...)\n\tif not self.enabled then\n\t\tself.enabled = true\n\t\tif self.transitionHint then\n\t\t\tself:addTransition(self.transitionHint)\n\t\tend\n\n\t\tif self.modal then\n\t\t\tself:raise()\n\t\t\tself:capture(self)\n\t\tend\n\n\t\tfor child in self:eachChild() do\n\t\t\tif not child.enabled then\n\t\t\t\tchild:enable(...)\n\t\t\tend\n\t\tend\n\tend\nend\n\nfunction UI.Window:disable()\n\tif self.enabled then\n\t\tself.enabled = false\n\t\tself.parent:dirty(true)\n\n\t\tif self.modal then\n\t\t\tself:release(self)\n\t\tend\n\n\t\tfor child in self:eachChild() do\n\t\t\tif child.enabled then\n\t\t\t\tchild:disable()\n\t\t\tend\n\t\tend\n\tend\nend\n\nfunction UI.Window:setTextScale(textScale)\n\tself.textScale = textScale\n\tself.parent:setTextScale(textScale)\nend\n\nUI.Window.docs.clear = [[clear(opt COLOR bg, opt COLOR fg)\nClears the window using either the passed values or the defaults for that window.]]\nfunction UI.Window:clear(bg, fg)\n\tCanvas.clear(self, bg or self:getProperty('backgroundColor'), fg or self:getProperty('textColor'))\nend\n\nUI.Window.docs.clearLine = [[clearLine(NUMBER y, opt COLOR bg)\nClears the specified line.]]\nfunction UI.Window:clearLine(y, bg)\n\tself:write(1, y, _rep(' ', self.width), bg)\nend\n\nfunction UI.Window:clearArea(x, y, width, height, bg)\n\tself:fillArea(x, y, width, height, ' ', bg)\nend\n\nfunction UI.Window:fillArea(x, y, width, height, fillChar, bg, fg)\n\tif width > 0 then\n\t\tlocal filler = _rep(fillChar, width)\n\t\tfor i = 0, height - 1 do\n\t\t\tself:write(x, y + i, filler, bg, fg)\n\t\tend\n\tend\nend\n\nUI.Window.docs.write = [[write(NUMBER x, NUMBER y, STRING text, opt COLOR bg, opt COLOR fg)\nWrite text to the canvas.\nIf colors are not specified, the colors from the base class will be used.\nIf the base class does not have colors defined, colors will be inherited from the parent container.]]\nfunction UI.Window:write(x, y, text, bg, fg)\n\tCanvas.write(self, x, y, text, bg or self:getProperty('backgroundColor'), fg or self:getProperty('textColor'))\nend\n\nfunction UI.Window:centeredWrite(y, text, bg, fg)\n\tif #text >= self.width then\n\t\tself:write(1, y, text, bg, fg)\n\telse\n\t\tlocal x = math.floor((self.width-#text) / 2) + 1\n\t\tself:write(x, y, text, bg, fg)\n\tend\nend\n\nfunction UI.Window:print(text, bg, fg)\n\tlocal marginLeft = self.marginLeft or 0\n\tlocal marginRight = self.marginRight or 0\n\tlocal width = self.width - marginLeft - marginRight\n\tlocal cs = {\n\t\tbg = bg or self:getProperty('backgroundColor'),\n\t\tfg = fg or self:getProperty('textColor'),\n\t\tpalette = self.palette,\n\t}\n\n\tlocal y = (self.marginTop or 0) + 1\n\tfor _,line in pairs(Util.split(text)) do\n\t\tfor _, ln in ipairs(Blit(line, cs):wrap(width)) do\n\t\t\tself:blit(marginLeft + 1, y, ln.text, ln.bg, ln.fg)\n\t\t\ty = y + 1\n\t\tend\n\tend\nend\n\nUI.Window.docs.focus = [[focus(VOID)\nIf the function is present on a class, it indicates\nthat this element can accept focus. Called when receiving focus.]]\n\nUI.Window.docs.setFocus = [[setFocus(ELEMENT el)\nSet the page's focus to the passed element.]]\nfunction UI.Window:setFocus(focus)\n\tif self.parent then\n\t\tself.parent:setFocus(focus)\n\tend\nend\n\nUI.Window.docs.capture = [[capture(ELEMENT el)\nRestricts input to the passed element's tree.]]\nfunction UI.Window:capture(child)\n\tif self.parent then\n\t\tself.parent:capture(child)\n\tend\nend\n\nfunction UI.Window:release(child)\n\tif self.parent then\n\t\tself.parent:release(child)\n\tend\nend\n\nfunction UI.Window:pointToChild(x, y)\n\tx = x + self.offx - self.x + 1\n\ty = y + self.offy - self.y + 1\n\tif self.children then\n\t\tfor i = #self.children, 1, -1 do\n\t\t\tlocal child = self.children[i]\n\t\t\tif child.enabled and not child.inactive and\n\t\t\t\t x >= child.x and x < child.x + child.width and\n\t\t\t\t y >= child.y and y < child.y + child.height then\n\t\t\t\tlocal c = child:pointToChild(x, y)\n\t\t\t\tif c then\n\t\t\t\t\treturn c\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\treturn {\n\t\telement = self,\n\t\tx = x,\n\t\ty = y\n\t}\nend\n\nUI.Window.docs.getFocusables = [[getFocusables(VOID)\nReturns a list of children that can accept focus.]]\nfunction UI.Window:getFocusables()\n\tlocal focusable = { }\n\n\tlocal function focusSort(a, b)\n\t\tif a.y == b.y then\n\t\t\treturn a.x < b.x\n\t\tend\n\t\treturn a.y < b.y\n\tend\n\n\tlocal function getFocusable(parent)\n\t\tfor _,child in Util.spairs(parent.children, focusSort) do\n\t\t\tif child.enabled and child.focus and not child.inactive then\n\t\t\t\ttable.insert(focusable, child)\n\t\t\tend\n\t\t\tif child.children then\n\t\t\t\tgetFocusable(child)\n\t\t\tend\n\t\tend\n\tend\n\n\tif self.children then\n\t\tgetFocusable(self)\n\tend\n\n\treturn focusable\nend\n\nfunction UI.Window:focusFirst()\n\tlocal focusables = self:getFocusables()\n\tlocal focused = focusables[1]\n\tif focused then\n\t\tself:setFocus(focused)\n\tend\nend\n\nfunction UI.Window:scrollIntoView()\n\tlocal parent = self.parent\n\tlocal offx, offy = parent.offx, parent.offy\n\n\tif self.x <= parent.offx then\n\t\tparent.offx = math.max(0, self.x - 1)\n\t\tif offx ~= parent.offx then\n\t\t\tparent:draw()\n\t\tend\n\telseif self.x + self.width > parent.width + parent.offx then\n\t\tparent.offx = self.x + self.width - parent.width - 1\n\t\tif offx ~= parent.offx then\n\t\t\tparent:draw()\n\t\tend\n\tend\n\n\t-- TODO: fix\n\tlocal function setOffset(y)\n\t\tparent.offy = y\n\t\tif offy ~= parent.offy then\n\t\t\tparent:draw()\n\t\tend\n\tend\n\n\tif self.y <= parent.offy then\n\t\tsetOffset(math.max(0, self.y - 1))\n\telseif self.y + self.height > parent.height + parent.offy then\n\t\tsetOffset(self.y + self.height - parent.height - 1)\n\tend\nend\n\nfunction UI.Window:addTransition(effect, args, canvas)\n\tself.parent:addTransition(effect, args, canvas or self)\nend\n\nUI.Window.docs.emit = [[emit(TABLE event)\nSend an event to the element. The event handler for the element is called.\nIf the event handler returns true, then no further processing is done.\nIf the event handler does not return true, then the event is sent to the parent element\nand continues up the element tree.\nIf an accelerator is defined, the accelerated event is processed in the same manner.\nAccelerators are useful for making events unique.]]\nfunction UI.Window:emit(event)\n\tlocal parent = self\n\twhile parent do\n\t\tif parent.accelerators then\n\t\t\t-- events types can be made unique via accelerators\n\t\t\tlocal acc = parent.accelerators[event.key or event.type]\n\t\t\tif acc and acc ~= event.type then -- don't get stuck in a loop\n\t\t\t\tlocal event2 = Util.shallowCopy(event)\n\t\t\t\tevent2.type = acc\n\t\t\t\tevent2.key = nil\n\t\t\t\tif parent:emit(event2) then\n\t\t\t\t\treturn true\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\t\tif parent.eventHandler then\n\t\t\tif parent:eventHandler(event) then\n\t\t\t\treturn true\n\t\t\tend\n\t\tend\n\t\tparent = parent.parent\n\tend\nend\n\nfunction UI.Window:getProperty(property)\n\treturn self[property] or self.parent and self.parent:getProperty(property)\nend\n\nfunction UI.Window:find(uid)\n\tlocal el = self.children and Util.find(self.children, 'uid', uid)\n\tif not el then\n\t\tfor child in self:eachChild() do\n\t\t\tel = child:find(uid)\n\t\t\tif el then\n\t\t\t\tbreak\n\t\t\tend\n\t\tend\n\tend\n\treturn el\nend\n\nfunction UI.Window:eventHandler()\n\treturn false\nend\n\n--[[-- Terminal for computer / advanced computer / monitor --]]--\nUI.Device = class(UI.Window)\nUI.Device.defaults = {\n\tUIElement = 'Device',\n\tbackgroundColor = colors.black,\n\ttextColor = colors.white,\n\ttextScale = 1,\n\teffectsEnabled = true,\n}\nfunction UI.Device:postInit()\n\tself.device = self.device or term.current()\n\n\tif not self.device.setTextScale then\n\t\tself.device.setTextScale = function() end\n\tend\n\n\tself._obg = term.getBackgroundColor()\n\tself.device.setTextScale(self.textScale)\n\tself.width, self.height = self.device.getSize()\n\tself.isColor = self.device.isColor()\n\tCanvas.init(self, { isColor = self.isColor })\n\n\tUI.devices[self.device.side or 'terminal'] = self\nend\n\nfunction UI.Device:resize()\n\tself.device.setTextScale(self.textScale)\n\tself.width, self.height = self.device.getSize()\n\tself.lines = { }\n\t-- TODO: resize all pages added to this device\n\tCanvas.resize(self, self.width, self.height)\n\tCanvas.clear(self, self.backgroundColor, self.textColor)\nend\n\nfunction UI.Device:setCursorPos(x, y)\n\tself.cursorX = x\n\tself.cursorY = y\nend\n\nfunction UI.Device:getCursorBlink()\n\treturn self.cursorBlink\nend\n\nfunction UI.Device:setCursorBlink(blink)\n\tself.cursorBlink = blink\nend\n\nfunction UI.Device:setTextScale(textScale)\n\tself.textScale = textScale\n\tself.device.setTextScale(self.textScale)\nend\n\nfunction UI.Device:reset()\n\tself.device.setBackgroundColor(self._obg)\n\tself.device.clear()\n\tself.device.setCursorPos(1, 1)\nend\n\nfunction UI.Device:addTransition(effect, args, canvas)\n\tif not self.transitions then\n\t\tself.transitions = { }\n\tend\n\n\tif type(effect) == 'string' then\n\t\teffect = Transition[effect] or error('Invalid transition')\n\tend\n\n\t-- there can be only one\n\tfor k,v in pairs(self.transitions) do\n\t\tif v.canvas == canvas then\n\t\t\ttable.remove(self.transitions, k)\n\t\t\tbreak\n\t\tend\n\tend\n\n\ttable.insert(self.transitions, { effect = effect, args = args or { }, canvas = canvas })\nend\n\nfunction UI.Device:runTransitions(transitions)\n\tfor _,k in pairs(transitions) do\n\t\tk.update = k.effect(k.canvas, k.args)\n\tend\n\twhile true do\n\t\tfor _,k in ipairs(Util.keys(transitions)) do\n\t\t\tlocal transition = transitions[k]\n\t\t\tif not transition.update() then\n\t\t\t\ttransitions[k] = nil\n\t\t\tend\n\t\tend\n\t\tself.currentPage:render(self, true)\n\t\tif Util.empty(transitions) then\n\t\t\tbreak\n\t\tend\n\t\tos.sleep(0)\n\tend\nend\n\nfunction UI.Device:sync()\n\tlocal transitions = self.effectsEnabled and self.transitions\n\tself.transitions = nil\n\n\tself.device.setCursorBlink(false)\n\n\tif transitions then\n\t\tself:runTransitions(transitions)\n\telse\n\t\tself.currentPage:render(self, true)\n\tend\n\n\tif self:getCursorBlink() then\n\t\tself.device.setCursorPos(self.cursorX, self.cursorY)\n\t\tif self.isColor then\n\t\t\tself.device.setTextColor(colors.orange)\n\t\tend\n\t\tself.device.setCursorBlink(true)\n\tend\nend\n\n-- lazy load components\nlocal function loadComponents()\n\tlocal function load(name)\n\t\tlocal s, m = Util.run(_ENV, 'sys/modules/opus/ui/components/' .. name .. '.lua')\n\t\tif not s then\n\t\t\terror(m)\n\t\tend\n\t\tif UI[name]._preload then\n\t\t\terror('Error loading UI.' .. name)\n\t\tend\n\t\tif UI.theme[name] and UI[name].defaults then\n\t\t\tUtil.merge(UI[name].defaults, UI.theme[name])\n\t\tend\n\t\treturn UI[name]\n\tend\n\n\tlocal components = fs.list('sys/modules/opus/ui/components')\n\tfor _, f in pairs(components) do\n\t\tlocal name = f:match('(.+)%.')\n\n\t\tUI[name] = setmetatable({ }, {\n\t\t\t__call = function(self, ...)\n\t\t\t\tload(name)\n\t\t\t\tsetmetatable(self, getmetatable(UI[name]))\n\t\t\t\treturn self(...)\n\t\t\tend\n\t\t})\n\t\tUI[name]._preload = function()\n\t\t\treturn load(name)\n\t\tend\n\tend\nend\n\nloadComponents()\nUI:loadTheme('usr/config/ui.theme')\nUI:setDefaultDevice(UI.Device())\n\nreturn UI\n", "sys/modules/opus/security.lua": "local Config = require('opus.config')\n\nlocal Security = { }\n\nfunction Security.verifyPassword(password)\n\tlocal current = Security.getPassword()\n\treturn current and password == current\nend\n\nfunction Security.hasPassword()\n\treturn not not Security.getPassword()\nend\n\nfunction Security.getIdentifier()\n\tlocal config = Config.load('os')\n\n\tif not config.identifier then\n\t\tlocal key = { }\n\t\tfor _ = 1, 32 do\n\t\t\ttable.insert(key, (\"%02x\"):format(math.random(0, 0xFF)))\n\t\tend\n\t\tconfig.identifier = table.concat(key)\n\n\t\tConfig.update('os', config)\n\tend\n\n\treturn config.identifier\nend\n\nfunction Security.updatePassword(password)\n\tlocal config = Config.load('os')\n\tconfig.password = password\n\tConfig.update('os', config)\nend\n\nfunction Security.getPassword()\n\treturn Config.load('os').password\nend\n\nreturn Security\n", "sys/modules/opus/injector.lua": "-- https://www.lua.org/manual/5.1/manual.html#pdf-require\n-- https://github.com/LuaDist/lua/blob/d2e7e7d4d43ff9068b279a617c5b2ca2c2771676/src/loadlib.c\n\nlocal defaultPath = { }\n\ndo\n\tlocal function split(str)\n\t\tlocal t = { }\n\t\tlocal function helper(line) table.insert(t, line) return \"\" end\n\t\thelper((str:gsub('(.-);', helper)))\n\t\treturn t\n\tend\n\n\tlocal function insert(p)\n\t\tfor _,v in pairs(defaultPath) do\n\t\t\tif v == p then\n\t\t\t\treturn\n\t\t\tend\n\t\tend\n\t\ttable.insert(defaultPath, p)\n\n\tend\n\n\tlocal paths = '?.lua;?/init.lua;'\n\tpaths = paths .. '/usr/modules/?.lua;/usr/modules/?/init.lua;'\n\tpaths = paths .. '/rom/modules/main/?;/rom/modules/main/?.lua;/rom/modules/main/?/init.lua;'\n\tpaths = paths .. '/sys/modules/?.lua;/sys/modules/?/init.lua'\n\n\tfor _,v in pairs(split(paths)) do\n\t\tinsert(v)\n\tend\n\n\tlocal luaPaths = package and package.path and split(package.path) or { }\n\tfor _,v in pairs(luaPaths) do\n\t\tif v ~= '?' then\n\t\t\tinsert(v)\n\t\tend\n\tend\nend\n\nlocal DEFAULT_PATH = table.concat(defaultPath, ';')\n\nlocal fs     = _G.fs\nlocal os     = _G.os\nlocal string = _G.string\n\n-- Add require and package to the environment\nreturn function(env, programDir)\n\tlocal function preloadSearcher(modname)\n\t\tif env.package.preload[modname] then\n\t\t\treturn function()\n\t\t\t\treturn env.package.preload[modname](modname, env)\n\t\t\tend\n\t\tend\n\tend\n\n\tlocal function pathSearcher(modname)\n\t\tlocal fname = modname:gsub('%.', '/')\n\n\t\tfor pattern in string.gmatch(env.package.path, \"[^;]+\") do\n\t\t\tlocal sPath = string.gsub(pattern, \"%?\", fname)\n\n\t\t\tif programDir and sPath:sub(1, 1) ~= \"/\" then\n\t\t\t\tsPath = fs.combine(programDir, sPath)\n\t\t\tend\n\t\t\tif fs.exists(sPath) and not fs.isDir(sPath) then\n\t\t\t\treturn loadfile(fs.combine(sPath, ''), env)\n\t\t\tend\n\t\tend\n\tend\n\n\t-- place package and require function into env\n\tenv.package = {\n\t\tpath    = env.LUA_PATH or _G.LUA_PATH or DEFAULT_PATH,\n\t\tcpath   = '',\n\t\tconfig  = '/\\n:\\n?\\n!\\n-',\n\t\tpreload = { },\n\t\tloaded  = {\n\t\t\tbit32 = bit32,\n\t\t\tcoroutine = coroutine,\n\t\t\t_G     = env._G,\n\t\t\tio     = io,\n\t\t\tmath   = math,\n\t\t\tos     = os,\n\t\t\tstring = string,\n\t\t\ttable  = table,\n\t\t\tdebug  = debug,\n\t\t\tutf8   = utf8,\n\t\t},\n\t\tloaders = {\n\t\t\tpreloadSearcher,\n\t\t\tpathSearcher,\n\t\t}\n\t}\n\tenv.package.loaded.package = env.package\n\n\tlocal sentinel = { }\n\n\tfunction env.require(modname)\n\t\tif env.package.loaded[modname] then\n\t\t\tif env.package.loaded[modname] == sentinel then\n\t\t\t\terror(\"loop or previous error loading module '\" .. modname .. \"'\", 0)\n\t\t\tend\n\t\t\treturn env.package.loaded[modname]\n\t\tend\n\n\t\tlocal t = { }\n\t\tfor _,searcher in ipairs(env.package.loaders) do\n\t\t\tlocal fn, msg = searcher(modname)\n\t\t\tif type(fn) == 'function' then\n\t\t\t\tenv.package.loaded[modname] = sentinel\n\n\t\t\t\tlocal module = fn(modname, env) or true\n\n\t\t\t\tenv.package.loaded[modname] = module\n\t\t\t\treturn module\n\t\t\tend\n\t\t\tif msg then\n\t\t\t\ttable.insert(t, msg)\n\t\t\tend\n\t\tend\n\n\t\tif #t > 0 then\n\t\t\terror(table.concat(t, '\\n'), 2)\n\t\tend\n\t\terror('Unable to find module ' .. modname, 2)\n\tend\nend\n", "sys/modules/opus/ui/region.lua": "--\n--\ttek.lib.region\n--\tWritten by Timm S. Mueller <tmueller at schulze-mueller.de>\n--\n-- Copyright 2008 - 2016 by the authors and contributors:\n--\n--  * Timm S. Muller <tmueller at schulze-mueller.de>\n--  * Franciska Schulze <fschulze at schulze-mueller.de>\n--  * Tobias Schwinger <tschwinger at isonews2.com>\n--\n-- https://opensource.org/licenses/MIT\n--\n-- Some comments have been removed to reduce file size, see:\n-- https://github.com/technosaurus/tekui/blob/master/etc/region.lua\n-- for the full source\n\nlocal insert = table.insert\nlocal ipairs = ipairs\nlocal max = math.max\nlocal min = math.min\nlocal setmetatable = setmetatable\nlocal unpack = unpack or table.unpack\n\nlocal Region = { }\nRegion._VERSION = \"Region 11.3\"\n\nRegion.__index = Region\n\n--\tx0, y0, x1, y1 = Region.intersect(d1, d2, d3, d4, s1, s2, s3, s4):\n--\tReturns the coordinates of a rectangle where a rectangle specified by\n--\tthe coordinates s1, s2, s3, s4 overlaps with the rectangle specified\n--\tby the coordinates d1, d2, d3, d4. The return value is '''nil''' if\n--\tthe rectangles do not overlap.\nfunction Region.intersect(d1, d2, d3, d4, s1, s2, s3, s4)\n\tif s3 >= d1 and s1 <= d3 and s4 >= d2 and s2 <= d4 then\n\t\treturn max(s1, d1), max(s2, d2), min(s3, d3), min(s4, d4)\n\tend\nend\n\n--\tinsertrect: insert rect to table, merging with an existing one if possible\nlocal function insertrect(d, s1, s2, s3, s4)\n\tfor i = 1, min(4, #d) do\n\t\tlocal a = d[i]\n\t\tlocal a1, a2, a3, a4 = a[1], a[2], a[3], a[4]\n\t\tif a2 == s2 and a4 == s4 then\n\t\t\tif a3 + 1 == s1 then\n\t\t\t\ta[3] = s3\n\t\t\t\treturn\n\t\t\telseif a1 == s3 + 1 then\n\t\t\t\ta[1] = s1\n\t\t\t\treturn\n\t\t\tend\n\t\telseif a1 == s1 and a3 == s3 then\n\t\t\tif a4 + 1 == s2 then\n\t\t\t\ta[4] = s4\n\t\t\t\treturn\n\t\t\telseif a2 == s4 + 1 then\n\t\t\t\ta[2] = s2\n\t\t\t\treturn\n\t\t\tend\n\t\tend\n\tend\n\tinsert(d, 1, { s1, s2, s3, s4 })\nend\n\n--\tcutrect: cut rect d into table of new rects, using rect s as a punch\nlocal function cutrect(d1, d2, d3, d4, s1, s2, s3, s4)\n\tif not Region.intersect(d1, d2, d3, d4, s1, s2, s3, s4) then\n\t\treturn { { d1, d2, d3, d4 } }\n\tend\n\tlocal r = { }\n\tif d1 < s1 then\n\t\tinsertrect(r, d1, d2, s1 - 1, d4)\n\t\td1 = s1\n\tend\n\tif d2 < s2 then\n\t\tinsertrect(r, d1, d2, d3, s2 - 1)\n\t\td2 = s2\n\tend\n\tif d3 > s3 then\n\t\tinsertrect(r, s3 + 1, d2, d3, d4)\n\t\td3 = s3\n\tend\n\tif d4 > s4 then\n\t\tinsertrect(r, d1, s4 + 1, d3, d4)\n\tend\n\treturn r\nend\n\n--\tcutregion: cut region d, using s as a punch\nlocal function cutregion(d, s1, s2, s3, s4)\n\tlocal r = { }\n\tfor _, dr in ipairs(d) do\n\t\tlocal d1, d2, d3, d4 = dr[1], dr[2], dr[3], dr[4]\n\t\tfor _, t in ipairs(cutrect(d1, d2, d3, d4, s1, s2, s3, s4)) do\n\t\t\tinsertrect(r, t[1], t[2], t[3], t[4])\n\t\tend\n\tend\n\treturn r\nend\n\n--\tregion = Region.new(r1, r2, r3, r4): Creates a new region from the given\n--\tcoordinates.\nfunction Region.new(r1, r2, r3, r4)\n\tif r1 then\n\t\treturn setmetatable({ region = { { r1, r2, r3, r4 } } }, Region)\n\tend\n\treturn setmetatable({ region = { } }, Region)\nend\n\n--\tself = region:setRect(r1, r2, r3, r4): Resets an existing region\n--\tto the specified rectangle.\nfunction Region:setRect(r1, r2, r3, r4)\n\tself.region = { { r1, r2, r3, r4 } }\n\treturn self\nend\n\n--\tregion:orRect(r1, r2, r3, r4): Logical ''or''s a rectangle to a region\nfunction Region:orRect(s1, s2, s3, s4)\n\tself.region = cutregion(self.region, s1, s2, s3, s4)\n\tinsertrect(self.region, s1, s2, s3, s4)\nend\n\n--\tregion:orRegion(region): Logical ''or''s another region to a region\nfunction Region:orRegion(s)\n\tfor _, r in ipairs(s) do\n\t\tself:orRect(r[1], r[2], r[3], r[4])\n\tend\nend\n\n--\tregion:andRect(r1, r2, r3, r4): Logical ''and''s a rectange to a region\nfunction Region:andRect(s1, s2, s3, s4)\n\tlocal r = { }\n\tfor _, d in ipairs(self.region) do\n\t\tlocal t1, t2, t3, t4 =\n\t\t\tRegion.intersect(d[1], d[2], d[3], d[4], s1, s2, s3, s4)\n\t\tif t1 then\n\t\t\tinsertrect(r, t1, t2, t3, t4)\n\t\tend\n\tend\n\tself.region = r\nend\n\n--\tregion:xorRect(r1, r2, r3, r4): Logical ''xor''s a rectange to a region\nfunction Region:xorRect(s1, s2, s3, s4)\n\tlocal r1 = { }\n\tlocal r2 = { { s1, s2, s3, s4 } }\n\tfor _, d in ipairs(self.region) do\n\t\tlocal d1, d2, d3, d4 = d[1], d[2], d[3], d[4]\n\t\tfor _, t in ipairs(cutrect(d1, d2, d3, d4, s1, s2, s3, s4)) do\n\t\t\tinsertrect(r1, t[1], t[2], t[3], t[4])\n\t\tend\n\t\tr2 = cutregion(r2, d1, d2, d3, d4)\n\tend\n\tself.region = r1\n\tself:orRegion(r2)\nend\n\n--\tself = region:subRect(r1, r2, r3, r4): Subtracts a rectangle from a region\nfunction Region:subRect(s1, s2, s3, s4)\n\tlocal r1 = { }\n\tfor _, d in ipairs(self.region) do\n\t\tlocal d1, d2, d3, d4 = d[1], d[2], d[3], d[4]\n\t\tfor _, t in ipairs(cutrect(d1, d2, d3, d4, s1, s2, s3, s4)) do\n\t\t\tinsertrect(r1, t[1], t[2], t[3], t[4])\n\t\tend\n\tend\n\tself.region = r1\n\treturn self\nend\n\n--\tregion:getRect - gets an iterator on the rectangles in a region [internal]\nfunction Region:getRects()\n\tlocal index = 0\n\treturn function(object)\n\t\tindex = index + 1\n\t\tif object[index] then\n\t\t\treturn unpack(object[index])\n\t\tend\n\tend, self.region\nend\n\n--\tsuccess = region:checkIntersect(x0, y0, x1, y1): Returns a boolean\n--\tindicating whether a rectangle specified by its coordinates overlaps\n--\twith a region.\nfunction Region:checkIntersect(s1, s2, s3, s4)\n\tfor _, d in ipairs(self.region) do\n\t\tif Region.intersect(d[1], d[2], d[3], d[4], s1, s2, s3, s4) then\n\t\t\treturn true\n\t\tend\n\tend\n\treturn false\nend\n\n--\tregion:subRegion(region2): Subtracts {{region2}} from {{region}}.\nfunction Region:subRegion(region)\n\tif region then\n\t\tfor r1, r2, r3, r4 in region:getRects() do\n\t\t\tself:subRect(r1, r2, r3, r4)\n\t\tend\n\tend\nend\n\n--\tregion:andRegion(r): Logically ''and''s a region to a region\nfunction Region:andRegion(s)\n\tlocal r = { }\n\tfor _, s in ipairs(s.region) do\n\t\tfor _, d in ipairs(self.region) do\n\t\t\tlocal t1, t2, t3, t4 =\n\t\t\t\tRegion.intersect(d[1], d[2], d[3], d[4],\n\t\t\t\t\ts[1], s[2], s[3], s[4])\n\t\t\tif t1 then\n\t\t\t\tinsertrect(r, t1, t2, t3, t4)\n\t\t\tend\n\t\tend\n\tend\n\tself.region = r\nend\n\n--\tregion:forEach(func, obj, ...): For each rectangle in a region, calls the\n--\tspecified function according the following scheme:\n--\t\t\tfunc(obj, x0, y0, x1, y1, ...)\n--\tExtra arguments are passed through to the function.\nfunction Region:forEach(func, obj, ...)\n\tfor x0, y0, x1, y1 in self:getRects() do\n\t\tfunc(obj, x0, y0, x1, y1, ...) \n\tend\nend\n\n--\tregion:shift(dx, dy): Shifts a region by delta x and y.\nfunction Region:shift(dx, dy)\n\tfor _, r in ipairs(self.region) do\n\t\tr[1] = r[1] + dx\n\t\tr[2] = r[2] + dy\n\t\tr[3] = r[3] + dx\n\t\tr[4] = r[4] + dy\n\tend\nend\n\n--\tregion:isEmpty(): Returns '''true''' if a region is empty.\nfunction Region:isEmpty()\n\treturn #self.region == 0\nend\n\n--\tminx, miny, maxx, maxy = region:get(): Get region's min/max extents\nfunction Region:get()\n\tif #self.region > 0 then\n\t\tlocal minx = 1000000 -- ui.HUGE\n\t\tlocal miny = 1000000\n\t\tlocal maxx = 0\n\t\tlocal maxy = 0\n\t\tfor _, r in ipairs(self.region) do\n\t\t\tminx = min(minx, r[1])\n\t\t\tminy = min(miny, r[2])\n\t\t\tmaxx = max(maxx, r[3])\n\t\t\tmaxy = max(maxy, r[4])\n\t\tend\n\t\treturn minx, miny, maxx, maxy\n\tend\nend\n\nreturn Region\n", "sys/modules/opus/ui/transition.lua": "local Tween  = require('opus.ui.tween')\n\nlocal Transition = { }\n\nfunction Transition.slideLeft(canvas, args)\n\tlocal ticks      = args.ticks or 6\n\tlocal easing     = args.easing or 'inCirc'\n\tlocal pos        = { x = canvas.ex }\n\tlocal tween      = Tween.new(ticks, pos, { x = canvas.x }, easing)\n\n\tcanvas:move(pos.x, canvas.y)\n\n\treturn function()\n\t\tlocal finished = tween:update(1)\n\t\tcanvas:move(math.floor(pos.x), canvas.y)\n\t\tcanvas:dirty(true)\n\t\treturn not finished\n\tend\nend\n\nfunction Transition.slideRight(canvas, args)\n\tlocal ticks      = args.ticks or 6\n\tlocal easing     = args.easing or 'inCirc'\n\tlocal pos        = { x = -canvas.width }\n\tlocal tween      = Tween.new(ticks, pos, { x = 1 }, easing)\n\n\tcanvas:move(pos.x, canvas.y)\n\n\treturn function()\n\t\tlocal finished = tween:update(1)\n\t\tcanvas:move(math.floor(pos.x), canvas.y)\n\t\tcanvas:dirty(true)\n\t\treturn not finished\n\tend\nend\n\nfunction Transition.expandUp(canvas, args)\n\tlocal ticks  = args.ticks or 3\n\tlocal easing = args.easing or 'linear'\n\tlocal pos    = { y = canvas.ey + 1 }\n\tlocal tween  = Tween.new(ticks, pos, { y = canvas.y }, easing)\n\n\tcanvas:move(canvas.x, pos.y)\n\n\treturn function()\n\t\tlocal finished = tween:update(1)\n\t\tcanvas:move(canvas.x, math.floor(pos.y))\n\t\tcanvas.parent:dirty(true)\n\t\treturn not finished\n\tend\nend\n\nfunction Transition.shake(canvas, args)\n\tlocal ticks  = args.ticks or 8\n\tlocal i = ticks\n\n\treturn function()\n\t\ti = -i\n\t\tcanvas:move(canvas.x + i, canvas.y)\n\t\tif i > 0 then\n\t\t\ti = i - 2\n\t\tend\n\t\treturn i ~= 0\n\tend\nend\n\nfunction Transition.shuffle(canvas, args)\n\tlocal ticks  = args.ticks or 4\n\tlocal easing = args.easing or 'linear'\n\tlocal t = { }\n\n\tfor _,child in pairs(canvas.children) do\n\t\tt[child] = Tween.new(ticks, child, { x = child.x, y = child.y }, easing)\n\t\tchild.x = math.random(1, canvas.parent.width)\n\t\tchild.y = math.random(1, canvas.parent.height)\n\tend\n\n\treturn function()\n\t\tlocal finished\n\t\tfor child, tween in pairs(t) do\n\t\t\tfinished = tween:update(1)\n\t\t\tchild:move(math.floor(child.x), math.floor(child.y))\n\t\tend\n\t\treturn not finished\n\tend\nend\n\nreturn Transition\n", "sys/modules/opus/ui/tween.lua": "local tween = {\n\t_VERSION     = 'tween 2.1.1',\n\t_DESCRIPTION = 'tweening for lua',\n\t_URL         = 'https://github.com/kikito/tween.lua',\n\t_LICENSE     = [[\n\t\tMIT LICENSE\n\n\t\tCopyright (c) 2014 Enrique Garc\u00eda Cota, Yuichi Tateno, Emmanuel Oga\n\n\t\tlicense details: https://opensource.org/licenses/MIT\n\t]]\n}\n\n-- easing\n\n-- Adapted from https://github.com/EmmanuelOga/easing. See LICENSE.txt for credits.\n-- For all easing functions:\n-- t = time == how much time has to pass for the tweening to complete\n-- b = begin == starting property value\n-- c = change == ending - beginning\n-- d = duration == running time. How much time has passed *right now*\n\nlocal pow, sin, cos, pi, sqrt, abs, asin = math.pow, math.sin, math.cos, math.pi, math.sqrt, math.abs, math.asin\n\n-- linear\nlocal function linear(t, b, c, d) return c * t / d + b end\n\n-- quad\nlocal function inQuad(t, b, c, d) return c * pow(t / d, 2) + b end\nlocal function outQuad(t, b, c, d)\n\tt = t / d\n\treturn -c * t * (t - 2) + b\nend\nlocal function inOutQuad(t, b, c, d)\n\tt = t / d * 2\n\tif t < 1 then return c / 2 * pow(t, 2) + b end\n\treturn -c / 2 * ((t - 1) * (t - 3) - 1) + b\nend\nlocal function outInQuad(t, b, c, d)\n\tif t < d / 2 then return outQuad(t * 2, b, c / 2, d) end\n\treturn inQuad((t * 2) - d, b + c / 2, c / 2, d)\nend\n\n-- cubic\nlocal function inCubic (t, b, c, d) return c * pow(t / d, 3) + b end\nlocal function outCubic(t, b, c, d) return c * (pow(t / d - 1, 3) + 1) + b end\nlocal function inOutCubic(t, b, c, d)\n\tt = t / d * 2\n\tif t < 1 then return c / 2 * t * t * t + b end\n\tt = t - 2\n\treturn c / 2 * (t * t * t + 2) + b\nend\nlocal function outInCubic(t, b, c, d)\n\tif t < d / 2 then return outCubic(t * 2, b, c / 2, d) end\n\treturn inCubic((t * 2) - d, b + c / 2, c / 2, d)\nend\n\n-- quart\nlocal function inQuart(t, b, c, d) return c * pow(t / d, 4) + b end\nlocal function outQuart(t, b, c, d) return -c * (pow(t / d - 1, 4) - 1) + b end\nlocal function inOutQuart(t, b, c, d)\n\tt = t / d * 2\n\tif t < 1 then return c / 2 * pow(t, 4) + b end\n\treturn -c / 2 * (pow(t - 2, 4) - 2) + b\nend\nlocal function outInQuart(t, b, c, d)\n\tif t < d / 2 then return outQuart(t * 2, b, c / 2, d) end\n\treturn inQuart((t * 2) - d, b + c / 2, c / 2, d)\nend\n\n-- quint\nlocal function inQuint(t, b, c, d) return c * pow(t / d, 5) + b end\nlocal function outQuint(t, b, c, d) return c * (pow(t / d - 1, 5) + 1) + b end\nlocal function inOutQuint(t, b, c, d)\n\tt = t / d * 2\n\tif t < 1 then return c / 2 * pow(t, 5) + b end\n\treturn c / 2 * (pow(t - 2, 5) + 2) + b\nend\nlocal function outInQuint(t, b, c, d)\n\tif t < d / 2 then return outQuint(t * 2, b, c / 2, d) end\n\treturn inQuint((t * 2) - d, b + c / 2, c / 2, d)\nend\n\n-- sine\nlocal function inSine(t, b, c, d) return -c * cos(t / d * (pi / 2)) + c + b end\nlocal function outSine(t, b, c, d) return c * sin(t / d * (pi / 2)) + b end\nlocal function inOutSine(t, b, c, d) return -c / 2 * (cos(pi * t / d) - 1) + b end\nlocal function outInSine(t, b, c, d)\n\tif t < d / 2 then return outSine(t * 2, b, c / 2, d) end\n\treturn inSine((t * 2) -d, b + c / 2, c / 2, d)\nend\n\n-- expo\nlocal function inExpo(t, b, c, d)\n\tif t == 0 then return b end\n\treturn c * pow(2, 10 * (t / d - 1)) + b - c * 0.001\nend\nlocal function outExpo(t, b, c, d)\n\tif t == d then return b + c end\n\treturn c * 1.001 * (-pow(2, -10 * t / d) + 1) + b\nend\nlocal function inOutExpo(t, b, c, d)\n\tif t == 0 then return b end\n\tif t == d then return b + c end\n\tt = t / d * 2\n\tif t < 1 then return c / 2 * pow(2, 10 * (t - 1)) + b - c * 0.0005 end\n\treturn c / 2 * 1.0005 * (-pow(2, -10 * (t - 1)) + 2) + b\nend\nlocal function outInExpo(t, b, c, d)\n\tif t < d / 2 then return outExpo(t * 2, b, c / 2, d) end\n\treturn inExpo((t * 2) - d, b + c / 2, c / 2, d)\nend\n\n-- circ\nlocal function inCirc(t, b, c, d) return(-c * (sqrt(1 - pow(t / d, 2)) - 1) + b) end\nlocal function outCirc(t, b, c, d)  return(c * sqrt(1 - pow(t / d - 1, 2)) + b) end\nlocal function inOutCirc(t, b, c, d)\n\tt = t / d * 2\n\tif t < 1 then return -c / 2 * (sqrt(1 - t * t) - 1) + b end\n\tt = t - 2\n\treturn c / 2 * (sqrt(1 - t * t) + 1) + b\nend\nlocal function outInCirc(t, b, c, d)\n\tif t < d / 2 then return outCirc(t * 2, b, c / 2, d) end\n\treturn inCirc((t * 2) - d, b + c / 2, c / 2, d)\nend\n\n-- elastic\nlocal function calculatePAS(p,a,c,d)\n\tp, a = p or d * 0.3, a or 0\n\tif a < abs(c) then return p, c, p / 4 end -- p, a, s\n\treturn p, a, p / (2 * pi) * asin(c/a) -- p,a,s\nend\nlocal function inElastic(t, b, c, d, a, p)\n\tlocal s\n\tif t == 0 then return b end\n\tt = t / d\n\tif t == 1  then return b + c end\n\tp,a,s = calculatePAS(p,a,c,d)\n\tt = t - 1\n\treturn -(a * pow(2, 10 * t) * sin((t * d - s) * (2 * pi) / p)) + b\nend\nlocal function outElastic(t, b, c, d, a, p)\n\tlocal s\n\tif t == 0 then return b end\n\tt = t / d\n\tif t == 1 then return b + c end\n\tp,a,s = calculatePAS(p,a,c,d)\n\treturn a * pow(2, -10 * t) * sin((t * d - s) * (2 * pi) / p) + c + b\nend\nlocal function inOutElastic(t, b, c, d, a, p)\n\tlocal s\n\tif t == 0 then return b end\n\tt = t / d * 2\n\tif t == 2 then return b + c end\n\tp,a,s = calculatePAS(p,a,c,d)\n\tt = t - 1\n\tif t < 0 then return -0.5 * (a * pow(2, 10 * t) * sin((t * d - s) * (2 * pi) / p)) + b end\n\treturn a * pow(2, -10 * t) * sin((t * d - s) * (2 * pi) / p ) * 0.5 + c + b\nend\nlocal function outInElastic(t, b, c, d, a, p)\n\tif t < d / 2 then return outElastic(t * 2, b, c / 2, d, a, p) end\n\treturn inElastic((t * 2) - d, b + c / 2, c / 2, d, a, p)\nend\n\n-- back\nlocal function inBack(t, b, c, d, s)\n\ts = s or 1.70158\n\tt = t / d\n\treturn c * t * t * ((s + 1) * t - s) + b\nend\nlocal function outBack(t, b, c, d, s)\n\ts = s or 1.70158\n\tt = t / d - 1\n\treturn c * (t * t * ((s + 1) * t + s) + 1) + b\nend\nlocal function inOutBack(t, b, c, d, s)\n\ts = (s or 1.70158) * 1.525\n\tt = t / d * 2\n\tif t < 1 then return c / 2 * (t * t * ((s + 1) * t - s)) + b end\n\tt = t - 2\n\treturn c / 2 * (t * t * ((s + 1) * t + s) + 2) + b\nend\nlocal function outInBack(t, b, c, d, s)\n\tif t < d / 2 then return outBack(t * 2, b, c / 2, d, s) end\n\treturn inBack((t * 2) - d, b + c / 2, c / 2, d, s)\nend\n\n-- bounce\nlocal function outBounce(t, b, c, d)\n\tt = t / d\n\tif t < 1 / 2.75 then return c * (7.5625 * t * t) + b end\n\tif t < 2 / 2.75 then\n\t\tt = t - (1.5 / 2.75)\n\t\treturn c * (7.5625 * t * t + 0.75) + b\n\telseif t < 2.5 / 2.75 then\n\t\tt = t - (2.25 / 2.75)\n\t\treturn c * (7.5625 * t * t + 0.9375) + b\n\tend\n\tt = t - (2.625 / 2.75)\n\treturn c * (7.5625 * t * t + 0.984375) + b\nend\nlocal function inBounce(t, b, c, d) return c - outBounce(d - t, 0, c, d) + b end\nlocal function inOutBounce(t, b, c, d)\n\tif t < d / 2 then return inBounce(t * 2, 0, c, d) * 0.5 + b end\n\treturn outBounce(t * 2 - d, 0, c, d) * 0.5 + c * .5 + b\nend\nlocal function outInBounce(t, b, c, d)\n\tif t < d / 2 then return outBounce(t * 2, b, c / 2, d) end\n\treturn inBounce((t * 2) - d, b + c / 2, c / 2, d)\nend\n\ntween.easing = {\n\tlinear    = linear,\n\tinQuad    = inQuad,    outQuad    = outQuad,    inOutQuad    = inOutQuad,    outInQuad    = outInQuad,\n\tinCubic   = inCubic,   outCubic   = outCubic,   inOutCubic   = inOutCubic,   outInCubic   = outInCubic,\n\tinQuart   = inQuart,   outQuart   = outQuart,   inOutQuart   = inOutQuart,   outInQuart   = outInQuart,\n\tinQuint   = inQuint,   outQuint   = outQuint,   inOutQuint   = inOutQuint,   outInQuint   = outInQuint,\n\tinSine    = inSine,    outSine    = outSine,    inOutSine    = inOutSine,    outInSine    = outInSine,\n\tinExpo    = inExpo,    outExpo    = outExpo,    inOutExpo    = inOutExpo,    outInExpo    = outInExpo,\n\tinCirc    = inCirc,    outCirc    = outCirc,    inOutCirc    = inOutCirc,    outInCirc    = outInCirc,\n\tinElastic = inElastic, outElastic = outElastic, inOutElastic = inOutElastic, outInElastic = outInElastic,\n\tinBack    = inBack,    outBack    = outBack,    inOutBack    = inOutBack,    outInBack    = outInBack,\n\tinBounce  = inBounce,  outBounce  = outBounce,  inOutBounce  = inOutBounce,  outInBounce  = outInBounce\n}\n\n\n\n-- private stuff\n\nlocal function copyTables(destination, keysTable, valuesTable)\n\tvaluesTable = valuesTable or keysTable\n\tlocal mt = getmetatable(keysTable)\n\tif mt and getmetatable(destination) == nil then\n\t\tsetmetatable(destination, mt)\n\tend\n\tfor k,v in pairs(keysTable) do\n\t\tif type(v) == 'table' then\n\t\t\tdestination[k] = copyTables({}, v, valuesTable[k])\n\t\telse\n\t\t\tdestination[k] = valuesTable[k]\n\t\tend\n\tend\n\treturn destination\nend\n\nlocal function checkSubjectAndTargetRecursively(subject, target, path)\n\tpath = path or {}\n\tlocal targetType, newPath\n\tfor k,targetValue in pairs(target) do\n\t\ttargetType, newPath = type(targetValue), copyTables({}, path)\n\t\ttable.insert(newPath, tostring(k))\n\t\tif targetType == 'number' then\n\t\t\tassert(type(subject[k]) == 'number', \"Parameter '\" .. table.concat(newPath,'/') .. \"' is missing from subject or isn't a number\")\n\t\telseif targetType == 'table' then\n\t\t\tcheckSubjectAndTargetRecursively(subject[k], targetValue, newPath)\n\t\telse\n\t\t\tassert(targetType == 'number', \"Parameter '\" .. table.concat(newPath,'/') .. \"' must be a number or table of numbers\")\n\t\tend\n\tend\nend\n\nlocal function checkNewParams(duration, subject, target, easing)\n\tassert(type(duration) == 'number' and duration > 0, \"duration must be a positive number. Was \" .. tostring(duration))\n\tlocal tsubject = type(subject)\n\tassert(tsubject == 'table' or tsubject == 'userdata', \"subject must be a table or userdata. Was \" .. tostring(subject))\n\tassert(type(target)== 'table', \"target must be a table. Was \" .. tostring(target))\n\tassert(type(easing)=='function', \"easing must be a function. Was \" .. tostring(easing))\n\tcheckSubjectAndTargetRecursively(subject, target)\nend\n\nlocal function getEasingFunction(easing)\n\teasing = easing or \"linear\"\n\tif type(easing) == 'string' then\n\t\tlocal name = easing\n\t\teasing = tween.easing[name]\n\t\tif type(easing) ~= 'function' then\n\t\t\terror(\"The easing function name '\" .. name .. \"' is invalid\")\n\t\tend\n\tend\n\treturn easing\nend\n\nlocal function performEasingOnSubject(subject, target, initial, clock, duration, easing)\n\tlocal t,b,c,d\n\tfor k,v in pairs(target) do\n\t\tif type(v) == 'table' then\n\t\t\tperformEasingOnSubject(subject[k], v, initial[k], clock, duration, easing)\n\t\telse\n\t\t\tt,b,c,d = clock, initial[k], v - initial[k], duration\n\t\t\tsubject[k] = easing(t,b,c,d)\n\t\tend\n\tend\nend\n\n-- Tween methods\n\nlocal Tween = {}\nlocal Tween_mt = {__index = Tween}\n\nfunction Tween:set(clock)\n\tassert(type(clock) == 'number', \"clock must be a positive number or 0\")\n\n\tself.initial = self.initial or copyTables({}, self.target, self.subject)\n\tself.clock = clock\n\n\tif self.clock <= 0 then\n\n\t\tself.clock = 0\n\t\tcopyTables(self.subject, self.initial)\n\n\telseif self.clock >= self.duration then -- the tween has expired\n\n\t\tself.clock = self.duration\n\t\tcopyTables(self.subject, self.target)\n\n\telse\n\n\t\tperformEasingOnSubject(self.subject, self.target, self.initial, self.clock, self.duration, self.easing)\n\n\tend\n\n\treturn self.clock >= self.duration\nend\n\nfunction Tween:reset()\n\treturn self:set(0)\nend\n\nfunction Tween:update(dt)\n\tassert(type(dt) == 'number', \"dt must be a number\")\n\treturn self:set(self.clock + dt)\nend\n\n\n-- Public interface\n\nfunction tween.new(duration, subject, target, easing)\n\teasing = getEasingFunction(easing)\n\tcheckNewParams(duration, subject, target, easing)\n\treturn setmetatable({\n\t\tduration  = duration,\n\t\tsubject   = subject,\n\t\ttarget    = target,\n\t\teasing    = easing,\n\t\tclock     = 0\n\t}, Tween_mt)\nend\n\nreturn tween", "sys/modules/opus/ui/blit.lua": "local colors = _G.colors\nlocal _rep   = string.rep\nlocal _sub   = string.sub\n\nlocal Blit = { }\n\nBlit.colorPalette = { }\nBlit.grayscalePalette = { }\n\nfor n = 1, 16 do\n\tBlit.colorPalette[2 ^ (n - 1)]     = _sub(\"0123456789abcdef\", n, n)\n\tBlit.grayscalePalette[2 ^ (n - 1)] = _sub(\"088888878877787f\", n, n)\nend\n\n-- default palette\nBlit.palette = Blit.colorPalette\n\nfunction Blit:init(t, args)\n\tif args then\n\t\tfor k,v in pairs(args) do\n\t\t\tself[k] = v\n\t\tend\n\tend\n\n\tif type(t) == 'string' then\n\t\t-- create a blit from a string\n\t\tself.text, self.bg, self.fg = Blit.toblit(t, args or { })\n\n\telseif type(t) == 'number' then\n\t\t-- create a fixed width blit\n\t\tself.width = t\n\t\tself.text = _rep(' ', self.width)\n\t\tself.bg = _rep(self.palette[args.bg], self.width)\n\t\tself.fg = _rep(self.palette[args.fg], self.width)\n\n\telse\n\t\tself.text = t.text\n\t\tself.bg = t.bg\n\t\tself.fg = t.fg\n\tend\nend\n\nfunction Blit:write(x, text, bg, fg)\n\tself:insert(x, text,\n\t\tbg and _rep(self.palette[bg], #text),\n\t\tfg and _rep(self.palette[fg], #text))\nend\n\nfunction Blit:insert(x, text, bg, fg)\n\tif x <= self.width then\n\t\tlocal width = #text\n\t\tlocal tx, tex\n\n\t\tif x < 1 then\n\t\t\ttx = 2 - x\n\t\t\twidth = width + x - 1\n\t\t\tx = 1\n\t\tend\n\n\t\tif x + width - 1 > self.width then\n\t\t\ttex = self.width - x + (tx or 1)\n\t\t\twidth = tex - (tx or 1) + 1\n\t\tend\n\n\t\tif width > 0 then\n\t\t\tlocal function replace(sstr, rstr)\n\t\t\t\tif tx or tex then\n\t\t\t\t\trstr = _sub(rstr, tx or 1, tex)\n\t\t\t\tend\n\t\t\t\tif x == 1 and width == self.width then\n\t\t\t\t\treturn rstr\n\t\t\t\telseif x == 1 then\n\t\t\t\t\treturn rstr .. _sub(sstr, x + width)\n\t\t\t\telseif x + width > self.width then\n\t\t\t\t\treturn _sub(sstr, 1, x - 1) .. rstr\n\t\t\t\tend\n\t\t\t\treturn _sub(sstr, 1, x - 1) .. rstr .. _sub(sstr, x + width)\n\t\t\tend\n\n\t\t\tself.text = replace(self.text, text)\n\t\t\tif fg then\n\t\t\t\tself.fg = replace(self.fg, fg)\n\t\t\tend\n\t\t\tif bg then\n\t\t\t\tself.bg = replace(self.bg, bg)\n\t\t\tend\n\t\tend\n\tend\nend\n\nfunction Blit:sub(s, e)\n\treturn Blit({\n\t\ttext = self.text:sub(s, e),\n\t\tbg = self.bg:sub(s, e),\n\t\tfg = self.fg:sub(s, e),\n\t})\nend\n\nfunction Blit:wrap(max)\n\tlocal lines = { }\n\tlocal data = self\n\n    repeat\n\t\tif #data.text <= max then\n\t\t\ttable.insert(lines, data)\n\t\t\tbreak\n\t\telseif data.text:sub(max+1, max+1) == ' ' then\n\t\t\ttable.insert(lines, data:sub(1, max))\n\t\t\tdata = data:sub(max + 2)\n\t\telse\n\t\t\tlocal x = data.text:sub(1, max)\n\t\t\tlocal s = x:match('(.*) ') or x\n\t\t\ttable.insert(lines, data:sub(1, #s))\n\t\t\tdata = data:sub(#s + 1)\n\t\tend\n\t\tlocal t = data.text:match('^%s*(.*)')\n\t\tlocal spaces = #data.text - #t\n\t\tif spaces > 0 then\n\t\t\tdata = data:sub(spaces + 1)\n\t\tend\n\tuntil not data.text or #data.text == 0\n\n    return lines\nend\n\n-- convert a string of text to blit format doing color conversion\n-- and processing ansi color sequences\nfunction Blit.toblit(str, cs)\n\tlocal text, fg, bg = '', '', ''\n\n\tif not cs.cbg then\n\t\t-- reset colors\n\t\tcs.rbg = cs.bg or colors.black\n\t\tcs.rfg = cs.fg or colors.white\n\t\t-- current colors\n\t\tcs.cbg = cs.rbg\n\t\tcs.cfg = cs.rfg\n\n\t\tcs.palette = cs.palette or Blit.palette\n\tend\n\n\tstr = str:gsub('(.-)\\027%[([%d;]+)m',\n\t\tfunction(k, seq)\n\t\t\ttext = text .. k\n\t\t\tbg = bg .. string.rep(cs.palette[cs.cbg], #k)\n\t\t\tfg = fg .. string.rep(cs.palette[cs.cfg], #k)\n\t\t\tfor color in string.gmatch(seq, \"%d+\") do\n\t\t\t\tcolor = tonumber(color)\n\t\t\t\tif color == 0 then\n\t\t\t\t\t-- reset to default\n\t\t\t\t\tcs.cfg = cs.rfg\n\t\t\t\t\tcs.cbg = cs.rbg\n\t\t\t\telseif color > 20 then\n\t\t\t\t\tcs.cbg = 2 ^ (color - 21)\n\t\t\t\telse\n\t\t\t\t\tcs.cfg = 2 ^ (color - 1)\n\t\t\t\tend\n\t\t\tend\n\t\t\treturn k\n\t\tend)\n\n\tlocal k = str:sub(#text + 1)\n\treturn text .. k,\n\t\tbg .. string.rep(cs.palette[cs.cbg], #k),\n\t\tfg .. string.rep(cs.palette[cs.cfg], #k)\nend\n\nreturn setmetatable(Blit, {\n\t__call = function(_, ...)\n\t\tlocal obj = setmetatable({ }, { __index = Blit })\n\t\tobj:init(...)\n\t\treturn obj\n\tend\n})\n", "sys/modules/opus/ui/canvas.lua": "local class  = require('opus.class')\nlocal Region = require('opus.ui.region')\nlocal Util   = require('opus.util')\n\nlocal _rep   = string.rep\nlocal _sub   = string.sub\nlocal _gsub  = string.gsub\nlocal colors = _G.colors\n\nlocal Canvas = class()\n\nlocal function genPalette(map)\n\tlocal t = { }\n\tlocal rcolors = Util.transpose(colors)\n\tfor n = 1, 16 do\n\t\tlocal pow = 2 ^ (n - 1)\n\t\tlocal ch = _sub(map, n, n)\n\t\tt[pow] = ch\n\t\tt[rcolors[pow]] = ch\n\tend\n\treturn t\nend\n\nCanvas.colorPalette     = genPalette('0123456789abcdef')\nCanvas.grayscalePalette = genPalette('088888878877787f')\n\n--[[\n\tA canvas can have more lines than canvas.height in order to scroll\n\n\tTODO: finish vertical scrolling\n]]\nfunction Canvas:init(args)\n\tself.bg = colors.black\n\tself.fg = colors.white\n\n\tUtil.merge(self, args)\n\n\tself.x = self.x or 1\n\tself.y = self.y or 1\n\tself.ex = self.x + self.width - 1\n\tself.ey = self.y + self.height - 1\n\n\tif not self.palette then\n\t\tif self.isColor then\n\t\t\tself.palette = Canvas.colorPalette\n\t\telse\n\t\t\tself.palette = Canvas.grayscalePalette\n\t\tend\n\tend\n\n\tself.lines = { }\n\tfor i = 1, self.height do\n\t\tself.lines[i] = { }\n\tend\n\n\tself:clear()\nend\n\nfunction Canvas:move(x, y)\n\tself.x, self.y = x, y\n\tself.ex = self.x + self.width - 1\n\tself.ey = self.y + self.height - 1\n\tif self.parent then\n\t\tself.parent:dirty(true)\n\tend\nend\n\nfunction Canvas:resize(w, h)\n\tself:resizeBuffer(w, h)\n\n\tself.ex = self.x + w - 1\n\tself.ey = self.y + h - 1\n\tself.width = w\n\tself.height = h\nend\n\n-- resize the canvas buffer - not the canvas itself\nfunction Canvas:resizeBuffer(w, h)\n\tfor i = #self.lines + 1, h do\n\t\tself.lines[i] = { }\n\t\tself:clearLine(i)\n\tend\n\n\twhile #self.lines > h do\n\t\ttable.remove(self.lines, #self.lines)\n\tend\n\n\tif w < self.width then\n\t\tfor i = 1, h do\n\t\t\tlocal ln = self.lines[i]\n\t\t\tln.text = _sub(ln.text, 1, w)\n\t\t\tln.fg = _sub(ln.fg, 1, w)\n\t\t\tln.bg = _sub(ln.bg, 1, w)\n\t\tend\n\telseif w > self.width then\n\t\tlocal d = w - self.width\n\t\tlocal text = _rep(' ', d)\n\t\tlocal fg = _rep(self.palette[self.fg], d)\n\t\tlocal bg = _rep(self.palette[self.bg], d)\n\t\tfor i = 1, h do\n\t\t\tlocal ln = self.lines[i]\n\t\t\tln.text = ln.text .. text\n\t\t\tln.fg = ln.fg .. fg\n\t\t\tln.bg = ln.bg .. bg\n\t\t\tln.dirty = true\n\t\tend\n\tend\nend\n\nfunction Canvas:copy()\n\tlocal b = Canvas({\n\t\tx       = self.x,\n\t\ty       = self.y,\n\t\twidth   = self.width,\n\t\theight  = self.height,\n\t\tisColor = self.isColor,\n\t})\n\tfor i = 1, #self.lines do\n\t\tb.lines[i].text = self.lines[i].text\n\t\tb.lines[i].fg = self.lines[i].fg\n\t\tb.lines[i].bg = self.lines[i].bg\n\tend\n\treturn b\nend\n\nfunction Canvas:addLayer(layer)\n\tlayer.parent = self\n\tif not self.children then\n\t\tself.children = { }\n\tend\n\ttable.insert(self.children, 1, layer)\n\treturn layer\nend\n\nfunction Canvas:removeLayer()\n\tfor k, layer in pairs(self.parent.children) do\n\t\tif layer == self then\n\t\t\tself:setVisible(false)\n\t\t\ttable.remove(self.parent.children, k)\n\t\t\tbreak\n\t\tend\n\tend\nend\n\nfunction Canvas:setVisible(visible)\n\tself.visible = visible  -- TODO: use self.active = visible\n\tif not visible and self.parent then\n\t\tself.parent:dirty()\n\t\t-- TODO: set parent's lines to dirty for each line in self\n\tend\nend\n\n-- Push a layer to the top\nfunction Canvas:raise()\n\tif self.parent and self.parent.children then\n\t\tfor k, v in pairs(self.parent.children) do\n\t\t\tif v == self then\n\t\t\t\ttable.insert(self.parent.children, table.remove(self.parent.children, k))\n\t\t\t\tbreak\n\t\t\tend\n\t\tend\n\tend\nend\n\nfunction Canvas:write(x, y, text, bg, fg)\n\tif bg then\n\t\tbg = _rep(self.palette[bg], #text)\n\tend\n\tif fg then\n\t\tfg = _rep(self.palette[fg] or self.palette[1], #text)\n\tend\n\tself:blit(x, y, text, bg, fg)\nend\n\nfunction Canvas:blit(x, y, text, bg, fg)\n\tif y > 0 and y <= #self.lines and x <= self.width then\n\t\tlocal width = #text\n\t\tlocal tx, tex\n\n\t\tif x < 1 then\n\t\t\ttx = 2 - x\n\t\t\twidth = width + x - 1\n\t\t\tx = 1\n\t\tend\n\n\t\tif x + width - 1 > self.width then\n\t\t\ttex = self.width - x + (tx or 1)\n\t\t\twidth = tex - (tx or 1) + 1\n\t\tend\n\n\t\tif width > 0 then\n\t\t\tlocal function replace(sstr, rstr)\n\t\t\t\tif tx or tex then\n\t\t\t\t\trstr = _sub(rstr, tx or 1, tex)\n\t\t\t\tend\n\t\t\t\tif x == 1 and width == self.width then\n\t\t\t\t\treturn rstr\n\t\t\t\telseif x == 1 then\n\t\t\t\t\treturn rstr .. _sub(sstr, x + width)\n\t\t\t\telseif x + width > self.width then\n\t\t\t\t\treturn _sub(sstr, 1, x - 1) .. rstr\n\t\t\t\tend\n\t\t\t\treturn _sub(sstr, 1, x - 1) .. rstr .. _sub(sstr, x + width)\n\t\t\tend\n\n\t\t\tlocal line = self.lines[y]\n\t\t\tline.dirty = true\n\t\t\tline.text = replace(line.text, text)\n\t\t\tif fg then\n\t\t\t\tline.fg = replace(line.fg, fg)\n\t\t\tend\n\t\t\tif bg then\n\t\t\t\tline.bg = replace(line.bg, bg)\n\t\t\tend\n\t\tend\n\tend\nend\n\nfunction Canvas:writeLine(y, text, fg, bg)\n\tif y > 0 and y <= #self.lines then\n\t\tself.lines[y].dirty = true\n\t\tself.lines[y].text = text\n\t\tself.lines[y].fg = fg\n\t\tself.lines[y].bg = bg\n\tend\nend\n\nfunction Canvas:clearLine(y, bg, fg)\n\tfg = _rep(self.palette[fg or self.fg], self.width)\n\tbg = _rep(self.palette[bg or self.bg], self.width)\n\tself:writeLine(y, _rep(' ', self.width), fg, bg)\nend\n\nfunction Canvas:clear(bg, fg)\n\tlocal text = _rep(' ', self.width)\n\tfg = _rep(self.palette[fg or self.fg], self.width)\n\tbg = _rep(self.palette[bg or self.bg], self.width)\n\tfor i = 1, #self.lines do\n\t\tself:writeLine(i, text, fg, bg)\n\tend\nend\n\nfunction Canvas:isDirty()\n\tfor i = 1, #self.lines do\n\t\tif self.lines[i].dirty then\n\t\t\treturn true\n\t\tend\n\tend\nend\n\nfunction Canvas:dirty(includingChildren)\n\tif self.lines then\n\t\tfor i = 1, #self.lines do\n\t\t\tself.lines[i].dirty = true\n\t\tend\n\n\t\tif includingChildren and self.children then\n\t\t\tfor _, child in pairs(self.children) do\n\t\t\t\tchild:dirty(true)\n\t\t\tend\n\t\tend\n\tend\nend\n\nfunction Canvas:clean()\n\tfor i = 1, #self.lines do\n\t\tself.lines[i].dirty = nil\n\tend\nend\n\nfunction Canvas:applyPalette(palette)\n\tlocal lookup = { }\n\tfor n = 1, 16 do\n\t\tlookup[self.palette[2 ^ (n - 1)]] = palette[2 ^ (n - 1)]\n\tend\n\n\tfor _, l in pairs(self.lines) do\n\t\tl.fg = _gsub(l.fg, '%w', lookup)\n\t\tl.bg = _gsub(l.bg, '%w', lookup)\n\t\tl.dirty = true\n\tend\n\n\tself.palette = palette\nend\n\n-- either render directly to the device\n-- or use another canvas as a backing buffer\nfunction Canvas:render(device, doubleBuffer)\n\tself.regions = Region.new(self.x, self.y, self.ex, self.ey)\n\tself:__renderLayers(device, { x = self.x - 1, y = self.y - 1 }, doubleBuffer)\n\n\t-- doubleBuffering to reduce the amount of\n\t-- setCursorPos, blits\n\tif doubleBuffer then\n\t\t--[[\n\t\tlocal drew = false\n\t\tlocal bg = _rep(2,   device.width)\n\t\tfor k,v in pairs(device.lines) do\n\t\t\tif v.dirty then\n\t\t\t\tdevice.device.setCursorPos(device.x, device.y + k - 1)\n\t\t\t\tdevice.device.blit(v.text, v.fg, bg)\n\t\t\t\tdrew = true\n\t\t\tend\n\t\tend\n\t\tif drew then\n\t\t\tlocal c = os.clock()\n\t\t\trepeat until os.clock()-c > .1\n\t\tend\n\t\t]]\n\t\tfor k,v in pairs(device.lines) do\n\t\t\tif v.dirty then\n\t\t\t\tdevice.device.setCursorPos(device.x, device.y + k - 1)\n\t\t\t\tdevice.device.blit(v.text, v.fg, v.bg)\n\t\t\t\tv.dirty = false\n\t\t\tend\n\t\tend\n\tend\nend\n\n-- regions are comprised of absolute values that correspond to the output device.\n-- canvases have coordinates relative to their parent.\n-- canvas layer's stacking order is determined by the position within the array.\n-- layers in the beginning of the array are overlayed by layers further down in\n-- the array.\nfunction Canvas:__renderLayers(device, offset, doubleBuffer)\n\tif self.children then\n\t\tfor i = #self.children, 1, -1 do\n\t\t\tlocal canvas = self.children[i]\n\t\t\tif canvas.visible or canvas.enabled then\n\t\t\t\t-- get the area to render for this layer\n\t\t\t\tcanvas.regions = Region.new(\n\t\t\t\t\tcanvas.x + offset.x - (self.offx or 0),\n\t\t\t\t\tcanvas.y + offset.y - (self.offy or 0),\n\t\t\t\t\tcanvas.ex + offset.x - (self.offx or 0),\n\t\t\t\t\tcanvas.ey + offset.y - (self.offy or 0))\n\n\t\t\t\t-- contain within parent\n\t\t\t\tcanvas.regions:andRegion(self.regions)\n\n\t\t\t\t-- punch out this area from the parent's canvas\n\t\t\t\tself.regions:subRect(\n\t\t\t\t\tcanvas.x + offset.x - (self.offx or 0),\n\t\t\t\t\tcanvas.y + offset.y - (self.offy or 0),\n\t\t\t\t\tcanvas.ex + offset.x - (self.offx or 0),\n\t\t\t\t\tcanvas.ey + offset.y - (self.offy or 0))\n\n\t\t\t\tif #canvas.regions.region > 0 then\n\t\t\t\t\tcanvas:__renderLayers(device, {\n\t\t\t\t\t\tx = canvas.x + offset.x - 1 - (self.offx or 0),\n\t\t\t\t\t\ty = canvas.y + offset.y - 1 - (self.offy or 0),\n\t\t\t\t\t}, doubleBuffer)\n\t\t\t\tend\n\t\t\t\tcanvas.regions = nil\n\t\t\tend\n\t\tend\n\tend\n\n\tfor _,region in ipairs(self.regions.region) do\n\t\tself:__blitRect(device,\n\t\t\t{ x = region[1] - offset.x,\n\t\t\t  y = region[2] - offset.y,\n\t\t\t  ex = region[3] - offset.x,\n\t\t\t  ey = region[4] - offset.y },\n\t\t\t{ x = region[1], y = region[2] },\n\t\t\tdoubleBuffer)\n\tend\n\tself.regions = nil\n\n\tself:clean()\nend\n\nfunction Canvas:__blitRect(device, src, tgt, doubleBuffer)\n\t-- for visualizing updates on the screen\n\t--[[\n\tif Canvas.__visualize or self.visualize then\n\t\tlocal drew\n\t\tlocal t  = _rep(' ', src.ex-src.x + 1)\n\t\tlocal bg = _rep(2,   src.ex-src.x + 1)\n\t\tfor i = 0, src.ey - src.y do\n\t\t\tlocal line = self.lines[src.y + i + (self.offy or 0)]\n\t\t\tif line and line.dirty then\n\t\t\t\tdrew = true\n\t\t\t\tdevice.setCursorPos(tgt.x, tgt.y + i)\n\t\t\t\tdevice.blit(t, bg, bg)\n\t\t\tend\n\t\tend\n\t\tif drew then\n\t\t\tlocal c = os.clock()\n\t\t\trepeat until os.clock()-c > .03\n\t\tend\n\tend\n\t]]\n\tfor i = 0, src.ey - src.y do\n\t\tlocal line = self.lines[src.y + i + (self.offy or 0)]\n\t\tif line and line.dirty then\n\t\t\tlocal t, fg, bg = line.text, line.fg, line.bg\n\t\t\tif src.x > 1 or src.ex < self.ex then\n\t\t\t\tt  = _sub(t, src.x, src.ex)\n\t\t\t\tfg = _sub(fg, src.x, src.ex)\n\t\t\t\tbg = _sub(bg, src.x, src.ex)\n\t\t\tend\n\t\t\tif doubleBuffer then\n\t\t\t\tCanvas.blit(device, tgt.x, tgt.y + i,\n\t\t\t\t\tt, bg, fg)\n\t\t\telse\n\t\t\t\tdevice.setCursorPos(tgt.x, tgt.y + i)\n\t\t\t\tdevice.blit(t, fg, bg)\n\t\t\tend\n\t\tend\n\tend\nend\n\nreturn Canvas\n", "sys/modules/opus/ui/components/Slider.lua": "local class  = require('opus.class')\nlocal UI     = require('opus.ui')\nlocal Util   = require('opus.util')\n\nUI.Slider = class(UI.Window)\nUI.Slider.defaults = {\n\tUIElement = 'Slider',\n\theight = 1,\n\tbarChar = UI.extChars and '\\140' or '-',\n\tbarColor = 'gray',\n\tsliderChar = UI.extChars and '\\143' or '\\124',\n\tsliderColor = 'blue',\n\tsliderFocusColor = 'lightBlue',\n\tleftBorder = UI.extChars and '\\141' or '\\124',\n\trightBorder = UI.extChars and '\\142' or '\\124',\n\tlabelWidth = 0,\n\tvalue = 0,\n\tmin = 0,\n\tmax = 100,\n\tevent = 'slider_update',\n\ttransform = function(v) return Util.round(v, 2) end,\n\taccelerators = {\n\t\tright = 'slide_right',\n\t\tleft = 'slide_left',\n\t}\n}\nfunction UI.Slider:setValue(value)\n\tself.value = self.transform(tonumber(value) or self.min)\n\tself.value = Util.clamp(self.value, self.min, self.max)\n\tself:draw()\nend\n\nfunction UI.Slider:reset() -- form support\n\tself.value = self.min\n\tself:draw()\nend\n\nfunction UI.Slider:focus()\n\tself:draw()\nend\n\nfunction UI.Slider:getSliderWidth()\n\tlocal labelWidth = self.labelWidth > 0 and self.labelWidth + 1\n\treturn self.width - (labelWidth or 0)\nend\n\nfunction UI.Slider:draw()\n\tlocal labelWidth = self.labelWidth > 0 and self.labelWidth + 1\n\tlocal width = self.width - (labelWidth or 0)\n\tlocal range = self.max - self.min\n\tlocal perc = (self.value - self.min) / range\n\tlocal progress = Util.clamp(1 + width * perc, 1, width)\n\n\tlocal bar = self.leftBorder .. string.rep(self.barChar, width - 2) .. self.rightBorder\n\tself:write(1, 1, bar, nil, self.barColor)\n\tself:write(progress, 1, self.sliderChar, nil, self.focused and self.sliderFocusColor or self.sliderColor)\n\tif labelWidth then\n\t\tself:write(self.width - labelWidth + 2, 1, Util.widthify(tostring(self.value), self.labelWidth))\n\tend\nend\n\nfunction UI.Slider:eventHandler(event)\n\tif event.type == \"mouse_down\" or event.type == \"mouse_drag\" then\n\t\tlocal pos = event.x - 1\n\t\tif event.type == 'mouse_down' then\n\t\t\tself.anchor = event.x - 1\n\t\telse\n\t\t\tpos = self.anchor + event.dx\n\t\tend\n\t\tlocal range = self.max - self.min\n\t\tlocal i = pos / (self:getSliderWidth() - 1)\n\t\tself:setValue(self.min + (i * range))\n\t\tself:emit({ type = self.event, value = self.value, element = self })\n\t\treturn true\n\n\telseif event.type == 'slide_left' or event.type == 'slide_right' then\n\t\tlocal range = self.max - self.min\n\t\tlocal step = range / (self:getSliderWidth() - 1)\n\t\tif event.type == 'slide_left' then\n\t\t\tself:setValue(self.value - step)\n\t\telse\n\t\t\tself:setValue(self.value + step)\n\t\tend\n\t\tself:emit({ type = self.event, value = self.value, element = self })\n\t\treturn true\n\tend\nend\n\nfunction UI.Slider.example()\n\treturn UI.Window {\n\t\tUI.Slider {\n\t\t\ty = 2, x = 2, ex = -2,\n\t\t\tmin = 0, max = 1,\n\t\t},\n\t\tUI.Slider {\n\t\t\ty = 4, x = 2, ex = -2,\n\t\t\tmin = -1, max = 1,\n\t\t\tlabelWidth = 5,\n\t\t},\n\t\tUI.Slider {\n\t\t\ty = 6, x = 2, ex = -2,\n\t\t\tmin = 0, max = 100,\n\t\t\tlabelWidth = 3,\n\t\t\ttransform = math.floor,\n\t\t},\n\t}\nend\n", "sys/modules/opus/ui/components/Viewport.lua": "local class = require('opus.class')\nlocal UI    = require('opus.ui')\n\nUI.Viewport = class(UI.Window)\nUI.Viewport.defaults = {\n\tUIElement = 'Viewport',\n\taccelerators = {\n\t\tdown            = 'scroll_down',\n\t\tup              = 'scroll_up',\n\t\thome            = 'scroll_top',\n\t\tleft            = 'scroll_left',\n\t\tright           = 'scroll_right',\n\t\t[ 'end' ]       = 'scroll_bottom',\n\t\tpageUp          = 'scroll_pageUp',\n\t\t[ 'control-b' ] = 'scroll_pageUp',\n\t\tpageDown        = 'scroll_pageDown',\n\t\t[ 'control-f' ] = 'scroll_pageDown',\n\t},\n}\nfunction UI.Viewport:postInit()\n\tif self.showScrollBar then\n\t\tself.scrollBar = UI.ScrollBar()\n\tend\nend\n\nfunction UI.Viewport:setScrollPosition(offy, offx) -- argh - reverse\n\tlocal oldOffy = self.offy\n\tself.offy = math.max(offy, 0)\n\tself.offy = math.min(self.offy, math.max(#self.lines, self.height) - self.height)\n\tif self.offy ~= oldOffy then\n\t\tif self.scrollBar then\n\t\t\tself.scrollBar:draw()\n\t\tend\n\t\tself.offy = offy\n\t\tself:dirty(true)\n\tend\n\n\tlocal oldOffx = self.offx\n\tself.offx = math.max(offx or 0, 0)\n\tself.offx = math.min(self.offx, math.max(#self.lines[1], self.width) - self.width)\n\tif self.offx ~= oldOffx then\n\t\tif self.scrollBar then\n\t\t\t--self.scrollBar:draw()\n\t\tend\n\t\tself.offx = offx or 0\n\t\tself:dirty(true)\n\tend\nend\n\nfunction UI.Viewport:blit(x, y, text, bg, fg)\n\tif y > #self.lines then\n\t\tself:resizeBuffer(self.width, y)\n\tend\n\treturn UI.Window.blit(self, x, y, text, bg, fg)\nend\n\nfunction UI.Viewport:write(x, y, text, bg, fg)\n\tif y > #self.lines then\n\t\tself:resizeBuffer(self.width, y)\n\tend\n\treturn UI.Window.write(self, x, y, text, bg, fg)\nend\n\nfunction UI.Viewport:setViewHeight(h)\n\tif h > #self.lines then\n\t\tself:resizeBuffer(self.width, h)\n\tend\nend\n\nfunction UI.Viewport:reset()\n\tself.offy = 0\n\tfor i = self.height + 1, #self.lines do\n\t\tself.lines[i] = nil\n\tend\nend\n\nfunction UI.Viewport:getViewArea()\n\treturn {\n\t\ty           = (self.offy or 0) + 1,\n\t\theight      = self.height,\n\t\ttotalHeight = #self.lines,\n\t\toffsetY     = self.offy or 0,\n\t}\nend\n\nfunction UI.Viewport:eventHandler(event)\n\tif #self.lines <= self.height then\n\t\treturn\n\tend\n\tif event.type == 'scroll_down' then\n\t\tself:setScrollPosition(self.offy + 1, self.offx)\n\telseif event.type == 'scroll_up' then\n\t\tself:setScrollPosition(self.offy - 1, self.offx)\n\telseif event.type == 'scroll_left' then\n\t\tself:setScrollPosition(self.offy, self.offx - 1)\n\telseif event.type == 'scroll_right' then\n\t\tself:setScrollPosition(self.offy, self.offx + 1)\n\telseif event.type == 'scroll_top' then\n\t\tself:setScrollPosition(0, 0)\n\telseif event.type == 'scroll_bottom' then\n\t\tself:setScrollPosition(10000000, 0)\n\telseif event.type == 'scroll_pageUp' then\n\t\tself:setScrollPosition(self.offy - self.height, self.offx)\n\telseif event.type == 'scroll_pageDown' then\n\t\tself:setScrollPosition(self.offy + self.height, self.offx)\n\telseif event.type == 'scroll_to' then\n\t\tself:setScrollPosition(event.offset, 0)\n\telse\n\t\treturn false\n\tend\n\treturn true\nend\n", "sys/modules/opus/ui/components/WizardPage.lua": "local class = require('opus.class')\nlocal UI    = require('opus.ui')\n\nUI.WizardPage = class(UI.Window)\nUI.WizardPage.defaults = {\n\tUIElement = 'WizardPage',\n\tey = -2,\n}\nfunction UI.WizardPage.validate()\n\treturn true\nend\n", "sys/modules/opus/ui/components/Tabs.lua": "local class = require('opus.class')\nlocal UI    = require('opus.ui')\nlocal Util  = require('opus.util')\n\nUI.Tabs = class(UI.Window)\nUI.Tabs.docs = { }\nUI.Tabs.defaults = {\n\tUIElement = 'Tabs',\n\tselectedBackgroundColor = 'primary',\n\tunselectedBackgroundColor = 'tertiary',\n\tunselectedTextColor = 'lightGray',\n\tselectedTextColor = 'black',\n}\nfunction UI.Tabs:postInit()\n\tself:add(self)\nend\n\nfunction UI.Tabs:add(children)\n\tlocal buttons = { }\n\tfor _,child in pairs(children) do\n\t\tif type(child) == 'table' and child.UIElement and child.UIElement == 'Tab' then\n\t\t\tchild.y = 2\n\t\t\ttable.insert(buttons, {\n\t\t\t\tindex = child.index,\n\t\t\t\ttext = child.title,\n\t\t\t\tevent = 'tab_select',\n\t\t\t\ttabUid = child.uid,\n\t\t\t})\n\t\tend\n\tend\n\n\tif not self.tabBar then\n\t\tself.tabBar = UI.TabBar({\n\t\t\tbuttons = buttons,\n\t\t\tbackgroundColor = self.barBackgroundColor,\n\t\t})\n\telse\n\t\tself.tabBar:addButtons(buttons)\n\tend\n\n\tif self.parent then\n\t\tlocal enabled = self.enabled\n\n\t\t-- don't enable children upon add\n\t\tself.enabled = nil\n\t\tUI.Window.add(self, children)\n\t\tself.enabled = enabled\n\tend\nend\n\nUI.Tabs.docs.selectTab = [[selectTab(TAB)\nMake to the passed tab active.]]\nfunction UI.Tabs:selectTab(tab)\n\tlocal menuItem = Util.find(self.tabBar.children, 'tabUid', tab.uid)\n\tif menuItem then\n\t\tif self.enabled then\n\t\t\tself.tabBar:emit({ type = 'tab_select', button = { uid = menuItem.uid } })\n\t\telse\n\t\t\tlocal previous = Util.find(self.tabBar.children, 'selected', true)\n\t\t\tif previous then\n\t\t\t\tprevious.selected = false\n\t\t\tend\n\t\t\tmenuItem.selected = true\n\t\tend\n\tend\nend\n\nfunction UI.Tabs:setActive(tab, active)\n\tlocal menuItem = Util.find(self.tabBar.children, 'tabUid', tab.uid)\n\tif menuItem then\n\t\tmenuItem.inactive = not active\n\tend\nend\n\nfunction UI.Tabs:enable()\n\tself.enabled = true\n\tself.tabBar:enable()\n\n\tlocal menuItem = Util.find(self.tabBar.children, 'selected', true)\n\tself:enableTab(menuItem.tabUid)\nend\n\nfunction UI.Tabs:enableTab(tabUid, hint)\n\tfor child in self:eachChild() do\n\t\tchild.transitionHint = hint\n\t\tif child.uid == tabUid then\n\t\t\tif not child.enabled then\n\t\t\t\tchild:enable()\n\t\t\tend\n\t\telseif child.UIElement == 'Tab' then\n\t\t\tif child.enabled then\n\t\t\t\tchild:disable()\n\t\t\tend\n\t\tend\n\tend\nend\n\nfunction UI.Tabs:eventHandler(event)\n\tif event.type == 'tab_change' then\n\t\tlocal tab = self:find(event.tab.tabUid)\n\t\tlocal hint = event.current > event.last and 'slideLeft' or 'slideRight'\n\n\t\tself:enableTab(event.tab.tabUid, hint)\n\t\ttab:draw()\n\t\treturn true\n\tend\nend\n\nfunction UI.Tabs.example()\n\treturn UI.Tabs {\n\t\ttab1 = UI.Tab {\n\t\t\tindex = 1,\n\t\t\ttitle = 'tab1',\n\t\t\tentry = UI.TextEntry { y = 3, shadowText = 'text' },\n\t\t},\n\t\ttab2 = UI.Tab {\n\t\t\tindex = 2,\n\t\t\ttitle = 'tab2',\n\t\t\tsubtabs = UI.Tabs {\n\t\t\t\tx = 3, y = 2, ex = -3, ey = -2,\n\t\t\t\ttab1 = UI.Tab {\n\t\t\t\t\tindex = 1,\n\t\t\t\t\ttitle = 'tab4',\n\t\t\t\t\tentry = UI.TextEntry { y = 3, shadowText = 'text' },\n\t\t\t\t},\n\t\t\t\ttab3 = UI.Tab {\n\t\t\t\t\tindex = 2,\n\t\t\t\t\ttitle = 'tab5',\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\ttab3 = UI.Tab {\n\t\t\tindex = 3,\n\t\t\ttitle = 'tab3',\n\t\t},\n\t\tenable = function(self)\n\t\t\tUI.Tabs.enable(self)\n\t\t\tself:setActive(self.tab3, false)\n\t\tend,\n\t}\nend\n", "sys/modules/opus/ui/components/ScrollingGrid.lua": "local class = require('opus.class')\nlocal UI    = require('opus.ui')\nlocal Util  = require('opus.util')\n\nUI.ScrollingGrid = class(UI.Grid)\nUI.ScrollingGrid.defaults = {\n\tUIElement = 'ScrollingGrid',\n\tscrollOffset = 0,\n\tmarginRight = 1,\n}\nfunction UI.ScrollingGrid:postInit()\n\tself.scrollBar = UI.ScrollBar()\nend\n\nfunction UI.ScrollingGrid:drawRows()\n\tUI.Grid.drawRows(self)\n\tself.scrollBar:draw()\nend\n\nfunction UI.ScrollingGrid:getViewArea()\n\tlocal y = 1\n\tif not self.disableHeader then\n\t\ty = y + self.headerHeight\n\tend\n\n\treturn {\n\t\tstatic      = true,                    -- the container doesn't scroll\n\t\ty           = y,                       -- scrollbar Y\n\t\theight      = self.pageSize,           -- viewable height\n\t\ttotalHeight = Util.size(self.values),  -- total height\n\t\toffsetY     = self.scrollOffset,       -- scroll offset\n\t\tfill        = not self.disableHeader and self.headerBackgroundColor,\n\t}\nend\n\nfunction UI.ScrollingGrid:getStartRow()\n\tlocal ts = Util.size(self.values)\n\tif ts < self.pageSize then\n\t\tself.scrollOffset = 0\n\tend\n\treturn self.scrollOffset + 1\nend\n\nfunction UI.ScrollingGrid:setIndex(index)\n\tif index < self.scrollOffset + 1 then\n\t\tself.scrollOffset = index - 1\n\telseif index - self.scrollOffset > self.pageSize then\n\t\tself.scrollOffset = index - self.pageSize\n\tend\n\n\tif self.scrollOffset < 0 then\n\t\tself.scrollOffset = 0\n\telse\n\t\tlocal ts = Util.size(self.values)\n\t\tif self.pageSize + self.scrollOffset + 1 > ts then\n\t\t\tself.scrollOffset = math.max(0, ts - self.pageSize)\n\t\tend\n\tend\n\tUI.Grid.setIndex(self, index)\nend\n\nfunction UI.ScrollingGrid.example()\n\tlocal values = { }\n\tfor i = 1, 20 do\n\t\ttable.insert(values, { key = 'key' .. i, value = 'value' .. i })\n\tend\n\treturn UI.ScrollingGrid {\n\t\tvalues = values,\n\t\tsortColumn = 'key',\n\t\tcolumns = {\n\t\t\t{ heading = 'key', key = 'key' },\n\t\t\t{ heading = 'value', key = 'value' },\n\t\t},\n\t\taccelerators = {\n\t\t\tgrid_select = 'custom_select',\n\t\t}\n\t}\nend", "sys/modules/opus/ui/components/Embedded.lua": "local class    = require('opus.class')\nlocal Event    = require('opus.event')\nlocal Terminal = require('opus.terminal')\nlocal UI       = require('opus.ui')\n\nUI.Embedded = class(UI.Window)\nUI.Embedded.defaults = {\n\tUIElement = 'Embedded',\n\tbackgroundColor = 'black',\n\ttextColor = 'white',\n\tmaxScroll = 100,\n\taccelerators = {\n\t\tup = 'scroll_up',\n\t\tdown = 'scroll_down',\n\t}\n}\nfunction UI.Embedded:layout()\n\tUI.Window.layout(self)\n\n\tif not self.win then\n\t\tlocal t\n\t\tfunction self.render()\n\t\t\tif not t then\n\t\t\t\tt = Event.onTimeout(0, function()\n\t\t\t\t\tt = nil\n\t\t\t\t\tif self.focused then\n\t\t\t\t\t\tself:setCursorPos(self.win.getCursorPos())\n\t\t\t\t\tend\n\t\t\t\t\tself:sync()\n\t\t\t\tend)\n\t\t\tend\n\t\tend\n\t\tself.win = Terminal.window(UI.term.device, self.x, self.y, self.width, self.height, false)\n\t\tself.win.canvas = self\n\t\tself.win.setMaxScroll(self.maxScroll)\n\t\tself.win.setCursorPos(1, 1)\n\t\tself.win.setBackgroundColor(self.backgroundColor)\n\t\tself.win.setTextColor(self.textColor)\n\t\tself.win.clear()\n\tend\nend\n\nfunction UI.Embedded:draw()\n\tself:dirty()\nend\n\nfunction UI.Embedded:focus()\n\t-- allow scrolling\n\tif self.focused then\n\t\tself:setCursorBlink(self.win.getCursorBlink())\n\tend\nend\n\nfunction UI.Embedded:enable()\n\tUI.Window.enable(self)\n\tself.win.setVisible(true)\n\tself:dirty()\nend\n\nfunction UI.Embedded:disable()\n\tself.win.setVisible(false)\n\tUI.Window.disable(self)\nend\n\nfunction UI.Embedded:eventHandler(event)\n\tif event.type == 'scroll_up' then\n\t\tself.win.scrollUp()\n\t\treturn true\n\telseif event.type == 'scroll_down' then\n\t\tself.win.scrollDown()\n\t\treturn true\n\tend\nend\n\nfunction UI.Embedded.example()\n\tlocal Util  = require('opus.util')\n\tlocal term  = _G.term\n\n\treturn UI.Embedded {\n\t\ty = 2, x = 2, ex = -2, ey = -2,\n\t\tenable = function (self)\n\t\t\tUI.Embedded.enable(self)\n\t\t\tEvent.addRoutine(function()\n\t\t\t\tlocal oterm = term.redirect(self.win)\n\t\t\t\tUtil.run(_ENV, '/sys/apps/shell.lua')\n\t\t\t\tterm.redirect(oterm)\n\t\t\tend)\n\t\tend,\n\t\teventHandler = function(self, event)\n\t\t\tif event.type == 'key' then\n\t\t\t\treturn true\n\t\t\tend\n\t\t\treturn UI.Embedded.eventHandler(self, event)\n\t\tend\n\t}\nend\n", "sys/modules/opus/ui/components/Question.lua": "local class = require('opus.class')\nlocal UI    = require('opus.ui')\n\nUI.Question = class(UI.MiniSlideOut)\nUI.Question.defaults = {\n    UIElement = 'Question',\n    accelerators = {\n        y = 'question_yes',\n        n = 'question_no',\n    }\n}\nfunction UI.Question:postInit()\n    local x = self.label and #self.label + 3 or 1\n\n    self.yes_button = UI.Button {\n        x = x,\n        text = 'Yes',\n        backgroundColor = 'primary',\n        event = 'question_yes',\n    }\n    self.no_button = UI.Button {\n        x = x + 5,\n        text = 'No',\n        backgroundColor = 'primary',\n        event = 'question_no',\n    }\nend\n", "sys/modules/opus/ui/components/Wizard.lua": "local class = require('opus.class')\nlocal UI    = require('opus.ui')\nlocal Util  = require('opus.util')\n\nUI.Wizard = class(UI.Window)\nUI.Wizard.defaults = {\n\tUIElement = 'Wizard',\n\tpages = { },\n}\nfunction UI.Wizard:postInit()\n\tself.cancelButton = UI.Button {\n\t\tx = 2, y = -1,\n\t\ttext = 'Cancel',\n\t\tevent = 'cancel',\n\t}\n\tself.previousButton = UI.Button {\n\t\tx = -18, y = -1,\n\t\ttext = '\\17 Back',\n\t\tevent = 'previousView',\n\t}\n\tself.nextButton = UI.Button {\n\t\tx = -9, y = -1,\n\t\ttext = 'Next \\16',\n\t\tevent = 'nextView',\n\t}\n\n\tUtil.merge(self, self.pages)\nend\n\nfunction UI.Wizard:getPages()\n\tlocal t = { }\n\tfor child in self:eachChild() do\n\t\tif type(child) == 'table' and child.UIElement == 'WizardPage' then\n\t\t\ttable.insert(t, child)\n\t\tend\n\tend\n\treturn t\nend\n\nfunction UI.Wizard:getPage(index)\n\tlocal pages = self:getPages()\n\treturn Util.find(pages, 'index', index)\nend\n\nfunction UI.Wizard:enable()\n\tself.enabled = true\n\tself.index = 1\n\tfor child in self:eachChild() do\n\t\tif child.UIElement ~= 'WizardPage' then\n\t\t\tchild:enable()\n\t\telseif child.enabled then\n\t\t\tchild:disable()\n\t\tend\n\tend\n\tlocal initial = self:getPage(1)\n\tself:emit({ type = 'enable_view', next = initial })\nend\n\nfunction UI.Wizard:isViewValid()\n\tlocal currentView = self:getPage(self.index)\n\treturn currentView:validate()\nend\n\nfunction UI.Wizard:eventHandler(event)\n\tif event.type == 'nextView' then\n\t\tlocal currentView = self:getPage(self.index)\n\t\tif self:isViewValid() then\n\t\t\tself.index = self.index + 1\n\t\t\tlocal nextView = self:getPage(self.index)\n\t\t\tcurrentView:emit({ type = 'enable_view', next = nextView, current = currentView })\n\t\tend\n\n\telseif event.type == 'previousView' then\n\t\tlocal currentView = self:getPage(self.index)\n\t\tlocal nextView = self:getPage(self.index - 1)\n\t\tif nextView then\n\t\t\tself.index = self.index - 1\n\t\t\tcurrentView:emit({ type = 'enable_view', prev = nextView, current = currentView })\n\t\tend\n\t\treturn true\n\n\telseif event.type == 'wizard_complete' then\n\t\tif self:isViewValid() then\n\t\t\tself:emit({ type = 'accept' })\n\t\tend\n\n\telseif event.type == 'enable_view' then\n\t\tlocal current = event.next or event.prev\n\t\tif not current then error('property \"index\" is required on wizard pages') end\n\t\tlocal hint\n\n\t\tif event.current then\n\t\t\tif event.next then\n\t\t\t\thint = 'slideLeft'\n\t\t\telseif event.prev then\n\t\t\t\thint = 'slideRight'\n\t\t\tend\n\t\t\tevent.current:disable()\n\t\tend\n\n\t\tif self:getPage(self.index - 1) then\n\t\t\tself.previousButton:enable()\n\t\telse\n\t\t\tself.previousButton:disable()\n\t\tend\n\n\t\tif self:getPage(self.index + 1) then\n\t\t\tself.nextButton.text = 'Next \\16'\n\t\t\tself.nextButton.event = 'nextView'\n\t\telse\n\t\t\tself.nextButton.text = 'Accept'\n\t\t\tself.nextButton.event = 'wizard_complete'\n\t\tend\n\t\t-- a new current view\n\t\tcurrent.transitionHint = hint\n\t\tcurrent:enable()\n\t\tcurrent:emit({ type = 'view_enabled', view = current })\n\t\tself:draw()\n\tend\nend\n\nfunction UI.Wizard.example()\n\treturn UI.Wizard {\n\t\tey = -2,\n\t\tsplash = UI.WizardPage {\n\t\t\tindex = 1,\n\t\t\tintro = UI.TextArea {\n\t\t\t\tinactive = true,\n\t\t\t\tx = 3, ex = -3, y = 2, ey = -2,\n\t\t\t\tvalue = 'sample text',\n\t\t\t},\n\t\t},\n\t\tlabel = UI.WizardPage {\n\t\t\tindex = 2,\n\t\t\tintro = UI.TextArea {\n\t\t\t\tinactive = true,\n\t\t\t\tx = 3, ex = -3, y = 2, ey = -2,\n\t\t\t\tvalue = 'sample more text',\n\t\t\t},\n\t\t},\n\t\tpassword = UI.WizardPage {\n\t\t\tindex = 3,\n\t\t\ttext = UI.TextEntry {\n\t\t\t\tx = 12, ex = -3, y = 2,\n\t\t\t\tshadowText = 'tet',\n\t\t\t},\n\t\t},\n\t}\nend\n", "sys/modules/opus/ui/components/FlatButton.lua": "local class = require('opus.class')\nlocal UI    = require('opus.ui')\n\nUI.FlatButton = class(UI.Button)\nUI.FlatButton.defaults = {\n\tUIElement = 'FlatButton',\n\ttextColor = 'black',\n\ttextFocusColor = 'white',\n\tnoPadding = true,\n}\nfunction UI.FlatButton:setParent()\n\tself.backgroundColor = self.parent:getProperty('backgroundColor')\n\tself.backgroundFocusColor = self.backgroundColor\n\n\tUI.Button.setParent(self)\nend\n", "sys/modules/opus/ui/components/ProgressBar.lua": "local class = require('opus.class')\nlocal UI    = require('opus.ui')\n\nUI.ProgressBar = class(UI.Window)\nUI.ProgressBar.defaults = {\n\tUIElement = 'ProgressBar',\n\tbackgroundColor = 'gray',\n\theight = 1,\n\tprogressColor = 'lime',\n\tprogressChar = UI.extChars and '\\153' or ' ',\n\tfillChar = ' ',\n\tfillColor = 'gray',\n\ttextColor = 'green',\n\tvalue = 0,\n}\nfunction UI.ProgressBar:draw()\n\tlocal width = math.ceil(self.value / 100 * self.width)\n\n\tself:fillArea(width + 1, 1, self.width - width, self.height, self.fillChar, nil, self.fillColor)\n\tself:fillArea(1, 1, width, self.height, self.progressChar, self.progressColor)\nend\n\nfunction UI.ProgressBar.example()\n\treturn UI.ProgressBar {\n\t\tx = 2, ex = -2, y = 2, height = 2,\n\t\tfocus = function() end,\n\t\tenable = function(self)\n\t\t\trequire('opus.event').onInterval(.25, function()\n\t\t\t\tself.value = self.value == 100 and 0 or self.value + 5\n\t\t\t\tself:draw()\n\t\t\t\tself:sync()\n\t\t\tend)\n\t\t\treturn UI.ProgressBar.enable(self)\n\t\tend\n\t}\nend\n", "sys/modules/opus/ui/components/TextEntry.lua": "local class = require('opus.class')\nlocal entry = require('opus.entry')\nlocal UI    = require('opus.ui')\nlocal Util  = require('opus.util')\n\nlocal _rep   = string.rep\n\nlocal function transform(directive)\n\tlocal transforms = {\n\t\tlowercase = string.lower,\n\t\tuppercase = string.upper,\n\t\tnumber    = tonumber,\n\t}\n\treturn transforms[directive]\nend\n\nUI.TextEntry = class(UI.Window)\nUI.TextEntry.docs = { }\nUI.TextEntry.defaults = {\n\tUIElement = 'TextEntry',\n\tshadowText = '',\n\tfocused = false,\n\ttextColor = 'white',\n\tshadowTextColor = 'gray',\n\tmarkBackgroundColor = 'gray',\n\tbackgroundColor = 'black',\n\tbackgroundFocusColor = 'black',\n\theight = 1,\n\tcursorBlink = true,\n\taccelerators = {\n\t\t[ 'control-c' ] = 'copy',\n\t}\n}\nfunction UI.TextEntry:postInit()\n\tself.entry = entry({ limit = self.limit, offset = 2, transform = transform(self.transform) })\nend\n\nfunction UI.TextEntry:layout()\n\tUI.Window.layout(self)\n\tself.entry.width = self.width - 2\nend\n\nfunction UI.TextEntry:setValue(value)\n\tself.value = value\n\tself.entry:unmark()\n\tself.entry.value = value\n\tself.entry:updateScroll()\nend\n\nfunction UI.TextEntry:setPosition(pos)\n\tself.entry.pos = pos\n\tself.entry.value = self.value -- WHY HERE ?\n\tself.entry:updateScroll()\nend\n\nfunction UI.TextEntry:draw()\n\tlocal bg = self.backgroundColor\n\tlocal tc = self.textColor\n\tif self.focused then\n\t\tbg = self.backgroundFocusColor\n\tend\n\n\tlocal text = tostring(self.value or '')\n\tif #text > 0 then\n\t\tif self.entry.scroll > 0 then\n\t\t\ttext = text:sub(1 + self.entry.scroll)\n\t\tend\n\t\tif self.mask then\n\t\t\ttext = _rep('*', #text)\n\t\tend\n\telse\n\t\ttc = self.shadowTextColor\n\t\ttext = self.shadowText\n\tend\n\n\tlocal ss = self.entry.scroll > 0 and '\\183' or ' '\n\tself:write(2, 1, Util.widthify(text, self.width - 2) .. ' ', bg, tc)\n\tself:write(1, 1, ss, bg, self.shadowTextColor)\n\n\tif self.entry.mark.active then\n\t\tlocal tx = math.max(self.entry.mark.x - self.entry.scroll, 0)\n\t\tlocal tex = self.entry.mark.ex - self.entry.scroll\n\n\t\tif tex > self.width - 2 then -- unsure about this\n\t\t\ttex = self.width - 2 - tx\n\t\tend\n\n\t\tif tx ~= tex then\n\t\t\tself:write(tx + 2, 1, text:sub(tx + 1, tex), self.markBackgroundColor, tc)\n\t\tend\n\tend\n\tif self.focused then\n\t\tself:setCursorPos(self.entry.pos - self.entry.scroll + 2, 1)\n\tend\nend\n\nUI.TextEntry.docs.reset = [[reset()\nClears the value and resets the cursor.]]\nfunction UI.TextEntry:reset()\n\tself.entry:reset()\n\tself.value = nil--''\n\tself:draw()\n\tself:updateCursor()\nend\n\nfunction UI.TextEntry:updateCursor()\n\tself:setCursorPos(self.entry.pos - self.entry.scroll + 2, 1)\nend\n\nfunction UI.TextEntry:markAll()\n\tself.entry:markAll()\nend\n\nfunction UI.TextEntry:focus()\n\tself:draw()\nend\n\nfunction UI.TextEntry:eventHandler(event)\n\tlocal text = self.value\n\tself.entry.value = text\n\tif event.ie and self.entry:process(event.ie) then\n\t\tif self.entry.textChanged then\n\t\t\tlocal changed = self.value ~= self.entry.value\n\t\t\tself.value = self.entry.value\n\t\t\tself:draw()\n\t\t\tif changed then\n\t\t\t\t-- we get entry.textChanged when marking is updated\n\t\t\t\t-- no need to emit in that case\n\t\t\t\tself:emit({ type = 'text_change', text = self.value, element = self })\n\t\t\tend\n\t\telseif self.entry.posChanged then\n\t\t\tself:updateCursor()\n\t\tend\n\t\treturn true\n\tend\n\n\treturn false\nend\n\nfunction UI.TextEntry.example()\n\treturn UI.Window {\n\t\ttext = UI.TextEntry {\n\t\t\tx = 2, y = 2,\n\t\t\twidth = 12,\n\t\t\tlimit = 36,\n\t\t\tshadowText = 'normal',\n\t\t},\n\t\tupper = UI.TextEntry {\n\t\t\tx = 2, y = 3,\n\t\t\twidth = 12,\n\t\t\tlimit = 36,\n\t\t\tshadowText = 'upper',\n\t\t\ttransform = 'uppercase',\n\t\t},\n\t\tlower = UI.TextEntry {\n\t\t\tx = 2, y = 4,\n\t\t\twidth = 12,\n\t\t\tlimit = 36,\n\t\t\tshadowText = 'lower',\n\t\t\ttransform = 'lowercase',\n\t\t},\n\t\tnumber = UI.TextEntry {\n\t\t\tx = 2, y = 5,\n\t\t\twidth = 12,\n\t\t\tlimit = 36,\n\t\t\ttransform = 'number',\n\t\t\tshadowText = 'number',\n\t\t},\n\t}\nend\n", "sys/modules/opus/ui/components/Tab.lua": "local class = require('opus.class')\nlocal UI    = require('opus.ui')\n\nUI.Tab = class(UI.Window)\nUI.Tab.defaults = {\n\tUIElement = 'Tab',\n\ttitle = 'tab',\n\ty = 2,\n}\n\nfunction UI.Tab:draw()\n\tif not self.noFill then\n\t\tself:fillArea(1, 1, self.width, self.height, string.rep('\\127', self.width), colors.black, colors.gray)\n\tend\n\tself:drawChildren()\nend\n\nfunction UI.Tab:enable()\n\tUI.Window.enable(self)\n\tself:emit({ type = 'tab_activate', activated = self })\nend\n", "sys/modules/opus/ui/components/Chooser.lua": "local class = require('opus.class')\nlocal UI    = require('opus.ui')\nlocal Util  = require('opus.util')\n\nlocal colors = _G.colors\n\nUI.Chooser = class(UI.Window)\nUI.Chooser.defaults = {\n\tUIElement = 'Chooser',\n\tchoices = { },\n\tnochoice = 'Select',\n\tbackgroundFocusColor = colors.lightGray,\n\ttextInactiveColor = colors.gray,\n\tleftIndicator = UI.extChars and '\\171' or '<',\n\trightIndicator = UI.extChars and '\\187' or '>',\n\theight = 1,\n\taccelerators = {\n\t\t[ ' ' ] = 'choice_next',\n\t\tright = 'choice_next',\n\t\tleft  = 'choice_prev',\n\t}\n}\nfunction UI.Chooser:layout()\n\tif not self.width and not self.ex then\n\t\tself.width = 1\n\t\tfor _,v in pairs(self.choices) do\n\t\t\tif #v.name > self.width then\n\t\t\t\tself.width = #v.name\n\t\t\tend\n\t\tend\n\t\tself.width = self.width + 4\n\tend\n\tUI.Window.layout(self)\nend\n\nfunction UI.Chooser:draw()\n\tlocal bg = self.focused and self.backgroundFocusColor or self.backgroundColor\n\tlocal fg = self.inactive and self.textInactiveColor or self.textColor\n\tlocal choice = Util.find(self.choices, 'value', self.value)\n\tlocal value = choice and choice.name or self.nochoice\n\n\tself:write(1, 1, self.leftIndicator, self.backgroundColor, colors.black)\n\tself:write(2, 1, ' ' .. Util.widthify(tostring(value), self.width - 4) .. ' ', bg, fg)\n\tself:write(self.width, 1, self.rightIndicator, self.backgroundColor, colors.black)\nend\n\nfunction UI.Chooser:focus()\n\tself:draw()\nend\n\nfunction UI.Chooser:eventHandler(event)\n\tif event.type == 'choice_next' then\n\t\tlocal _,k = Util.find(self.choices, 'value', self.value)\n\t\tlocal choice\n\t\tif not k then k = 0 end\n\t\tif k and k < #self.choices then\n\t\t\tchoice = self.choices[k + 1]\n\t\telse\n\t\t\tchoice = self.choices[1]\n\t\tend\n\t\tself.value = choice.value\n\t\tself:emit({ type = 'choice_change', value = self.value, element = self, choice = choice })\n\t\tself:draw()\n\t\treturn true\n\n\telseif event.type == 'choice_prev' then\n\t\tlocal _,k = Util.find(self.choices, 'value', self.value)\n\t\tlocal choice\n\t\tif k and k > 1 then\n\t\t\tchoice = self.choices[k - 1]\n\t\telse\n\t\t\tchoice = self.choices[#self.choices]\n\t\tend\n\t\tself.value = choice.value\n\t\tself:emit({ type = 'choice_change', value = self.value, element = self, choice = choice })\n\t\tself:draw()\n\t\treturn true\n\n\telseif event.type == 'mouse_click' or event.type == 'mouse_doubleclick' then\n\t\tif event.x == 1 then\n\t\t\tself:emit({ type = 'choice_prev' })\n\t\t\treturn true\n\t\telseif event.x == self.width then\n\t\t\tself:emit({ type = 'choice_next' })\n\t\t\treturn true\n\t\tend\n\tend\nend\n\nfunction UI.Chooser.example()\n\treturn UI.Window {\n\t\ta = UI.Chooser {\n\t\t\tx = 2, y = 2,\n\t\t\tchoices = {\n\t\t\t\t{ name = 'choice1', value = 'value1' },\n\t\t\t\t{ name = 'choice2', value = 'value2' },\n\t\t\t\t{ name = 'choice3', value = 'value3' },\n\t\t\t},\n\t\t\tvalue = 'value2',\n\t\t},\n\t\tb = UI.Chooser {\n\t\t\tx = 2, y = 4,\n\t\t\tchoices = {\n\t\t\t\t{ name = 'choice1', value = 'value1' },\n\t\t\t\t{ name = 'choice2', value = 'value2' },\n\t\t\t\t{ name = 'choice3', value = 'value3' },\n\t\t\t},\n\t\t}\n\t}\nend\n", "sys/modules/opus/ui/components/Throttle.lua": "local class = require('opus.class')\nlocal UI    = require('opus.ui')\n\nlocal colors = _G.colors\nlocal os     = _G.os\n\nUI.Throttle = class(UI.Window)\nUI.Throttle.defaults = {\n\tUIElement = 'Throttle',\n\tbackgroundColor = colors.gray,\n\tbordercolor = colors.cyan,\n\theight = 4,\n\twidth = 10,\n\ttimeout = .075,\n\tctr = 0,\n\timage = {\n\t\t'  //)    (O )~@ &~&-( ?Q        ',\n\t\t'  //)    (O )- @  \\\\-( ?)  &&    ',\n\t\t'  //)    (O ), @  \\\\-(?)     &&  ',\n\t\t'  //)    (O ). @  \\\\-d )      (@ '\n\t}\n}\nfunction UI.Throttle:layout()\n\tself.x = math.ceil((self.parent.width - self.width) / 2)\n\tself.y = math.ceil((self.parent.height - self.height) / 2)\n\tself:reposition(self.x, self.y, self.width, self.height)\nend\n\nfunction UI.Throttle:enable()\n\tself.c = os.clock()\n\tself.ctr = 0\nend\n\nfunction UI.Throttle:update()\n\tlocal cc = os.clock()\n\tif cc > self.c + self.timeout then\n\t\tos.sleep(0)\n\t\tself.c = os.clock()\n\t\tself.enabled = true\n\t\tself:clear(self.borderColor)\n\t\tlocal image = self.image[self.ctr + 1]\n\t\tlocal width = self.width - 2\n\t\tfor i = 0, #self.image do\n\t\t\tself:write(2, i + 1, image:sub(width * i + 1, width * i + width),\n\t\t\t\tself.backgroundColor, self.textColor)\n\t\tend\n\n\t\tself.ctr = (self.ctr + 1) % #self.image\n\n\t\tself:sync()\n\tend\nend\n\nfunction UI.Throttle.example()\n\treturn UI.Window {\n\t\tbutton1 = UI.Button {\n\t\t\tx = 2, y = 2,\n\t\t\ttext = 'Test',\n\t\t},\n\t\tthrottle = UI.Throttle {\n\t\t\ttextColor = colors.yellow,\n\t\t\tborderColor = colors.green,\n\t\t},\n\t\teventHandler = function (self, event)\n\t\t\tif event.type == 'button_press' then\n\t\t\t\tfor _ = 1, 40 do\n\t\t\t\t\tself.throttle:update()\n\t\t\t\t\tos.sleep(.05)\n\t\t\t\tend\n\t\t\t\tself.throttle:disable()\n\t\t\tend\n\t\tend,\n\t}\nend\n", "sys/modules/opus/ui/components/VerticalMeter.lua": "local class = require('opus.class')\nlocal UI    = require('opus.ui')\n\nUI.VerticalMeter = class(UI.Window)\nUI.VerticalMeter.defaults = {\n\tUIElement = 'VerticalMeter',\n\tbackgroundColor = 'gray',\n\tmeterColor = 'lime',\n\twidth = 1,\n\tvalue = 0,\n}\nfunction UI.VerticalMeter:draw()\n\tlocal height = self.height - math.ceil(self.value / 100 * self.height)\n\tself:clear()\n\tself:clearArea(1, height + 1, self.width, self.height, self.meterColor)\nend\n\nfunction UI.VerticalMeter.example()\n\treturn UI.VerticalMeter {\n\t\tx = 2, width = 3, y = 2, ey = -2,\n\t\tfocus = function() end,\n\t\tenable = function(self)\n\t\t\trequire('opus.event').onInterval(.25, function()\n\t\t\t\tself.value = self.value == 100 and 0 or self.value + 5\n\t\t\t\tself:draw()\n\t\t\t\tself:sync()\n\t\t\tend)\n\t\t\treturn UI.VerticalMeter.enable(self)\n\t\tend\n\t}\nend\n", "sys/modules/opus/ui/components/DropMenu.lua": "local class = require('opus.class')\nlocal UI    = require('opus.ui')\nlocal Util  = require('opus.util')\n\nUI.DropMenu = class(UI.MenuBar)\nUI.DropMenu.defaults = {\n\tUIElement = 'DropMenu',\n\tbackgroundColor = 'white',\n\tbuttonClass = 'DropMenuItem',\n}\nfunction UI.DropMenu:layout()\n\tUI.MenuBar.layout(self)\n\n\tlocal maxWidth = 1\n\tfor y,child in ipairs(self.children) do\n\t\tchild.x = 1\n\t\tchild.y = y\n\t\tif #(child.text or '') > maxWidth then\n\t\t\tmaxWidth = #child.text\n\t\tend\n\tend\n\tfor _,child in ipairs(self.children) do\n\t\tchild.width = maxWidth + 2\n\t\tif child.spacer then\n\t\t\tchild.inactive = true\n\t\t\tchild.text = string.rep('-', child.width - 2)\n\t\tend\n\tend\n\n\tself.height = #self.children + 1\n\tself.width = maxWidth + 2\n\n\tif self.x + self.width > self.parent.width then\n\t\tself.x = self.parent.width - self.width + 1\n\tend\n\n\tself:reposition(self.x, self.y, self.width, self.height)\nend\n\nfunction UI.DropMenu:enable()\n\tlocal menuBar = self.parent:find(self.menuUid)\n\tlocal hasActive\n\n\tfor _,c in pairs(self.children) do\n\t\tif not c.spacer and menuBar then\n\t\t\tc.inactive = not menuBar:getActive(c)\n\t\tend\n\t\tif not c.inactive then\n\t\t\thasActive = true\n\t\tend\n\tend\n\n\t-- jump through a lot of hoops if all selections are inactive\n\t-- there's gotta be a better way\n\t-- lots of exception code just to handle drop menus\n\tself.focus = not hasActive and function() end\n\n\tUI.Window.enable(self)\n\tif self.focus then\n\t\tself:setFocus(self)\n\telse\n\t\tself:focusFirst()\n\tend\n\tself:draw()\nend\n\nfunction UI.DropMenu:disable()\n\tUI.Window.disable(self)\n\tself:remove()\nend\n\nfunction UI.DropMenu:eventHandler(event)\n\tif event.type == 'focus_lost' and self.enabled then\n\t\tif not (Util.contains(self.children, event.focused) or event.focused == self) then\n\t\t\tself:disable()\n\t\tend\n\telseif event.type == 'mouse_out' and self.enabled then\n\t\tself:disable()\n\t\tself:setFocus(self.parent:find(self.lastFocus))\n\telse\n\t\treturn UI.MenuBar.eventHandler(self, event)\n\tend\n\treturn true\nend\n\nfunction UI.DropMenu.example()\n\treturn UI.MenuBar {\n\t\tbuttons = {\n\t\t\t{ text = 'File', dropdown = {\n\t\t\t\t\t{ text = 'Run',            event = 'run' },\n\t\t\t\t\t{ text = 'Shell        s', event = 'shell'  },\n\t\t\t\t\t{ spacer = true },\n\t\t\t\t\t{ text = 'Quit        ^q', event = 'quit'   },\n\t\t\t} },\n\t\t\t{ text = 'Edit', dropdown = {\n\t\t\t\t{ text = 'Copy',           event = 'run' },\n\t\t\t\t{ text = 'Paste        s', event = 'shell'  },\n\t\t\t} },\n\t\t\t{ text = '\\187',\n\t\t\t\tx = -3,\n\t\t\t\tdropdown = {\n\t\t\t\t\t{ text = 'Associations', event = 'associate' },\n\t\t\t} },\n\t\t}\n\t}\nend\n", "sys/modules/opus/ui/components/TitleBar.lua": "local class = require('opus.class')\nlocal UI    = require('opus.ui')\n\nUI.TitleBar = class(UI.Window)\nUI.TitleBar.defaults = {\n\tUIElement = 'TitleBar',\n\theight = 1,\n\ttitle = '',\n\tframeChar = UI.extChars and '\\140' or '-',\n\tcloseInd = UI.extChars and '\\215' or '*',\n}\nfunction UI.TitleBar:draw()\n\tself:fillArea(2, 1, self.width - 2, 1, self.frameChar)\n\tself:centeredWrite(1, string.format(' %s ', self.title))\n\tif self.previousPage or self.event then\n\t\tself:write(self.width - 1, 1, ' ' .. self.closeInd)\n\tend\nend\n\nfunction UI.TitleBar:eventHandler(event)\n\tif event.type == 'mouse_click' then\n\t\tif (self.previousPage or self.event) and event.x == self.width then\n\t\t\tif self.event then\n\t\t\t\tself:emit({ type = self.event, element = self })\n\t\t\telseif type(self.previousPage) == 'string' or\n\t\t\t\t type(self.previousPage) == 'table' then\n\t\t\t\tUI:setPage(self.previousPage)\n\t\t\telse\n\t\t\t\tUI:setPreviousPage()\n\t\t\tend\n\t\t\treturn true\n\t\tend\n\n\telseif event.type == 'mouse_down' then\n\t\tself.anchor = { x = event.x, y = event.y, ox = self.parent.x, oy = self.parent.y, h = self.parent.height }\n\n\telseif event.type == 'mouse_drag' then\n\t\tif self.expand == 'height' then\n\t\t\tlocal d = event.dy\n\t\t\tif self.anchor.h - d > 0 and self.anchor.oy + d > 0 then\n\t\t\t\tself.parent:reposition(self.parent.x, self.anchor.oy + event.dy, self.width, self.anchor.h - d)\n\t\t\tend\n\n\t\telseif self.moveable then\n\t\t\tlocal d = event.dy\n\t\t\tif self.anchor.oy + d > 0 and self.anchor.oy + d <= self.parent.parent.height then\n\t\t\t\tself.parent:move(self.anchor.ox + event.dx, self.anchor.oy + event.dy)\n\t\t\tend\n\t\tend\n\tend\nend\n\nfunction UI.TitleBar.example()\n\treturn UI.Window {\n\t\twin1 = UI.Window {\n\t\t\tx = 9, y = 2, ex = -7, ey = -3,\n\t\t\tbackgroundColor = 'green',\n\t\t\ttitleBar = UI.TitleBar {\n\t\t\t\ttitle = 'A really, really, really long title',  moveable = true,\n\t\t\t},\n\t\t\tbutton1 = UI.Button {\n\t\t\t\tx = 2, y = 3,\n\t\t\t\ttext = 'Press',\n\t\t\t},\n\t\t\tfocus = function (self)\n\t\t\t\tself:raise()\n\t\t\tend,\n\t\t},\n\t\twin2 = UI.Window {\n\t\t\tx = 7, y = 3, ex = -9, ey = -2,\n\t\t\tbackgroundColor = 'orange',\n\t\t\ttitleBar = UI.TitleBar {\n\t\t\t\ttitle = 'test', moveable = true,\n\t\t\t\tevent = 'none',\n\t\t\t},\n\t\t\tbutton1 = UI.Button {\n\t\t\t\tx = 2, y = 3,\n\t\t\t\ttext = 'Press',\n\t\t\t},\n\t\t\tfocus = UI.Window.raise,\n\t\t},\n\t\tdraw = function(self, isBG)\n\t\t\tfor i = 1, self.height do\n\t\t\t\tself:write(1, i, self.filler or '')\n\t\t\tend\n\t\t\tif not isBG then\n\t\t\t\tfor _,v in pairs(self.children) do\n\t\t\t\t\tv:draw()\n\t\t\t\tend\n\t\t\tend\n\t\tend,\n\t\tenable = function (self)\n\t\t\trequire('opus.event').onInterval(.5, function()\n\t\t\t\tself.filler = string.rep(string.char(math.random(33, 126)), self.width)\n\t\t\t\tself:draw(true)\n\t\t\t\tself:sync()\n\t\t\tend)\n\t\t\tUI.Window.enable(self)\n\t\tend\n\t}\nend\n", "sys/modules/opus/ui/components/Grid.lua": "local class = require('opus.class')\nlocal UI    = require('opus.ui')\nlocal Util  = require('opus.util')\n\nlocal os     = _G.os\nlocal _rep   = string.rep\n\nlocal function safeValue(v)\n\tlocal t = type(v)\n\tif t == 'string' or t == 'number' then\n\t\treturn v\n\tend\n\treturn tostring(v)\nend\n\nlocal Writer = class()\nfunction Writer:init(element, y)\n\tself.element = element\n\tself.y = y\n\tself.x = 1\nend\n\nfunction Writer:write(s, width, align, bg, fg)\n\ts = Util.widthify(s, width, align)\n\tself.element:write(self.x, self.y, s, bg, fg)\n\tself.x = self.x + width\nend\n\nfunction Writer:finish(bg)\n\tif self.x <= self.element.width then\n\t\tself.element:write(self.x, self.y, _rep(' ', self.element.width - self.x + 1), bg)\n\tend\n\tself.x = 1\n\tself.y = self.y + 1\nend\n\n--[[-- Grid --]]--\nUI.Grid = class(UI.Window)\nUI.Grid.defaults = {\n\tUIElement = 'Grid',\n\tindex = 1,\n\tinverseSort = false,\n\tdisableHeader = false,\n\theaderHeight = 1,\n\tmarginRight = 0,\n\ttextColor = 'white',\n\ttextSelectedColor = 'white',\n\tbackgroundColor = 'black',\n\tbackgroundSelectedColor = 'gray',\n\theaderBackgroundColor = 'primary',\n\theaderTextColor = 'white',\n\theaderSortColor = 'yellow',\n\tunfocusedTextSelectedColor = 'white',\n\tunfocusedBackgroundSelectedColor = 'gray',\n\tfocusIndicator = UI.extChars and '\\26' or '>',\n\tsortIndicator = ' ',\n\tinverseSortIndicator = UI.extChars and '\\24' or '^',\n\tvalues = { },\n\tcolumns = { },\n\taccelerators = {\n\t\tenter           = 'key_enter',\n\t\t[ 'control-c' ] = 'copy',\n\t\tdown            = 'scroll_down',\n\t\tup              = 'scroll_up',\n\t\thome            = 'scroll_top',\n\t\t[ 'end' ]       = 'scroll_bottom',\n\t\tpageUp          = 'scroll_pageUp',\n\t\t[ 'control-b' ] = 'scroll_pageUp',\n\t\tpageDown        = 'scroll_pageDown',\n\t\t[ 'control-f' ] = 'scroll_pageDown',\n\t},\n}\nfunction UI.Grid:layout()\n\tUI.Window.layout(self)\n\n\tfor _,c in pairs(self.columns) do\n\t\tc.cw = c.width\n\t\tif not c.heading then\n\t\t\tc.heading = ''\n\t\tend\n\tend\n\n\tself:update()\n\n\tif not self.pageSize then\n\t\tif self.disableHeader then\n\t\t\tself.pageSize = self.height\n\t\telse\n\t\t\tself.pageSize = self.height - self.headerHeight\n\t\tend\n\tend\nend\n\nfunction UI.Grid:resize()\n\tUI.Window.resize(self)\n\n\tif self.disableHeader then\n\t\tself.pageSize = self.height\n\telse\n\t\tself.pageSize = self.height - self.headerHeight\n\tend\n\tself:adjustWidth()\nend\n\nfunction UI.Grid:adjustWidth()\n\tlocal t = { }        -- cols without width\n\tlocal w = self.width - #self.columns - 1 - self.marginRight -- width remaining\n\n\tfor _,c in pairs(self.columns) do\n\t\tif c.width then\n\t\t\tc.cw = c.width\n\t\t\tw = w - c.cw\n\t\telse\n\t\t\ttable.insert(t, c)\n\t\tend\n\tend\n\n\tif #t == 0 then\n\t\treturn\n\tend\n\n\tif #t == 1 then\n\t\tt[1].cw = #(t[1].heading or '')\n\t\tt[1].cw = math.max(t[1].cw, w)\n\t\treturn\n\tend\n\n\tif not self.autospace then\n\t\tfor k,c in ipairs(t) do\n\t\t\tc.cw = math.floor(w / (#t - k + 1))\n\t\t\tw = w - c.cw\n\t\tend\n\n\telse\n\t\tfor _,c in ipairs(t) do\n\t\t\tc.cw = #(c.heading or '')\n\t\t\tw = w - c.cw\n\t\tend\n\t\t-- adjust the size to the length of the value\n\t\tfor key,row in pairs(self.values) do\n\t\t\tif w <= 0 then\n\t\t\t\tbreak\n\t\t\tend\n\t\t\trow = self:getDisplayValues(row, key)\n\t\t\tfor _,col in pairs(t) do\n\t\t\t\tlocal value = row[col.key]\n\t\t\t\tif value then\n\t\t\t\t\tvalue = tostring(value)\n\t\t\t\t\tif #value > col.cw then\n\t\t\t\t\t\tw = w + col.cw\n\t\t\t\t\t\tcol.cw = math.min(#value, w)\n\t\t\t\t\t\tw = w - col.cw\n\t\t\t\t\t\tif w <= 0 then\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\tend\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\n\t\t-- last column does not get padding (right alignment)\n\t\tif not self.columns[#self.columns].width then\n\t\t\tUtil.removeByValue(t, self.columns[#self.columns])\n\t\tend\n\n\t\t-- got some extra room - add some padding\n\t\tif w > 0 then\n\t\t\tfor k,c in ipairs(t) do\n\t\t\t\tlocal padding = math.floor(w / (#t - k + 1))\n\t\t\t\tc.cw = c.cw + padding\n\t\t\t\tw = w - padding\n\t\t\tend\n\t\tend\n\tend\nend\n\nfunction UI.Grid:setPageSize(pageSize)\n\tself.pageSize = pageSize\nend\n\nfunction UI.Grid:getValues()\n\treturn self.values\nend\n\nfunction UI.Grid:setValues(t)\n\tself.values = t\n\tself:update()\nend\n\nfunction UI.Grid:setInverseSort(inverseSort)\n\tself.inverseSort = inverseSort\n\tself:update()\n\tself:setIndex(self.index)\nend\n\nfunction UI.Grid:setSortColumn(column)\n\tself.sortColumn = column\nend\n\nfunction UI.Grid:getDisplayValues(row, key)\n\treturn row\nend\n\nfunction UI.Grid:getSelected()\n\tif self.sorted then\n\t\treturn self.values[self.sorted[self.index]], self.sorted[self.index]\n\tend\nend\n\nfunction UI.Grid:setSelected(name, value)\n\tif self.sorted then\n\t\tfor k,v in pairs(self.sorted) do\n\t\t\tif self.values[v][name] == value then\n\t\t\t\tself:setIndex(k)\n\t\t\t\treturn\n\t\t\tend\n\t\tend\n\tend\n\tself:setIndex(1)\nend\n\nfunction UI.Grid:focus()\n\tself:drawRows()\nend\n\nfunction UI.Grid:draw()\n\tif not self.disableHeader then\n\t\tself:drawHeadings()\n\tend\n\n\tif self.index <= 0 then\n\t\tself:setIndex(1)\n\telseif self.index > #self.sorted then\n\t\tself:setIndex(#self.sorted)\n\tend\n\tself:drawRows()\nend\n\n-- Something about the displayed table has changed\n-- resort the table\nfunction UI.Grid:update()\n\tlocal function sort(a, b)\n\t\tif not a[self.sortColumn] then\n\t\t\treturn false\n\t\telseif not b[self.sortColumn] then\n\t\t\treturn true\n\t\tend\n\t\treturn self:sortCompare(a, b)\n\tend\n\n\tlocal function inverseSort(a, b)\n\t\treturn not sort(a, b)\n\tend\n\n\tlocal order\n\tif self.sortColumn then\n\t\torder = sort\n\t\tif self.inverseSort then\n\t\t\torder = inverseSort\n\t\tend\n\tend\n\n\tself.sorted = Util.keys(self.values)\n\tif order then\n\t\ttable.sort(self.sorted, function(a,b)\n\t\t\treturn order(self.values[a], self.values[b])\n\t\tend)\n\tend\n\n\tself:adjustWidth()\nend\n\nfunction UI.Grid:drawHeadings()\n\tif self.headerHeight > 1 then\n\t\tself:clear(self.headerBackgroundColor)\n\tend\n\tlocal sb = Writer(self, math.ceil(self.headerHeight / 2))\n\tfor _,col in ipairs(self.columns) do\n\t\tlocal ind = ' '\n\t\tlocal color = self.headerTextColor\n\t\tif col.key == self.sortColumn then\n\t\t\tif self.inverseSort then\n\t\t\t\tind = self.inverseSortIndicator\n\t\t\telse\n\t\t\t\tind = self.sortIndicator\n\t\t\tend\n\t\t\tcolor = self.headerSortColor\n\t\tend\n\t\tsb:write(ind .. col.heading,\n\t\t\tcol.cw + 1,\n\t\t\tcol.align,\n\t\t\tself.headerBackgroundColor,\n\t\t\tcolor)\n\tend\n\tsb:finish(self.headerBackgroundColor)\nend\n\nfunction UI.Grid:sortCompare(a, b)\n\ta = safeValue(a[self.sortColumn])\n\tb = safeValue(b[self.sortColumn])\n\tif type(a) == type(b) then\n\t\treturn a < b\n\tend\n\treturn tostring(a) < tostring(b)\nend\n\nfunction UI.Grid:drawRows()\n\tlocal startRow = math.max(1, self:getStartRow())\n\n\tlocal sb = Writer(self, self.disableHeader and 1 or self.headerHeight + 1)\n\n\tlocal lastRow = math.min(startRow + self.pageSize - 1, #self.sorted)\n\tfor index = startRow, lastRow do\n\n\t\tlocal key = self.sorted[index]\n\t\tlocal rawRow = self.values[key]\n\t\tlocal row = self:getDisplayValues(rawRow, key)\n\n\t\tlocal selected = index == self.index and not self.inactive\n\t\tlocal bg = self:getRowBackgroundColor(rawRow, selected)\n\t\tlocal fg = self:getRowTextColor(rawRow, selected)\n\t\tlocal focused = self.focused and selected\n\n\t\tself:drawRow(sb, row, focused, bg, fg)\n\n\t\tsb:finish(bg)\n\tend\n\n\tif sb.y <= self.height then\n\t\tself:clearArea(1, sb.y, self.width, self.height - sb.y + 1)\n\tend\nend\n\nfunction UI.Grid:drawRow(sb, row, focused, bg, fg)\n\tlocal ind = focused and self.focusIndicator or ' '\n\n\tfor _,col in pairs(self.columns) do\n\t\tsb:write(ind .. safeValue(row[col.key] or ''),\n\t\t\tcol.cw + 1,\n\t\t\tcol.align,\n\t\t\tcol.backgroundColor or bg,\n\t\t\tcol.textColor or fg)\n\t\tind = ' '\n\tend\nend\n\nfunction UI.Grid:getRowTextColor(row, selected)\n\tif selected then\n\t\tif self.focused then\n\t\t\treturn self.textSelectedColor\n\t\tend\n\t\treturn self.unfocusedTextSelectedColor\n\tend\n\treturn self.textColor\nend\n\nfunction UI.Grid:getRowBackgroundColor(row, selected)\n\tif selected then\n\t\tif self.focused then\n\t\t\treturn self.backgroundSelectedColor\n\t\tend\n\t\treturn self.unfocusedBackgroundSelectedColor\n\tend\n\treturn self.backgroundColor\nend\n\nfunction UI.Grid:getIndex()\n\treturn self.index\nend\n\nfunction UI.Grid:setIndex(index)\n\tindex = math.max(1, index)\n\tself.index = math.min(index, #self.sorted)\n\n\tlocal selected = self:getSelected()\n\tif selected ~= self.selected then\n\t\tself:drawRows()\n\t\tself.selected = selected\n\t\tif selected then\n\t\t\tself:emit({ type = 'grid_focus_row', selected = selected, element = self })\n\t\tend\n\tend\nend\n\nfunction UI.Grid:getStartRow()\n\treturn math.floor((self.index - 1) / self.pageSize) * self.pageSize + 1\nend\n\nfunction UI.Grid:getPage()\n\treturn math.floor(self.index / self.pageSize) + 1\nend\n\nfunction UI.Grid:getPageCount()\n\tlocal tableSize = Util.size(self.values)\n\tlocal pc = math.floor(tableSize / self.pageSize)\n\tif tableSize % self.pageSize > 0 then\n\t\tpc = pc + 1\n\tend\n\treturn pc\nend\n\nfunction UI.Grid:nextPage()\n\tself:setPage(self:getPage() + 1)\nend\n\nfunction UI.Grid:previousPage()\n\tself:setPage(self:getPage() - 1)\nend\n\nfunction UI.Grid:setPage(pageNo)\n\t-- 1 based paging\n\tself:setIndex((pageNo-1) * self.pageSize + 1)\nend\n\nfunction UI.Grid:eventHandler(event)\n\tif event.type == 'mouse_click' or\n\t\t event.type == 'mouse_rightclick' or\n\t\t event.type == 'mouse_doubleclick' then\n\t\tif not self.disableHeader then\n\t\t\tif event.y <= self.headerHeight then\n\t\t\t\tlocal col = 2\n\t\t\t\tfor _,c in ipairs(self.columns) do\n\t\t\t\t\tif event.x < col + c.cw then\n\t\t\t\t\t\tself:emit({\n\t\t\t\t\t\t\ttype = 'grid_sort',\n\t\t\t\t\t\t\tsortColumn = c.key,\n\t\t\t\t\t\t\tinverseSort = self.sortColumn == c.key and not self.inverseSort,\n\t\t\t\t\t\t\telement = self,\n\t\t\t\t\t\t})\n\t\t\t\t\t\tbreak\n\t\t\t\t\tend\n\t\t\t\t\tcol = col + c.cw + 1\n\t\t\t\tend\n\t\t\t\treturn true\n\t\t\tend\n\t\tend\n\t\tlocal row = self:getStartRow() + event.y - 1\n\t\tif not self.disableHeader then\n\t\t\trow = row - self.headerHeight\n\t\tend\n\t\tif row > 0 and row <= Util.size(self.values) then\n\t\t\tself:setIndex(row)\n\t\t\tif event.type == 'mouse_doubleclick' then\n\t\t\t\tself:emit({ type = 'key_enter' })\n\t\t\telseif event.type == 'mouse_rightclick' then\n\t\t\t\tself:emit({ type = 'grid_select_right', selected = self.selected, element = self })\n\t\t\tend\n\t\t\treturn true\n\t\tend\n\t\treturn false\n\n\telseif event.type == 'grid_sort' then\n\t\tself.sortColumn = event.sortColumn\n\t\tself:setInverseSort(event.inverseSort)\n\t\tself:draw()\n\telseif event.type == 'scroll_down' then\n\t\tself:setIndex(self.index + 1)\n\telseif event.type == 'scroll_up' then\n\t\tself:setIndex(self.index - 1)\n\telseif event.type == 'scroll_top' then\n\t\tself:setIndex(1)\n\telseif event.type == 'scroll_bottom' then\n\t\tself:setIndex(Util.size(self.values))\n\telseif event.type == 'scroll_pageUp' then\n\t\tself:setIndex(self.index - self.pageSize)\n\telseif event.type == 'scroll_pageDown' then\n\t\tself:setIndex(self.index + self.pageSize)\n\telseif event.type == 'scroll_to' then\n\t\tself:setIndex(event.offset)\n\telseif event.type == 'key_enter' then\n\t\tif self.selected then\n\t\t\tself:emit({ type = 'grid_select', selected = self.selected, element = self })\n\t\tend\n\telseif event.type == 'copy' then\n\t\tif self.selected then\n\t\t\tos.queueEvent('clipboard_copy', self.selected)\n\t\tend\n\telse\n\t\treturn false\n\tend\n\treturn true\nend\n\nfunction UI.Grid.example()\n\tlocal values = {\n\t\t{ key = 'key1', value = 'value1' },\n\t\t{ key = 'key2', value = 'value2' },\n\t\t{ key = 'key3', value = 'value3-longer value text' },\n\t\t{ key = 'key4', value = 'value4' },\n\t\t{ key = 'key5', value = 'value5' },\n\t}\n\treturn UI.Window {\n\t\tregular = UI.Grid {\n\t\t\tex = '48%', ey = 4,\n\t\t\tvalues = values,\n\t\t\tsortColumn = 'key',\n\t\t\tinverseSort = true,\n\t\t\tcolumns = {\n\t\t\t\t{ heading = 'key', key = 'key' },\n\t\t\t\t{ heading = 'value', key = 'value' },\n\t\t\t},\n\t\t\taccelerators = {\n\t\t\t\tgrid_select = 'custom_select',\n\t\t\t}\n\t\t},\n\t\tnoheader = UI.Grid {\n\t\t\tex = '48%', y = 6, ey = -2,\n\t\t\tdisableHeader = true,\n\t\t\tvalues = values,\n\t\t\tcolumns = {\n\t\t\t\t{ heading = 'key', key = 'key', width = 6,  },\n\t\t\t\t{ heading = 'value', key = 'value', textColor = 'yellow' },\n\t\t\t},\n\t\t},\n\t\tautospace = UI.Grid {\n\t\t\tx = '52%', ey = 4,\n\t\t\tautospace = true,\n\t\t\tvalues = values,\n\t\t\tcolumns = {\n\t\t\t\t{ heading = 'key', key = 'key' },\n\t\t\t\t{ heading = 'value', key = 'value' },\n\t\t\t},\n\t\t},\n\t}\nend\n", "sys/modules/opus/ui/components/CheckboxGrid.lua": "local class = require('opus.class')\nlocal UI    = require('opus.ui')\n\nlocal function safeValue(v)\n\tlocal t = type(v)\n\tif t == 'string' or t == 'number' then\n\t\treturn v\n\tend\n\treturn tostring(v)\nend\n\nUI.CheckboxGrid = class(UI.Grid)\nUI.CheckboxGrid.defaults = {\n\tUIElement = 'CheckboxGrid',\n\tcheckedKey = 'checked',\n\taccelerators = {\n\t\t[ ' ' ] = 'grid_toggle',\n\t\tkey_enter = 'grid_toggle',\n\t},\n}\nfunction UI.CheckboxGrid:drawRow(sb, row, focused, bg, fg)\n\tlocal ind = focused and self.focusIndicator or ' '\n\n\tfor _,col in pairs(self.columns) do\n\t\tsb:write(ind .. safeValue(row[col.key] or ''),\n\t\t\tcol.cw + 1,\n\t\t\tcol.align,\n\t\t\tcol.backgroundColor or bg,\n\t\t\tcol.textColor or fg)\n\t\tind = ' '\n\tend\nend\n\nfunction UI.CheckboxGrid:eventHandler(event)\n\tif event.type == 'grid_toggle' and self.selected then\n\t\tself.selected.checked = not self.selected.checked\n\t\tself:draw()\n\t\tself:emit({ type = 'grid_check', checked = self.selected, element = self })\n\telse\n\t\treturn UI.Grid.eventHandler(self, event)\n\tend\nend\n\nfunction UI.CheckboxGrid.example()\n\treturn UI.CheckboxGrid {\n\t\tvalues = {\n\t\t\t{ checked = false, name = 'unchecked' },\n\t\t\t{ checked = true, name = 'checked' },\n\t\t},\n\t\tcolumns = {\n\t\t\t{ heading = 'Checked', key = 'checked' },\n\t\t\t{ heading = 'Data', key = 'name',  }\n\t\t},\n\t}\nend\n", "sys/modules/opus/ui/components/MenuBar.lua": "local class = require('opus.class')\nlocal UI    = require('opus.ui')\n\nUI.MenuBar = class(UI.Window)\nUI.MenuBar.defaults = {\n\tUIElement = 'MenuBar',\n\tbuttons = { },\n\theight = 1,\n\tbackgroundColor = 'secondary',\n\ttextColor = 'black',\n\tspacing = 2,\n\tlastx = 1,\n\tbuttonClass = 'MenuItem',\n}\nfunction UI.MenuBar:postInit()\n\tself:addButtons(self.buttons)\nend\n\nfunction UI.MenuBar:addButtons(buttons)\n\tif not self.children then\n\t\tself.children = { }\n\tend\n\n\tfor _,button in pairs(buttons) do\n\t\tif button.index then -- don't sort unless needed\n\t\t\ttable.sort(buttons, function(a, b)\n\t\t\t\treturn (a.index or 999) < (b.index or 999)\n\t\t\tend)\n\t\t\tbreak\n\t\tend\n\tend\n\n\tfor _,button in pairs(buttons) do\n\t\tif button.UIElement then\n\t\t\ttable.insert(self.children, button)\n\t\telse\n\t\t\tlocal buttonProperties = {\n\t\t\t\tx = self.lastx,\n\t\t\t\twidth = #(button.text or 'button') + self.spacing,\n\t\t\t\tcentered = false,\n\t\t\t\tbackgroundColor = self.backgroundColor,\n\t\t\t}\n\t\t\tself.lastx = self.lastx + buttonProperties.width\n\t\t\tUI:mergeProperties(buttonProperties, button)\n\n\t\t\tbutton = UI[self.buttonClass](buttonProperties)\n\t\t\tif button.name then\n\t\t\t\tself[button.name] = button\n\t\t\telse\n\t\t\t\ttable.insert(self.children, button)\n\t\t\tend\n\t\tend\n\tend\n\tif self.parent then\n\t\tself:initChildren()\n\tend\nend\n\nfunction UI.MenuBar:getActive(menuItem)\n\treturn not menuItem.inactive\nend\n\nfunction UI.MenuBar:eventHandler(event)\n\tif event.type == 'button_press' and event.button.dropdown then\n\t\tlocal function getPosition(element)\n\t\t\tlocal x, y = 1, 1\n\t\t\trepeat\n\t\t\t\tx = element.x + x - 1\n\t\t\t\ty = element.y + y - 1\n\t\t\t\telement = element.parent\n\t\t\tuntil not element\n\t\t\treturn x, y\n\t\tend\n\n\t\tlocal x, y = getPosition(event.button)\n\n\t\tlocal menu = UI.DropMenu {\n\t\t\tbuttons = event.button.dropdown,\n\t\t\tx = x,\n\t\t\ty = y + 1,\n\t\t\tlastFocus = event.button.uid,\n\t\t\tmenuUid = self.uid,\n\t\t}\n\t\tself.parent:add({ dropmenu = menu })\n\n\t\treturn true\n\tend\nend\n\nfunction UI.MenuBar.example()\n\treturn UI.MenuBar {\n\t\tbuttons = {\n\t\t\t{ text = 'Choice1', event = 'event1' },\n\t\t\t{ text = 'Choice2', event = 'event2', inactive = true },\n\t\t\t{ text = 'Choice3', event = 'event3' },\n\t\t}\n\t}\nend\n", "sys/modules/opus/ui/components/MiniSlideOut.lua": "local class = require('opus.class')\nlocal UI    = require('opus.ui')\n\nUI.MiniSlideOut = class(UI.SlideOut)\nUI.MiniSlideOut.defaults = {\n\tUIElement = 'MiniSlideOut',\n    noFill = true,\n    backgroundColor = 'primary',\n    height = 1,\n}\nfunction UI.MiniSlideOut:postInit()\n    self.close_button = UI.Button {\n        x = -1,\n        backgroundColor = self.backgroundColor,\n        backgroundFocusColor = self.backgroundColor,\n        text = 'x',\n        event = 'slide_hide',\n        noPadding = true,\n    }\n    if self.label then\n        self.label_text = UI.Text {\n            x = 2,\n            value = self.label,\n        }\n    end\nend\n\nfunction UI.MiniSlideOut:show(...)\n    UI.SlideOut.show(self, ...)\n    self:addTransition('slideLeft', { easing = 'outBounce' })\nend\n", "sys/modules/opus/ui/components/StatusBar.lua": "local class = require('opus.class')\nlocal Event = require('opus.event')\nlocal UI    = require('opus.ui')\nlocal Util  = require('opus.util')\n\nUI.StatusBar = class(UI.Window)\nUI.StatusBar.defaults = {\n\tUIElement = 'StatusBar',\n\tbackgroundColor = 'lightGray',\n\ttextColor = 'gray',\n\theight = 1,\n\tey = -1,\n}\nfunction UI.StatusBar:layout()\n\tUI.Window.layout(self)\n\t-- Can only have 1 adjustable width\n\tif self.columns then\n\t\tlocal w = self.width - #self.columns - 1\n\t\tfor _,c in pairs(self.columns) do\n\t\t\tif c.width then\n\t\t\t\tc.cw = c.width  -- computed width\n\t\t\t\tw = w - c.width\n\t\t\tend\n\t\tend\n\t\tfor _,c in pairs(self.columns) do\n\t\t\tif not c.width then\n\t\t\t\tc.cw = w\n\t\t\tend\n\t\tend\n\tend\nend\n\nfunction UI.StatusBar:setStatus(status)\n\tif self.values ~= status then\n\t\tself.values = status\n\t\tself:draw()\n\tend\nend\n\nfunction UI.StatusBar:setValue(name, value)\n\tif not self.values then\n\t\tself.values = { }\n\tend\n\tself.values[name] = value\nend\n\nfunction UI.StatusBar:getValue(name)\n\tif self.values then\n\t\treturn self.values[name]\n\tend\nend\n\nfunction UI.StatusBar:timedStatus(status, timeout)\n\tself:write(2, 1, Util.widthify(status, self.width-2), self.backgroundColor)\n\tEvent.onTimeout(timeout or 3, function()\n\t\tif self.enabled then\n\t\t\tself:draw()\n\t\t\tself:sync()\n\t\tend\n\tend)\nend\n\nfunction UI.StatusBar:getColumnWidth(name)\n\tlocal c = Util.find(self.columns, 'key', name)\n\treturn c and c.cw\nend\n\nfunction UI.StatusBar:setColumnWidth(name, width)\n\tlocal c = Util.find(self.columns, 'key', name)\n\tif c then\n\t\tc.cw = width\n\tend\nend\n\nfunction UI.StatusBar:draw()\n\tif not self.values then\n\t\tself:clear()\n\telseif type(self.values) == 'string' then\n\t\tself:write(1, 1, Util.widthify(' ' .. self.values, self.width))\n\telse\n\t\tlocal x = 2\n\t\tself:clear()\n\t\tfor _,c in ipairs(self.columns) do\n\t\t\tlocal s = Util.widthify(tostring(self.values[c.key] or ''), c.cw)\n\t\t\tself:write(x, 1, s, c.bg, c.fg)\n\t\t\tx = x + c.cw + 1\n\t\tend\n\tend\nend\n\nfunction UI.StatusBar.example()\n\treturn UI.Window {\n\t\tstatus1 = UI.StatusBar { values = 'standard' },\n\t\tstatus2 = UI.StatusBar {\n\t\t\tey = -3,\n\t\t\tcolumns = {\n\t\t\t\t{ key = 'field1' },\n\t\t\t\t{ key = 'field2', width = 6 },\n\t\t\t},\n\t\t\tvalues = {\n\t\t\t\tfield1 = 'test',\n\t\t\t\tfield2 = '42',\n\t\t\t}\n\t\t}\n\t}\nend\n", "sys/modules/opus/ui/components/Dialog.lua": "local class  = require('opus.class')\nlocal UI     = require('opus.ui')\n\nUI.Dialog = class(UI.SlideOut)\nUI.Dialog.defaults = {\n\tUIElement = 'Dialog',\n\theight = 7,\n\tnoFill = true,\n\tokEvent ='dialog_ok',\n\tcancelEvent = 'dialog_cancel',\n}\nfunction UI.Dialog:postInit()\n\tself.y = -self.height\n\tself.titleBar = UI.TitleBar({ event = self.cancelEvent, title = self.title })\nend\n\nfunction UI.Dialog:eventHandler(event)\n\tif event.type == 'dialog_cancel' then\n\t\tself:hide()\n\tend\n\treturn UI.SlideOut.eventHandler(self, event)\nend\n\nfunction UI.Dialog.example()\n\treturn UI.Dialog {\n\t\ttitle = 'Enter Starting Level',\n\t\theight = 7,\n\t\tform = UI.Form {\n\t\t\ty = 3, x = 2, height = 4,\n\t\t\tevent = 'setStartLevel',\n\t\t\tcancelEvent = 'slide_hide',\n\t\t\ttext = UI.Text {\n\t\t\t\tx = 5, y = 1, width = 20,\n\t\t\t\ttextColor = 'gray',\n\t\t\t},\n\t\t\ttextEntry = UI.TextEntry {\n\t\t\t\tformKey = 'level',\n\t\t\t\tx = 15, y = 1, width = 7,\n\t\t\t},\n\t\t},\n\t\tstatusBar = UI.StatusBar(),\n\t\tenable = function(self)\n\t\t\trequire('opus.event').onTimeout(0, function()\n\t\t\t\tself:show()\n\t\t\t\tself:sync()\n\t\t\tend)\n\t\tend,\n\t}\nend\n", "sys/modules/opus/ui/components/Menu.lua": "local class = require('opus.class')\nlocal UI    = require('opus.ui')\n\nUI.Menu = class(UI.Grid)\nUI.Menu.defaults = {\n\tUIElement = 'Menu',\n\tdisableHeader = true,\n\tcolumns = { { heading = 'Prompt', key = 'prompt', width = 20 } },\n\tmenuItems = { },\n}\nfunction UI.Menu:postInit()\n\tself.values = self.menuItems\n\tself.pageSize = #self.menuItems\nend\n\nfunction UI.Menu:layout()\n\tself.itemWidth = 1\n\tfor _,v in pairs(self.values) do\n\t\tif #v.prompt > self.itemWidth then\n\t\t\tself.itemWidth = #v.prompt\n\t\tend\n\tend\n\tself.columns[1].width = self.itemWidth\n\n\tif self.centered then\n\t\tself:center()\n\telse\n\t\tself.width = self.itemWidth + 2\n\tend\n\tUI.Grid.layout(self)\nend\n\nfunction UI.Menu:center()\n\tself.x = (self.width - self.itemWidth + 2) / 2\n\tself.width = self.itemWidth + 2\nend\n\nfunction UI.Menu:eventHandler(event)\n\tif event.type == 'key' then\n\t\tif event.key == 'enter' then\n\t\t\tlocal selected = self.menuItems[self.index]\n\t\t\tself:emit({\n\t\t\t\ttype = selected.event or 'menu_select',\n\t\t\t\tselected = selected\n\t\t\t})\n\t\t\treturn true\n\t\tend\n\telseif event.type == 'mouse_click' then\n\t\tif event.y <= #self.menuItems then\n\t\t\tUI.Grid.setIndex(self, event.y)\n\t\t\tlocal selected = self.menuItems[self.index]\n\t\t\tself:emit({\n\t\t\t\ttype = selected.event or 'menu_select',\n\t\t\t\tselected = selected\n\t\t\t})\n\t\t\treturn true\n\t\tend\n\tend\n\treturn UI.Grid.eventHandler(self, event)\nend\n\nfunction UI.Menu.example()\n\treturn UI.Menu {\n\t\tx = 2, y = 2, height = 3,\n\t\tmenuItems = {\n\t\t\t{ prompt = 'Start',    event = 'start' },\n\t\t\t{ prompt = 'Continue', event = 'continue' },\n\t\t\t{ prompt = 'Quit',     event = 'quit' }\n\t\t}\n\t}\nend\n", "sys/modules/opus/ui/components/MenuItem.lua": "local class = require('opus.class')\nlocal UI    = require('opus.ui')\n\nUI.MenuItem = class(UI.FlatButton)\nUI.MenuItem.defaults = {\n\tUIElement = 'MenuItem',\n\tnoPadding = false,\n\ttextInactiveColor = 'gray',\n}\n", "sys/modules/opus/ui/components/TabBarMenuItem.lua": "local class = require('opus.class')\nlocal UI    = require('opus.ui')\n\nUI.TabBarMenuItem = class(UI.Button)\nUI.TabBarMenuItem.defaults = {\n\tUIElement = 'TabBarMenuItem',\n\tevent = 'tab_select',\n}\nfunction UI.TabBarMenuItem:draw()\n\tif self.selected then\n\t\tself.backgroundColor = self:getProperty('selectedBackgroundColor')\n\t\tself.backgroundFocusColor = self.backgroundColor\n\t\tself.textColor = self:getProperty('selectedTextColor')\n\telse\n\t\tself.backgroundColor = self:getProperty('unselectedBackgroundColor')\n\t\tself.backgroundFocusColor = self.backgroundColor\n\t\tself.textColor = self:getProperty('unselectedTextColor')\n\tend\n\tUI.Button.draw(self)\nend\n", "sys/modules/opus/ui/components/QuickSelect.lua": "local class = require('opus.class')\nlocal fuzzy = require('opus.fuzzy')\nlocal UI    = require('opus.ui')\n\nlocal fs      = _G.fs\nlocal _insert = table.insert\n\nUI.QuickSelect = class(UI.Window)\nUI.QuickSelect.defaults = {\n\tUIElement = 'QuickSelect',\n}\nfunction UI.QuickSelect:postInit()\n\tself.filterEntry = UI.TextEntry {\n\t\tx = 2, y = 2, ex = -2,\n\t\tshadowText = 'File name',\n\t\taccelerators = {\n\t\t\t[ 'enter' ] = 'accept',\n\t\t\t[ 'up' ] = 'grid_up',\n\t\t\t[ 'down' ] = 'grid_down',\n\t\t},\n\t}\n\tself.grid = UI.ScrollingGrid {\n\t\tx = 2, y = 3, ex = -2, ey = -4,\n\t\tdisableHeader = true,\n\t\tcolumns = {\n\t\t\t{ key = 'name' },\n\t\t\t{ key = 'dir', textColor = 'lightGray' },\n\t\t},\n\t\taccelerators = {\n\t\t\tgrid_select = 'accept',\n\t\t},\n\t}\n\tself.cancel = UI.Button {\n\t\tx = -9, y = -2,\n\t\ttext = 'Cancel',\n\t\tevent = 'select_cancel',\n\t}\nend\n\nfunction UI.QuickSelect:draw()\n\tself:fillArea(1, 1, self.width, self.height, string.rep('\\127', self.width), 'black', 'gray')\n\tself:drawChildren()\nend\n\nfunction UI.QuickSelect:applyFilter(filter)\n\tif filter then\n\t\tfilter = filter:lower()\n\t\tself.grid.sortColumn = 'score'\n\n\t\tfor _,v in pairs(self.grid.values) do\n\t\t\tv.score = -fuzzy(v.lname, filter)\n\t\tend\n\telse\n\t\tself.grid.sortColumn = 'lname'\n\tend\n\n\tself.grid:update()\n\tself.grid:setIndex(1)\nend\n\nfunction UI.QuickSelect.getFiles()\n\tlocal t = { }\n\tlocal function recurse(dir)\n\t\tlocal files = fs.list(dir)\n\t\tfor _,f in ipairs(files) do\n\t\t\tlocal fullName = fs.combine(dir, f)\n\t\t\tif fs.isDir(fullName) then\n\t\t\t\t-- skip virtual dirs\n\t\t\t\tif f ~= '.git' and fs.native.isDir(fullName) then\n\t\t\t\t\trecurse(fullName)\n\t\t\t\tend\n\t\t\telse\n\t\t\t\t_insert(t, {\n\t\t\t\t\tname = f,\n\t\t\t\t\tdir = dir,\n\t\t\t\t\tlname = f:lower(),\n\t\t\t\t\tfullName = fullName,\n\t\t\t\t})\n\t\t\tend\n\t\tend\n\tend\n\trecurse('')\n\treturn t\nend\n\nfunction UI.QuickSelect:enable()\n\tself.grid.values = self:getFiles()\n\tself:applyFilter()\n\tself.filterEntry:reset()\n\tUI.Window.enable(self)\nend\n\nfunction UI.QuickSelect:eventHandler(event)\n\tif event.type == 'grid_up' then\n\t\tself.grid:emit({ type = 'scroll_up' })\n\t\treturn true\n\n\telseif event.type == 'grid_down' then\n\t\tself.grid:emit({ type = 'scroll_down' })\n\t\treturn true\n\n\telseif event.type == 'accept' then\n\t\tlocal sel = self.grid:getSelected()\n\t\tif sel then\n\t\t\tself:emit({ type = 'select_file', file = sel.fullName, element = self })\n\t\tend\n\t\treturn true\n\n\telseif event.type == 'text_change' then\n\t\tself:applyFilter(event.text)\n\t\tself.grid:draw()\n\t\treturn true\n\n\tend\nend\n", "sys/modules/opus/ui/components/TextArea.lua": "local class = require('opus.class')\nlocal UI    = require('opus.ui')\n\nUI.TextArea = class(UI.Viewport)\nUI.TextArea.defaults = {\n\tUIElement = 'TextArea',\n\tmarginRight = 2,\n\tvalue = '',\n\tshowScrollBar = true,\n}\nfunction UI.TextArea:setValue(text)\n\tself:reset()\n\tself.value = text\n\tself:draw()\nend\nUI.TextArea.setText = UI.TextArea.setValue -- deprecate\n\nfunction UI.TextArea.focus()\n\t-- allow keyboard scrolling\nend\n\nfunction UI.TextArea:draw()\n\tself:clear()\n\tself:print(self.value)\n\tself:drawChildren()\nend\n\nfunction UI.TextArea.example()\n\tlocal Ansi = require('opus.ansi')\n\treturn UI.Window {\n\t\tbackgroundColor = 2048,\n\t\tt1 = UI.TextArea {\n\t\t\tey = 3,\n\t\t\tvalue = 'sample text\\nabc'\n\t\t},\n\t\tt2 = UI.TextArea {\n\t\t\ty = 5,\n\t\t\tbackgroundColor = 'green',\n\t\t\tvalue = string.format([[now %%is the %stime %sfor%s all good men to come to the aid of their country.\n1\n2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26\n3\n4\n5\n6\n7\n8]], Ansi.yellow, Ansi.onred, Ansi.reset),\n\t\t}\n\t}\nend", "sys/modules/opus/ui/components/TabBar.lua": "local class = require('opus.class')\nlocal UI    = require('opus.ui')\nlocal Util  = require('opus.util')\n\nUI.TabBar = class(UI.MenuBar)\nUI.TabBar.defaults = {\n\tUIElement = 'TabBar',\n\tbuttonClass = 'TabBarMenuItem',\n\tbackgroundColor = 'black',\n}\nfunction UI.TabBar:enable()\n\tUI.MenuBar.enable(self)\n\tif not Util.find(self.children, 'selected', true) then\n\t\tlocal menuItem = self:getFocusables()[1]\n\t\tif menuItem then\n\t\t\tmenuItem.selected = true\n\t\tend\n\tend\nend\n\nfunction UI.TabBar:eventHandler(event)\n\tif event.type == 'tab_select' then\n\t\tlocal selected, si = Util.find(self.children, 'uid', event.button.uid)\n\t\tlocal previous, pi = Util.find(self.children, 'selected', true)\n\n\t\tif si ~= pi then\n\t\t\tselected.selected = true\n\t\t\tif previous then\n\t\t\t\tprevious.selected = false\n\t\t\t\tself:emit({ type = 'tab_change', current = si, last = pi, tab = selected })\n\t\t\tend\n\t\tend\n\t\tself:draw(self)\n\tend\n\treturn UI.MenuBar.eventHandler(self, event)\nend\n\n", "sys/modules/opus/ui/components/Page.lua": "local class  = require('opus.class')\nlocal UI     = require('opus.ui')\nlocal Util   = require('opus.util')\n\nUI.Page = class(UI.Window)\nUI.Page.defaults = {\n\tUIElement = 'Page',\n\taccelerators = {\n\t\tdown = 'focus_next',\n\t\tscroll_down = 'focus_next',\n\t\tenter = 'focus_next',\n\t\ttab = 'focus_next',\n\t\t['shift-tab' ] = 'focus_prev',\n\t\tup = 'focus_prev',\n\t\tscroll_up = 'focus_prev',\n\t},\n\tbackgroundColor = 'primary',\n\ttextColor = 'white',\n}\nfunction UI.Page:postInit()\n\tself.parent = self.parent or UI.term\n\tself.__target = self\nend\n\nfunction UI.Page:sync()\n\tif self.enabled then\n\t\tself:checkFocus()\n\t\tself.parent:setCursorBlink(self.focused and self.focused.cursorBlink)\n\t\tself.parent:sync()\n\tend\nend\n\nfunction UI.Page:capture(child)\n\tself.__target = child\nend\n\nfunction UI.Page:release(child)\n\tif self.__target == child then\n\t\tself.__target = self\n\tend\nend\n\nfunction UI.Page:pointToChild(x, y)\n\tif self.__target == self then\n\t\treturn UI.Window.pointToChild(self, x, y)\n\tend\n\n\tlocal function getPosition(element)\n\t\tlocal x, y = 1, 1\n\t\trepeat\n\t\t\tx = element.x + x - 1\n\t\t\ty = element.y + y - 1\n\t\t\telement = element.parent\n\t\tuntil not element\n\t\treturn x, y\n\tend\n\n\tlocal absX, absY = getPosition(self.__target)\n\treturn self.__target:pointToChild(x - absX + self.__target.x, y - absY + self.__target.y)\nend\n\nfunction UI.Page:getFocusables()\n\tif self.__target == self or not self.__target.modal then\n\t\treturn UI.Window.getFocusables(self)\n\tend\n\treturn self.__target:getFocusables()\nend\n\nfunction UI.Page:getFocused()\n\treturn self.focused\nend\n\nfunction UI.Page:focusPrevious()\n\tlocal function getPreviousFocus(focused)\n\t\tlocal focusables = self:getFocusables()\n\t\tlocal k = Util.contains(focusables, focused)\n\t\tif k then\n\t\t\tif k > 1 then\n\t\t\t\treturn focusables[k - 1]\n\t\t\tend\n\t\t\treturn focusables[#focusables]\n\t\tend\n\tend\n\n\tlocal focused = getPreviousFocus(self.focused)\n\tif focused then\n\t\tself:setFocus(focused)\n\tend\nend\n\nfunction UI.Page:focusNext()\n\tlocal function getNextFocus(focused)\n\t\tlocal focusables = self:getFocusables()\n\t\tlocal k = Util.contains(focusables, focused)\n\t\tif k then\n\t\t\tif k < #focusables then\n\t\t\t\treturn focusables[k + 1]\n\t\t\tend\n\t\t\treturn focusables[1]\n\t\tend\n\tend\n\n\tlocal focused = getNextFocus(self.focused)\n\tif focused then\n\t\tself:setFocus(focused)\n\tend\nend\n\nfunction UI.Page:setFocus(child)\n\tif not child or not child.focus then\n\t\treturn\n\tend\n\n\tif self.focused and self.focused ~= child then\n\t\tself.focused.focused = false\n\t\tself.focused:focus()\n\t\tself.focused:emit({ type = 'focus_lost', focused = child, unfocused = self.focused })\n\tend\n\n\tself.focused = child\n\tif not child.focused then\n\t\tchild.focused = true\n\t\tchild:emit({ type = 'focus_change', focused = child })\n\tend\n\n\tchild:focus()\nend\n\nfunction UI.Page:checkFocus()\n\tif not self.focused or not self.focused.enabled then\n\t\tself.__target:focusFirst()\n\tend\nend\n\nfunction UI.Page:eventHandler(event)\n\tif self.focused then\n\t\tif event.type == 'focus_next' then\n\t\t\tself:focusNext()\n\t\t\treturn true\n\t\telseif event.type == 'focus_prev' then\n\t\t\tself:focusPrevious()\n\t\t\treturn true\n\t\tend\n\tend\nend\n", "sys/modules/opus/ui/components/Checkbox.lua": "local class = require('opus.class')\nlocal UI    = require('opus.ui')\n\nUI.Checkbox = class(UI.Window)\nUI.Checkbox.defaults = {\n\tUIElement = 'Checkbox',\n\tnochoice = 'Select',\n\tcheckedIndicator = UI.extChars and '\\4' or 'X',\n\tleftMarker = UI.extChars and '\\124' or '[',\n\trightMarker = UI.extChars and '\\124' or ']',\n\tvalue = false,\n\ttextColor = 'white',\n\tbackgroundColor = 'black',\n\tbackgroundFocusColor = 'lightGray',\n\tevent = 'checkbox_change',\n\theight = 1,\n\twidth = 3,\n\taccelerators = {\n\t\t[ ' ' ] = 'checkbox_toggle',\n\t\tmouse_click = 'checkbox_toggle',\n\t}\n}\nfunction UI.Checkbox:layout()\n\tself.width = self.label and #self.label + 4 or 3\n\tUI.Window.layout(self)\nend\n\nfunction UI.Checkbox:draw()\n\tlocal bg = self.focused and self.backgroundFocusColor or self.backgroundColor\n\tlocal x = 1\n\tif self.label then\n\t\tself:write(1, 1, self.label, self.labelBackgroundColor)\n\t\tx = #self.label + 2\n\tend\n\tself:write(x,     1, self.leftMarker, self.backgroundColor, self.textColor)\n\tself:write(x + 1, 1, not self.value and ' ' or self.checkedIndicator, bg)\n\tself:write(x + 2, 1, self.rightMarker, self.backgroundColor, self.textColor)\nend\n\nfunction UI.Checkbox:focus()\n\tself:draw()\nend\n\nfunction UI.Checkbox:setValue(v)\n\tself.value = not not v\nend\n\nfunction UI.Checkbox:reset()\n\tself.value = false\n\tself:draw()\nend\n\nfunction UI.Checkbox:eventHandler(event)\n\tif event.type == 'checkbox_toggle' then\n\t\tself.value = not self.value\n\t\tself:emit({ type = self.event, checked = self.value, element = self })\n\t\tself:draw()\n\t\treturn true\n\tend\nend\n\nfunction UI.Checkbox.example()\n\treturn UI.Window {\n\t\tex1 = UI.Checkbox {\n\t\t\tlabel = 'test',\n\t\t\tx = 2, y = 2,\n\t\t},\n\t\tex2 = UI.Checkbox {\n\t\t\tx = 2, y = 4,\n\t\t},\n\t}\nend\n", "sys/modules/opus/ui/components/Form.lua": "local class = require('opus.class')\nlocal Sound = require('opus.sound')\nlocal UI    = require('opus.ui')\n\nUI.Form = class(UI.Window)\nUI.Form.defaults = {\n\tUIElement = 'Form',\n\tvalues = { },\n\tmargin = 2,\n\tevent = 'form_complete',\n\tcancelEvent = 'form_cancel',\n}\nfunction UI.Form:postInit()\n\tself:createForm()\nend\n\nfunction UI.Form:reset()\n\tfor _,child in pairs(self.children) do\n\t\tif child.reset then\n\t\t\tchild:reset()\n\t\tend\n\tend\nend\n\nfunction UI.Form:setValues(values)\n\tself:reset()\n\tself.values = values\n\tfor _,child in pairs(self.children) do\n\t\tif child.formKey then\n\t\t\tif child.setValue then\n\t\t\t\tchild:setValue(self.values[child.formKey])\n\t\t\telse\n\t\t\t\tchild.value = self.values[child.formKey]\n\t\t\tend\n\t\tend\n\tend\nend\n\nfunction UI.Form:createForm()\n\tself.children = self.children or { }\n\n\tif not self.labelWidth then\n\t\tself.labelWidth = 1\n\t\tfor _, child in pairs(self) do\n\t\t\tif type(child) == 'table' and child.UIElement then\n\t\t\t\tif child.formLabel then\n\t\t\t\t\tself.labelWidth = math.max(self.labelWidth, #child.formLabel + 2)\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\n\tlocal y = self.margin\n\tfor _, child in pairs(self) do\n\t\tif type(child) == 'table' and child.UIElement then\n\t\t\tif child.formKey then\n\t\t\t\tchild.value = self.values[child.formKey]\n\t\t\tend\n\t\t\tif child.formLabel then\n\t\t\t\tchild.x = self.labelWidth + self.margin - 1\n\t\t\t\tchild.y = child.formIndex and (child.formIndex + self.margin - 1) or y\n\t\t\t\tif not child.width and not child.ex then\n\t\t\t\t\tchild.ex = -self.margin\n\t\t\t\tend\n\n\t\t\t\ttable.insert(self.children, UI.Text {\n\t\t\t\t\tx = self.margin,\n\t\t\t\t\ty = child.y,\n\t\t\t\t\ttextColor = 'black',\n\t\t\t\t\twidth = #child.formLabel,\n\t\t\t\t\tvalue = child.formLabel,\n\t\t\t\t})\n\t\t\tend\n\t\t\tif child.formLabel then\n\t\t\t\ty = y + 1\n\t\t\tend\n\t\tend\n\tend\n\n\tif not self.manualControls then\n\t\ttable.insert(self.children, UI.Button {\n\t\t\ty = -self.margin, x = -12 - self.margin,\n\t\t\ttext = 'Ok',\n\t\t\tevent = 'form_ok',\n\t\t})\n\t\ttable.insert(self.children, UI.Button {\n\t\t\ty = -self.margin, x = -7 - self.margin,\n\t\t\ttext = 'Cancel',\n\t\t\tevent = self.cancelEvent,\n\t\t})\n\tend\nend\n\nfunction UI.Form:validateField(field)\n\tif field.required then\n\t\tif not field.value or #tostring(field.value) == 0 then\n\t\t\treturn false, 'Field is required'\n\t\tend\n\tend\n\treturn true\nend\n\nfunction UI.Form:save()\n\tfor _,child in pairs(self.children) do\n\t\tif child.formKey then\n\t\t\tlocal s, m = self:validateField(child)\n\t\t\tif not s then\n\t\t\t\tself:setFocus(child)\n\t\t\t\tSound.play('entity.villager.no', .5)\n\t\t\t\tself:emit({ type = 'form_invalid', message = m, field = child })\n\t\t\t\treturn false\n\t\t\tend\n\t\tend\n\tend\n\tfor _,child in pairs(self.children) do\n\t\tif child.formKey then\n\t\t\tself.values[child.formKey] = child.value\n\t\tend\n\tend\n\n\treturn true\nend\n\nfunction UI.Form:eventHandler(event)\n\tif event.type == 'form_ok' then\n\t\tif not self:save() then\n\t\t\treturn false\n\t\tend\n\t\tself:emit({ type = self.event, UIElement = self, values = self.values })\n\telse\n\t\treturn UI.Window.eventHandler(self, event)\n\tend\n\treturn true\nend\n\nfunction UI.Form.example()\n\treturn UI.Form {\n\t\tx = 2, ex = -2, y = 2,\n\t\tptype = UI.Chooser {\n\t\t\tformLabel = 'Type', formKey = 'type', formIndex = 1,\n\t\t\twidth = 10,\n\t\t\tchoices = {\n\t\t\t\t{ name = 'Modem', value = 'wireless_modem' },\n\t\t\t\t{ name = 'Drive', value = 'disk_drive'     },\n\t\t\t},\n\t\t},\n\t\tdrive_id = UI.TextEntry {\n\t\t\tformLabel = 'Drive', formKey = 'drive_id', formIndex = 2,\n\t\t\trequired = true,\n\t\t\twidth = 5,\n\t\t\ttransform = 'number',\n\t\t},\n\t}\nend\n", "sys/modules/opus/ui/components/Notification.lua": "local class = require('opus.class')\nlocal Event = require('opus.event')\nlocal Sound = require('opus.sound')\nlocal UI    = require('opus.ui')\nlocal Util  = require('opus.util')\n\nUI.Notification = class(UI.Window)\nUI.Notification.defaults = {\n\tUIElement = 'Notification',\n\tbackgroundColor = 'gray',\n\tcloseInd = UI.extChars and '\\215' or '*',\n\theight = 3,\n\ttimeout = 3,\n\tanchor = 'bottom',\n}\nfunction UI.Notification.draw()\nend\n\nfunction UI.Notification.enable()\nend\n\nfunction UI.Notification:error(value, timeout)\n\tself.backgroundColor = 'red'\n\tSound.play('entity.villager.no', .5)\n\tself:display(value, timeout)\nend\n\nfunction UI.Notification:info(value, timeout)\n\tself.backgroundColor = 'lightGray'\n\tself:display(value, timeout)\nend\n\nfunction UI.Notification:success(value, timeout)\n\tself.backgroundColor = 'green'\n\tself:display(value, timeout)\nend\n\nfunction UI.Notification:cancel()\n\tif self.timer then\n\t\tEvent.off(self.timer)\n\t\tself.timer = nil\n\tend\n\n\tself:disable()\nend\n\nfunction UI.Notification:display(value, timeout)\n\tlocal lines = Util.wordWrap(value, self.width - 3)\n\n\tself.enabled = true\n\tself.height = #lines\n\n\tif self.anchor == 'bottom' then\n\t\tself.y = self.parent.height - self.height + 1\n\t\tself:addTransition('expandUp', { ticks = self.height })\n\telse\n\t\tself.y = 1\n\tend\n\n\tself:reposition(self.x, self.y, self.width, self.height)\n\tself:raise()\n\tself:clear()\n\tfor k,v in pairs(lines) do\n\t\tself:write(2, k, v)\n\tend\n\tself:write(self.width, 1, self.closeInd)\n\n\tif self.timer then\n\t\tEvent.off(self.timer)\n\t\tself.timer = nil\n\tend\n\n\ttimeout = timeout or self.timeout\n\tif timeout > 0 then\n\t\tself.timer = Event.onTimeout(timeout, function()\n\t\t\tself:cancel()\n\t\t\tself:sync()\n\t\tend)\n\telse\n\t\tself:sync()\n\tend\nend\n\nfunction UI.Notification:eventHandler(event)\n\tif event.type == 'mouse_click' then\n\t\tif event.x == self.width then\n\t\t\tself:cancel()\n\t\t\treturn true\n\t\tend\n\tend\nend\n\nfunction UI.Notification.example()\n\treturn UI.Window {\n\t\tnotify1 = UI.Notification {\n\t\t\tanchor = 'top',\n\t\t},\n\t\tnotify2 = UI.Notification { },\n\t\tbutton1 = UI.Button {\n\t\t\tx = 2, y = 3,\n\t\t\ttext = 'example 1',\n\t\t\tevent = 'test_success',\n\t\t},\n\t\tbutton2 = UI.Button {\n\t\t\tx = 2, y = 5,\n\t\t\ttext = 'example 2',\n\t\t\tevent = 'test_error',\n\t\t},\n\t\teventHandler = function (self, event)\n\t\t\tif event.type == 'test_success' then\n\t\t\t\tself.notify1:success('Example text')\n\t\t\telseif event.type == 'test_error' then\n\t\t\t\tself.notify2:error([[Example text test test\ntest test test test test\ntest test test]], 0)\n\t\t\tend\n\t\tend,\n\t}\nend\n", "sys/modules/opus/ui/components/ScrollBar.lua": "local class = require('opus.class')\nlocal UI    = require('opus.ui')\nlocal Util  = require('opus.util')\n\nlocal colors = _G.colors\n\nUI.ScrollBar = class(UI.Window)\nUI.ScrollBar.defaults = {\n\tUIElement = 'ScrollBar',\n\tlineChar = '\\166',\n\tsliderChar = UI.extChars and '\\127' or '#',\n\tupArrowChar = UI.extChars and '\\30' or '^',\n\tdownArrowChar = UI.extChars and '\\31' or 'v',\n\tscrollbarColor = colors.lightGray,\n\twidth = 1,\n\tx = -1,\n\tey = -1,\n}\nfunction UI.ScrollBar:draw()\n\tlocal parent = self.target or self.parent --self:find(self.target)\n\tlocal view = parent:getViewArea()\n\n\tself:clear()\n\n\t-- ...\n\tself:write(1, 1, ' ', view.fill)\n\n\tif view.totalHeight > view.height then\n\t\tlocal maxScroll = view.totalHeight - view.height\n\t\tlocal percent = view.offsetY / maxScroll\n\t\tlocal sliderSize = math.max(1, Util.round(view.height / view.totalHeight * (view.height - 2)))\n\t\tlocal x = self.width\n\n\t\tlocal row = view.y\n\t\tif not view.static then  -- does the container scroll ?\n\t\t\tself:reposition(self.x, self.y, self.width, view.totalHeight)\n\t\tend\n\n\t\tfor i = 1, view.height - 2 do\n\t\t\tself:write(x, row + i, self.lineChar, nil, self.scrollbarColor)\n\t\tend\n\n\t\tlocal y = Util.round((view.height - 2 - sliderSize) * percent)\n\t\tfor i = 1, sliderSize do\n\t\t\tself:write(x, row + y + i, self.sliderChar, nil, self.scrollbarColor)\n\t\tend\n\n\t\tlocal color = self.scrollbarColor\n\t\tif view.offsetY > 0 then\n\t\t\tcolor = colors.white\n\t\tend\n\t\tself:write(x, row, self.upArrowChar, nil, color)\n\n\t\tcolor = self.scrollbarColor\n\t\tif view.offsetY + view.height < view.totalHeight then\n\t\t\tcolor = colors.white\n\t\tend\n\t\tself:write(x, row + view.height - 1, self.downArrowChar, nil, color)\n\tend\nend\n\nfunction UI.ScrollBar:eventHandler(event)\n\tif event.type == 'mouse_click' or event.type == 'mouse_doubleclick' then\n\t\tif event.x == 1 then\n\t\t\tlocal parent = self.target or self.parent --self:find(self.target)\n\t\t\tlocal view = parent:getViewArea()\n\t\t\tif view.totalHeight > view.height then\n\t\t\t\tif event.y == view.y then\n\t\t\t\t\tparent:emit({ type = 'scroll_up'})\n\t\t\t\telseif event.y == view.y + view.height - 1 then\n\t\t\t\t\tparent:emit({ type = 'scroll_down'})\n\t\t\t\telse\n\t\t\t\t\tlocal percent = (event.y - view.y) / (view.height - 2)\n\t\t\t\t\tlocal y = math.floor((view.totalHeight - view.height) * percent)\n\t\t\t\t\tparent :emit({ type = 'scroll_to', offset = y })\n\t\t\t\tend\n\t\t\tend\n\t\t\treturn true\n\t\tend\n\tend\nend\n", "sys/modules/opus/ui/components/DropMenuItem.lua": "local class = require('opus.class')\nlocal UI    = require('opus.ui')\n\nUI.DropMenuItem = class(UI.Button)\nUI.DropMenuItem.defaults = {\n\tUIElement = 'DropMenuItem',\n\ttextColor = 'black',\n\tbackgroundColor = 'white',\n\ttextFocusColor = 'white',\n\ttextInactiveColor = 'lightGray',\n\tbackgroundFocusColor = 'lightGray',\n}\nfunction UI.DropMenuItem:eventHandler(event)\n\tif event.type == 'button_activate' then\n\t\tself.parent:disable()\n\tend\n\treturn UI.Button.eventHandler(self, event)\nend\n", "sys/modules/opus/ui/components/Image.lua": "local class = require('opus.class')\nlocal UI    = require('opus.ui')\nlocal Util  = require('opus.util')\n\nlocal lookup = '0123456789abcdef'\n\n-- handle files produced by Paint\nUI.Image = class(UI.Window)\nUI.Image.defaults = {\n\tUIElement = 'Image',\n\tevent = 'button_press',\n}\nfunction UI.Image:postInit()\n\tif self.filename then\n\t\tself.image = Util.readLines(self.filename)\n\tend\n\n\tif self.image and not (self.height or self.ey) then\n\t\tself.height = #self.image\n\tend\n\tif self.image and not (self.width or self.ex) then\n\t\tfor i = 1, self.height do\n\t\t\tself.width = math.max(self.width or 0, #self.image[i])\n\t\tend\n\tend\nend\n\nfunction UI.Image:draw()\n\tself:clear()\n\tif self.image then\n\t\tfor y = 1, #self.image do\n\t\t\tlocal line = self.image[y]\n\t\t\tfor x = 1, #line do\n\t\t\t\tlocal ch = lookup:find(line:sub(x, x))\n\t\t\t\tif ch then\n\t\t\t\t\tself:write(x, y, ' ', 2 ^ (ch - 1))\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\tself:drawChildren()\nend\n\nfunction UI.Image:setImage(image)\n\tself.image = image\nend\n\nfunction UI.Image.example()\n\treturn UI.Image {\n\t\tbackgroundColor = 'primary',\n\t\tfilename = 'test.paint',\n\t}\nend\n", "sys/modules/opus/ui/components/FileSelect.lua": "local class = require('opus.class')\nlocal UI    = require('opus.ui')\nlocal Util  = require('opus.util')\n\nlocal fs = _G.fs\n\nUI.FileSelect = class(UI.Window)\nUI.FileSelect.defaults = {\n\tUIElement = 'FileSelect',\n}\nfunction UI.FileSelect:postInit()\n\tself.grid = UI.ScrollingGrid {\n\t\tx = 2, y = 2, ex = -2, ey = -4,\n\t\tdir = '/',\n\t\tsortColumn = 'name',\n\t\tcolumns = {\n\t\t\t{ heading = 'Name', key = 'name' },\n\t\t\t{ heading = 'Size', key = 'size', width = 5 }\n\t\t},\n\t\tgetDisplayValues = function(_, row)\n\t\t\treturn {\n\t\t\t\tname = row.name,\n\t\t\t\tsize = row.size and Util.toBytes(row.size),\n\t\t\t}\n\t\tend,\n\t\tgetRowTextColor = function(_, file)\n\t\t\treturn file.isDir and 'cyan' or file.isReadOnly and 'pink' or 'white'\n\t\tend,\n\t\tsortCompare = function(self, a, b)\n\t\t\tif self.sortColumn == 'size' then\n\t\t\t\treturn a.size < b.size\n\t\t\tend\n\t\t\tif a.isDir == b.isDir then\n\t\t\t\treturn a.name:lower() < b.name:lower()\n\t\t\tend\n\t\t\treturn a.isDir\n\t\tend,\n\t\tdraw = function(self)\n\t\t\tlocal files = fs.listEx(self.dir)\n\t\t\tif #self.dir > 0 then\n\t\t\t\ttable.insert(files, {\n\t\t\t\t\tname = '..',\n\t\t\t\t\tisDir = true,\n\t\t\t\t})\n\t\t\tend\n\t\t\tself:setValues(files)\n\t\t\tself:setIndex(1)\n\t\t\tUI.Grid.draw(self)\n\t\tend,\n\t}\n\tself.path = UI.TextEntry {\n\t\tx = 2, y = -2, ex = -11,\n\t\taccelerators = {\n\t\t\tenter = 'path_enter',\n\t\t}\n\t}\n\tself.cancel = UI.Button {\n\t\tx = -9, y = -2,\n\t\ttext = 'Cancel',\n\t\tevent = 'select_cancel',\n\t}\nend\n\nfunction UI.FileSelect:draw()\n\tself:fillArea(1, 1, self.width, self.height, string.rep('\\127', self.width), 'black', 'gray')\n\tself:drawChildren()\nend\n\nfunction UI.FileSelect:enable(path)\n\tself:setPath(path or '')\n\tUI.Window.enable(self)\nend\n\nfunction UI.FileSelect:setPath(path)\n\tself.grid.dir = path\n\twhile not fs.isDir(self.grid.dir) do\n\t\tself.grid.dir = fs.getDir(self.grid.dir)\n\tend\n\tself.path.value = self.grid.dir\nend\n\nfunction UI.FileSelect:eventHandler(event)\n\tif event.type == 'grid_select' then\n\t\tself.grid.dir = fs.combine(self.grid.dir, event.selected.name)\n\t\tself.path.value = self.grid.dir\n\t\tif event.selected.isDir then\n\t\t\tself.grid:draw()\n\t\t\tself.path:draw()\n\t\telse\n\t\t\tself:emit({ type = 'select_file', file = '/' .. self.path.value, element = self })\n\t\tend\n\t\treturn true\n\n\telseif event.type == 'path_enter' then\n\t\tif self.path.value then\n\t\t\tif fs.isDir(self.path.value) then\n\t\t\t\tself:setPath(self.path.value)\n\t\t\t\tself.grid:draw()\n\t\t\t\tself.path:draw()\n\t\t\telse\n\t\t\t\tself:emit({ type = 'select_file', file = '/' .. self.path.value, element = self })\n\t\t\tend\n\t\tend\n\t\treturn true\n\tend\nend\n", "sys/modules/opus/ui/components/SlideOut.lua": "local class = require('opus.class')\nlocal UI    = require('opus.ui')\n\nUI.SlideOut = class(UI.Window)\nUI.SlideOut.defaults = {\n\tUIElement = 'SlideOut',\n\ttransitionHint = 'expandUp',\n\tmodal = true,\n}\nfunction UI.SlideOut:enable()\nend\n\nfunction UI.SlideOut:toggle()\n\tif self.enabled then\n\t\tself:hide()\n\telse\n\t\tself:show()\n\tend\nend\n\nfunction UI.SlideOut:show(...)\n\tUI.Window.enable(self, ...)\n\tself:draw()\n\tself:focusFirst()\nend\n\nfunction UI.SlideOut:hide()\n\tself:disable()\nend\n\nfunction UI.SlideOut:draw()\n\tif not self.noFill then\n\t\tself:fillArea(1, 1, self.width, self.height, string.rep('\\127', self.width), 'black', 'gray')\n\tend\n\tself:drawChildren()\nend\n\nfunction UI.SlideOut:eventHandler(event)\n\tif event.type == 'slide_show' then\n\t\tself:show()\n\t\treturn true\n\n\telseif event.type == 'slide_hide' then\n\t\tself:hide()\n\t\treturn true\n\tend\nend\n\nfunction UI.SlideOut.example()\n\treturn UI.Window {\n\t\ty = 3,\n\t\tbackgroundColor = 2048,\n\t\tbutton = UI.Button {\n\t\t\tx = 2, y = 5,\n\t\t\ttext = 'show',\n\t\t},\n\t\tslideOut = UI.SlideOut {\n\t\t\tbackgroundColor = 16,\n\t\t\ty = -7, height = 4, x = 3, ex = -3,\n\t\t\ttitleBar = UI.TitleBar {\n\t\t\t\ttitle = 'test',\n\t\t\t},\n\t\t\tbutton = UI.Button {\n\t\t\t\tx = 2, y = 2,\n\t\t\t\ttext = 'hide',\n\t\t\t\t--visualize = true,\n\t\t\t},\n\t\t},\n\t\teventHandler = function (self, event)\n\t\t\tif event.type == 'button_press' then\n\t\t\t\tself.slideOut:toggle()\n\t\t\tend\n\t\tend,\n\t}\nend\n", "sys/modules/opus/ui/components/NftImage.lua": "local class = require('opus.class')\nlocal UI    = require('opus.ui')\n\nUI.NftImage = class(UI.Window)\nUI.NftImage.defaults = {\n\tUIElement = 'NftImage',\n}\nfunction UI.NftImage:postInit()\n\tif self.image and not (self.ey or self.height) then\n\t\tself.height = self.image.height\n\tend\n\tif self.image and not (self.ex or self.width) then\n\t\tself.width = self.image.width\n\tend\nend\n\nfunction UI.NftImage:draw()\n\tself:clear()\n\n\tif self.image then\n\t\t-- due to blittle, the background and foreground transparent\n\t\t-- color is the same as the background color\n\t\tlocal bg = self:getProperty('backgroundColor')\n\t\tfor y = 1, self.image.height do\n\t\t\tfor x = 1, #self.image.text[y] do\n\t\t\t\tself:write(x, y, self.image.text[y][x], self.image.bg[y][x], self.image.fg[y][x] or bg)\n\t\t\tend\n\t\tend\n\tend\nend\n\nfunction UI.NftImage:setImage(image)\n\tself.image = image\nend\n", "sys/modules/opus/ui/components/Text.lua": "local class = require('opus.class')\nlocal UI    = require('opus.ui')\nlocal Util  = require('opus.util')\n\nUI.Text = class(UI.Window)\nUI.Text.defaults = {\n\tUIElement = 'Text',\n\tvalue = '',\n\theight = 1,\n}\nfunction UI.Text:layout()\n\tif not self.width and not self.ex then\n\t\tself.width = #tostring(self.value)\n\tend\n\tUI.Window.layout(self)\nend\n\nfunction UI.Text:draw()\n\tself:write(1, 1, Util.widthify(self.value, self.width, self.align))\nend\n", "sys/modules/opus/ui/components/Button.lua": "local class = require('opus.class')\nlocal UI    = require('opus.ui')\nlocal Util  = require('opus.util')\n\nUI.Button = class(UI.Window)\nUI.Button.defaults = {\n\tUIElement = 'Button',\n\ttext = 'button',\n\tbackgroundColor = 'lightGray',\n\tbackgroundFocusColor = 'gray',\n\ttextFocusColor = 'white',\n\ttextInactiveColor = 'gray',\n\ttextColor = 'black',\n\tcentered = true,\n\theight = 1,\n\tfocusIndicator = ' ',\n\tevent = 'button_press',\n\taccelerators = {\n\t\t[ ' ' ] = 'button_activate',\n\t\tenter = 'button_activate',\n\t\tmouse_click = 'button_activate',\n\t\tmouse_doubleclick = 'button_activate',\n\t\tmouse_tripleclick = 'button_activate',\n\t}\n}\nfunction UI.Button:layout()\n\tif not self.width and not self.ex then\n\t\tself.width = self.noPadding and #self.text or #self.text + 2\n\tend\n\tUI.Window.layout(self)\nend\n\nfunction UI.Button:draw()\n\tlocal fg = self.textColor\n\tlocal bg = self.backgroundColor\n\tlocal ind = ' '\n\tif self.focused then\n\t\tbg = self:getProperty('backgroundFocusColor')\n\t\tfg = self:getProperty('textFocusColor')\n\t\tind = self.focusIndicator\n\telseif self.inactive then\n\t\tfg = self:getProperty('textInactiveColor')\n\tend\n\tlocal text = self.noPadding and self.text or ind .. self.text .. ' '\n\tif self.centered then\n\t\tself:clear(bg)\n\t\tself:centeredWrite(1 + math.floor(self.height / 2), text, bg, fg)\n\telse\n\t\tself:write(1, 1, Util.widthify(text, self.width), bg, fg)\n\tend\nend\n\nfunction UI.Button:focus()\n\tif self.focused then\n\t\tself:scrollIntoView()\n\tend\n\tself:draw()\nend\n\nfunction UI.Button:eventHandler(event)\n\tif event.type == 'button_activate' then\n\t\tself:emit({ type = self.event, button = self, element = self })\n\t\treturn true\n\tend\n\treturn false\nend\n\nfunction UI.Button.example()\n\treturn UI.Window {\n\t\tbutton1 = UI.Button {\n\t\t\tx = 2, y = 2,\n\t\t\ttext = 'Press',\n\t\t},\n\t\tbutton2 = UI.Button {\n\t\t\tx = 2, y = 4,\n\t\t\tbackgroundColor = 'green',\n\t\t\tevent = 'custom_event',\n\t\t},\n\t\tbutton3 = UI.Button {\n\t\t\tx = 12, y = 2,\n\t\t\theight = 5,\n\t\t\tevent = 'big_event',\n\t\t\ttext = 'large button'\n\t\t}\n\t}\nend\n", "sys/modules/opus/crypto/chacha20.lua": "-- Chacha20 cipher in ComputerCraft\n-- By Anavrins\n\nlocal cbor = require('opus.cbor')\nlocal sha2 = require('opus.crypto.sha2')\nlocal Util = require('opus.util')\n\nlocal ROUNDS = 8 -- Adjust this for speed tradeoff\n\nlocal bxor = bit32.bxor\nlocal band = bit32.band\nlocal blshift = bit32.lshift\nlocal brshift = bit32.arshift\nlocal textutils = _G.textutils\nlocal mt = Util.byteArrayMT\n\nlocal mod = 2^32\nlocal tau = {(\"expand 16-byte k\"):byte(1,-1)}\nlocal sigma = {(\"expand 32-byte k\"):byte(1,-1)}\n\nlocal function rotl(n, b)\n\tlocal s = n/(2^(32-b))\n\tlocal f = s%1\n\treturn (s-f) + f*mod\nend\n\nlocal function quarterRound(s, a, b, c, d)\n\ts[a] = (s[a]+s[b])%mod; s[d] = rotl(bxor(s[d], s[a]), 16)\n\ts[c] = (s[c]+s[d])%mod; s[b] = rotl(bxor(s[b], s[c]), 12)\n\ts[a] = (s[a]+s[b])%mod; s[d] = rotl(bxor(s[d], s[a]), 8)\n\ts[c] = (s[c]+s[d])%mod; s[b] = rotl(bxor(s[b], s[c]), 7)\n\treturn s\nend\n\nlocal function hashBlock(state, rnd)\n\tlocal s = {table.unpack(state)}\n\tfor i = 1, rnd do\n\t\tlocal r = i%2==1\n\t\ts = r and quarterRound(s, 1, 5,  9, 13) or quarterRound(s, 1, 6, 11, 16)\n\t\ts = r and quarterRound(s, 2, 6, 10, 14) or quarterRound(s, 2, 7, 12, 13)\n\t\ts = r and quarterRound(s, 3, 7, 11, 15) or quarterRound(s, 3, 8,  9, 14)\n\t\ts = r and quarterRound(s, 4, 8, 12, 16) or quarterRound(s, 4, 5, 10, 15)\n\tend\n\tfor i = 1, 16 do s[i] = (s[i]+state[i])%mod end\n\treturn s\nend\n\nlocal function LE_toInt(bs, i)\n\treturn (bs[i+1] or 0)+\n\tblshift((bs[i+2] or 0), 8)+\n\tblshift((bs[i+3] or 0), 16)+\n\tblshift((bs[i+4] or 0), 24)\nend\n\nlocal function initState(key, nonce, counter)\n\tlocal isKey256 = #key == 32\n\tlocal const = isKey256 and sigma or tau\n\tlocal state = {}\n\n\tstate[ 1] = LE_toInt(const, 0)\n\tstate[ 2] = LE_toInt(const, 4)\n\tstate[ 3] = LE_toInt(const, 8)\n\tstate[ 4] = LE_toInt(const, 12)\n\n\tstate[ 5] = LE_toInt(key, 0)\n\tstate[ 6] = LE_toInt(key, 4)\n\tstate[ 7] = LE_toInt(key, 8)\n\tstate[ 8] = LE_toInt(key, 12)\n\tstate[ 9] = LE_toInt(key, isKey256 and 16 or 0)\n\tstate[10] = LE_toInt(key, isKey256 and 20 or 4)\n\tstate[11] = LE_toInt(key, isKey256 and 24 or 8)\n\tstate[12] = LE_toInt(key, isKey256 and 28 or 12)\n\n\tstate[13] = counter\n\tstate[14] = LE_toInt(nonce, 0)\n\tstate[15] = LE_toInt(nonce, 4)\n\tstate[16] = LE_toInt(nonce, 8)\n\n\treturn state\nend\n\nlocal function serialize(state)\n\tlocal r = {}\n\tfor i = 1, 16 do\n\t\tr[#r+1] = band(state[i], 0xFF)\n\t\tr[#r+1] = band(brshift(state[i], 8), 0xFF)\n\t\tr[#r+1] = band(brshift(state[i], 16), 0xFF)\n\t\tr[#r+1] = band(brshift(state[i], 24), 0xFF)\n\tend\n\treturn r\nend\n\nlocal function crypt(data, key, nonce, cntr, round)\n\tassert(type(key) == \"table\", \"ChaCha20: Invalid key format (\"..type(key)..\"), must be table\")\n\tassert(type(nonce) == \"table\", \"ChaCha20: Invalid nonce format (\"..type(nonce)..\"), must be table\")\n\tassert(#key == 16 or #key == 32, \"ChaCha20: Invalid key length (\"..#key..\"), must be 16 or 32\")\n\tassert(#nonce == 12, \"ChaCha20: Invalid nonce length (\"..#nonce..\"), must be 12\")\n\n\tdata = type(data) == \"table\" and {table.unpack(data)} or {tostring(data):byte(1,-1)}\n\tcntr = tonumber(cntr) or 1\n\tround = tonumber(round) or 20\n\n\tlocal throttle = Util.throttle()\n\tlocal out = {}\n\tlocal state = initState(key, nonce, cntr)\n\tlocal blockAmt = math.floor(#data/64)\n\tfor i = 0, blockAmt do\n\t\tlocal ks = serialize(hashBlock(state, round))\n\t\tstate[13] = (state[13]+1) % mod\n\n\t\tlocal block = {}\n\t\tfor j = 1, 64 do\n\t\t\tblock[j] = data[((i)*64)+j]\n\t\tend\n\t\tfor j = 1, #block do\n\t\t\tout[#out+1] = bxor(block[j], ks[j])\n\t\tend\n\n\t\tthrottle()\n\tend\n\treturn setmetatable(out, mt)\nend\n\n-- Helper functions\nlocal function genNonce(len)\n\tlocal nonce = {}\n\tfor i = 1, len do\n\t\tnonce[i] = math.random(0, 0xFF)\n\tend\n\treturn setmetatable(nonce, mt)\nend\n\nlocal function encrypt(data, key)\n\tlocal nonce = genNonce(12)\n\tdata = cbor.encode(data)\n\tkey = sha2.digest(key)\n\tlocal ctx = crypt(data, key, nonce, 1, ROUNDS)\n\n\treturn { nonce:toHex(), ctx:toHex() }\nend\n\nlocal function decrypt(data, key)\n\tlocal nonce = Util.hexToByteArray(data[1])\n\tdata = Util.hexToByteArray(data[2])\n\tkey = sha2.digest(key)\n\tlocal ptx = crypt(data, key, nonce, 1, ROUNDS)\n\treturn cbor.decode(tostring(ptx))\nend\n\nlocal obj = {}\nlocal rng_mt = {['__index'] = obj}\n\n-- PRNG object\nlocal null32 = {(\"A\"):rep(32):byte(1,-1)}\nlocal null12 = {(\"A\"):rep(12):byte(1,-1)}\nfunction obj:nextInt(byte)\n\tif not byte or byte < 1 or byte > 6 then error(\"Can only return 1-6 bytes\", 2) end\n\tlocal output = 0\n\tfor i = 0, byte-1 do\n\t\tif #self.block == 0 then\n\t\t\tself.cnt = self.cnt + 1\n\t\t\tself.block = crypt(null32, self.seed, null12, self.cnt)\n\t\tend\n\n\t\tlocal newByte = table.remove(self.block)\n\t\toutput = output + (newByte * (2^(8*i)))\n\tend\n\treturn output\nend\n\nlocal function newRNG(seed)\n\tlocal o = {}\n\to.seed = seed\n\to.cnt = 0\n\to.block = {}\n\n\treturn setmetatable(o, rng_mt)\nend\n\nreturn {\n\tencrypt = encrypt,\n\tdecrypt = decrypt,\n\tnewRNG  = newRNG,\n}\n", "sys/modules/opus/crypto/sha2.lua": "-- SHA-256, HMAC and PBKDF2 functions in ComputerCraft\n-- By Anavrins\nlocal Util = require('opus.util')\n\nlocal bit     = _G.bit\nlocal mod32   = 2^32\nlocal band    = bit32 and bit32.band or bit.band\nlocal bnot    = bit32 and bit32.bnot or bit.bnot\nlocal bxor    = bit32 and bit32.bxor or bit.bxor\nlocal blshift = bit32 and bit32.lshift or bit.blshift\nlocal upack   = unpack or table.unpack\nlocal mt      = Util.byteArrayMT\n\nlocal function rrotate(n, b)\n\tlocal s = n/(2^b)\n\tlocal f = s%1\n\treturn (s-f) + f*mod32\nend\nlocal function brshift(int, by)\n\tlocal s = int / (2^by)\n\treturn s - s%1\nend\n\nlocal H = {\n\t0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,\n\t0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19,\n}\n\nlocal K = {\n\t0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n\t0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n\t0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n\t0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n\t0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n\t0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n\t0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n\t0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2,\n}\n\nlocal function counter(incr)\n\tlocal t1, t2 = 0, 0\n\tif 0xFFFFFFFF - t1 < incr then\n\t\tt2 = t2 + 1\n\t\tt1 = incr - (0xFFFFFFFF - t1) - 1\n\telse t1 = t1 + incr\n\tend\n\treturn t2, t1\nend\n\nlocal function BE_toInt(bs, i)\n\treturn blshift((bs[i] or 0), 24) + blshift((bs[i+1] or 0), 16) + blshift((bs[i+2] or 0), 8) + (bs[i+3] or 0)\nend\n\nlocal function preprocess(data)\n\tlocal len = #data\n\tlocal proc = {}\n\tdata[#data+1] = 0x80\n\twhile #data%64~=56 do data[#data+1] = 0 end\n\tlocal blocks = math.ceil(#data/64)\n\tfor i = 1, blocks do\n\t\tproc[i] = {}\n\t\tfor j = 1, 16 do\n\t\t\tproc[i][j] = BE_toInt(data, 1+((i-1)*64)+((j-1)*4))\n\t\tend\n\tend\n\tproc[blocks][15], proc[blocks][16] = counter(len*8)\n\treturn proc\nend\n\nlocal function digestblock(w, C)\n\tfor j = 17, 64 do\n\t\tlocal s0 = bxor(rrotate(w[j-15], 7), rrotate(w[j-15], 18), brshift(w[j-15], 3))\n\t\tlocal s1 = bxor(rrotate(w[j-2], 17), rrotate(w[j-2], 19), brshift(w[j-2], 10))\n\t\tw[j] = (w[j-16] + s0 + w[j-7] + s1)%mod32\n\tend\n\tlocal a, b, c, d, e, f, g, h = upack(C)\n\tfor j = 1, 64 do\n\t\tlocal S1 = bxor(rrotate(e, 6), rrotate(e, 11), rrotate(e, 25))\n\t\tlocal ch = bxor(band(e, f), band(bnot(e), g))\n\t\tlocal temp1 = (h + S1 + ch + K[j] + w[j])%mod32\n\t\tlocal S0 = bxor(rrotate(a, 2), rrotate(a, 13), rrotate(a, 22))\n\t\tlocal maj = bxor(bxor(band(a, b), band(a, c)), band(b, c))\n\t\tlocal temp2 = (S0 + maj)%mod32\n\t\th, g, f, e, d, c, b, a = g, f, e, (d+temp1)%mod32, c, b, a, (temp1+temp2)%mod32\n\tend\n\tC[1] = (C[1] + a)%mod32\n\tC[2] = (C[2] + b)%mod32\n\tC[3] = (C[3] + c)%mod32\n\tC[4] = (C[4] + d)%mod32\n\tC[5] = (C[5] + e)%mod32\n\tC[6] = (C[6] + f)%mod32\n\tC[7] = (C[7] + g)%mod32\n\tC[8] = (C[8] + h)%mod32\n\treturn C\nend\n\nlocal function toBytes(t, n)\n\tlocal b = {}\n\tfor i = 1, n do\n\t\tb[(i-1)*4+1] = band(brshift(t[i], 24), 0xFF)\n\t\tb[(i-1)*4+2] = band(brshift(t[i], 16), 0xFF)\n\t\tb[(i-1)*4+3] = band(brshift(t[i], 8), 0xFF)\n\t\tb[(i-1)*4+4] = band(t[i], 0xFF)\n\tend\n\treturn setmetatable(b, mt)\nend\n\nlocal function digest(data)\n\tdata = data or \"\"\n\tdata = type(data) == \"table\" and {upack(data)} or {tostring(data):byte(1,-1)}\n\n\tdata = preprocess(data)\n\tlocal C = {upack(H)}\n\tfor i = 1, #data do C = digestblock(data[i], C) end\n\treturn toBytes(C, 8)\nend\n\nlocal function hmac(data, key)\n\tdata = type(data) == \"table\" and {upack(data)} or {tostring(data):byte(1,-1)}\n\tkey = type(key) == \"table\" and {upack(key)} or {tostring(key):byte(1,-1)}\n\n\tlocal blocksize = 64\n\n\tkey = #key > blocksize and digest(key) or key\n\n\tlocal ipad = {}\n\tlocal opad = {}\n\tlocal padded_key = {}\n\n\tfor i = 1, blocksize do\n\t\tipad[i] = bxor(0x36, key[i] or 0)\n\t\topad[i] = bxor(0x5C, key[i] or 0)\n\tend\n\n\tfor i = 1, #data do\n\t\tipad[blocksize+i] = data[i]\n\tend\n\n\tipad = digest(ipad)\n\n\tfor i = 1, blocksize do\n\t\tpadded_key[i] = opad[i]\n\t\tpadded_key[blocksize+i] = ipad[i]\n\tend\n\n\treturn digest(padded_key)\nend\n\nlocal function pbkdf2(pass, salt, iter, dklen)\n\tsalt = type(salt) == \"table\" and salt or {tostring(salt):byte(1,-1)}\n\tlocal hashlen = 32\n\tdklen = dklen or 32\n\tlocal block = 1\n\tlocal out = {}\n\tlocal throttle = Util.throttle()\n\n\twhile dklen > 0 do\n\t\tlocal ikey = {}\n\t\tlocal isalt = {upack(salt)}\n\t\tlocal clen = dklen > hashlen and hashlen or dklen\n\n\t\tisalt[#isalt+1] = band(brshift(block, 24), 0xFF)\n\t\tisalt[#isalt+1] = band(brshift(block, 16), 0xFF)\n\t\tisalt[#isalt+1] = band(brshift(block, 8), 0xFF)\n\t\tisalt[#isalt+1] = band(block, 0xFF)\n\n\t\tfor j = 1, iter do\n\t\t\tisalt = hmac(isalt, pass)\n\t\t\tfor k = 1, clen do ikey[k] = bxor(isalt[k], ikey[k] or 0) end\n\t\t\tif j % 200 == 0 then\n\t\t\t\tthrottle()\n\t\t\t\t--os.queueEvent(\"PBKDF2\", j) coroutine.yield(\"PBKDF2\")\n\t\t\tend\n\t\tend\n\t\tdklen = dklen - clen\n\t\tblock = block+1\n\t\tfor k = 1, clen do out[#out+1] = ikey[k] end\n\tend\n\n\treturn setmetatable(out, mt)\nend\n\nlocal function compute(data)\n\treturn digest(data):toHex()\nend\n\nreturn {\n\tdigest = digest,\n\tcompute = compute,\n\thmac = hmac,\n\tpbkdf2 = pbkdf2,\n}\n", "sys/modules/opus/crypto/ecc/init.lua": "local fq       = require('opus.crypto.ecc.fq')\nlocal elliptic = require('opus.crypto.ecc.elliptic')\nlocal sha256   = require('opus.crypto.sha2')\nlocal Util     = require('opus.util')\n\n\nlocal os = _G.os\nlocal unpack = table.unpack\nlocal mt = Util.byteArrayMT\n\nlocal q = {1372, 62520, 47765, 8105, 45059, 9616, 65535, 65535, 65535, 65535, 65535, 65532}\n\nlocal sLen = 24\nlocal eLen = 24\n\nlocal function hashModQ(sk)\n\tlocal hash = sha256.hmac({0x00}, sk)\n\tlocal x\n\trepeat\n\t\thash = sha256.digest(hash)\n\t\tx = fq.fromBytes(hash)\n\tuntil fq.cmp(x, q) <= 0\n\n\treturn x\nend\n\nlocal function publicKey(sk)\n\tlocal x = hashModQ(sk)\n\n\tlocal Y = elliptic.scalarMulG(x)\n\tlocal pk = elliptic.pointEncode(Y)\n\n\treturn setmetatable(pk, mt)\nend\n\nlocal function exchange(sk, pk)\n\tlocal Y = elliptic.pointDecode(pk)\n\tlocal x = hashModQ(sk)\n\n\tlocal Z = elliptic.scalarMul(x, Y)\n\tZ = elliptic.pointScale(Z)\n\n\tlocal ss = fq.bytes(Z[2])\n\treturn sha256.digest(ss)\nend\n\nlocal function sign(sk, message)\n\tmessage = type(message) == \"table\" and string.char(unpack(message)) or message\n\tsk = type(sk) == \"table\" and string.char(unpack(sk)) or sk\n\tlocal epoch = tostring(os.epoch(\"utc\"))\n\tlocal x = hashModQ(sk)\n\tlocal k = hashModQ(message .. epoch .. sk)\n\n\tlocal R = elliptic.scalarMulG(k)\n\tR = string.char(unpack(elliptic.pointEncode(R)))\n\tlocal e = hashModQ(R .. message)\n\tlocal s = fq.sub(k, fq.mul(x, e))\n\n\te = fq.bytes(e)\n\ts = fq.bytes(s)\n\n\tlocal sig = {unpack(e)}\n\n\tfor i = 1, #s do\n\t\tsig[#sig + 1] = s[i]\n\tend\n\n\treturn setmetatable(sig, mt)\nend\n\nlocal function verify(pk, message, sig)\n\tlocal Y = elliptic.pointDecode(pk)\n\tlocal e = {unpack(sig, 1, eLen)}\n\tlocal s = {unpack(sig, eLen + 1, eLen + sLen)}\n\n\te = fq.fromBytes(e)\n\ts = fq.fromBytes(s)\n\n\tlocal R = elliptic.pointAdd(elliptic.scalarMulG(s), elliptic.scalarMul(e, Y))\n\tR = string.char(unpack(elliptic.pointEncode(R)))\n\tlocal e2 = hashModQ(R .. message)\n\n\treturn fq.eq(e2, e)\nend\n\nreturn {\n\tpublicKey = publicKey,\n\texchange = exchange,\n\tsign = sign,\n\tverify = verify,\n}\n", "sys/modules/opus/crypto/ecc/fp.lua": "-- Fp Integer Arithmetic\n\nlocal unpack = table.unpack\n\nlocal n = 0xffff\nlocal m = 0x10000\n\nlocal p = {3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 65533}\nlocal p2 = {21845, 21845, 21845, 21845, 21845, 21845, 21845, 21845, 21845, 21845, 21845, 43690}\nlocal r2 = {44014, 58358, 19452, 6484, 45852, 58974, 63348, 64806, 65292, 65454, 65508, 21512}\n\nlocal function eq(a, b)\n\tfor i = 1, 12 do\n\t\tif a[i] ~= b[i] then\n\t\t\treturn false\n\t\tend\n\tend\n\n\treturn true\nend\n\nlocal function reduce(a)\n\tlocal r1 = a[1]\n\tlocal r2 = a[2]\n\tlocal r3 = a[3]\n\tlocal r4 = a[4]\n\tlocal r5 = a[5]\n\tlocal r6 = a[6]\n\tlocal r7 = a[7]\n\tlocal r8 = a[8]\n\tlocal r9 = a[9]\n\tlocal r10 = a[10]\n\tlocal r11 = a[11]\n\tlocal r12 = a[12]\n\n\tif r12 < 65533 or r12 == 65533 and r1 < 3 then\n\t\treturn {unpack(a)}\n\tend\n\n\tr1 = r1 - 3\n\tr12 = r12 - 65533\n\n\tif r1 < 0 then\n\t\tr2 = r2 - 1\n\t\tr1 = r1 + m\n\tend\n\tif r2 < 0 then\n\t\tr3 = r3 - 1\n\t\tr2 = r2 + m\n\tend\n\tif r3 < 0 then\n\t\tr4 = r4 - 1\n\t\tr3 = r3 + m\n\tend\n\tif r4 < 0 then\n\t\tr5 = r5 - 1\n\t\tr4 = r4 + m\n\tend\n\tif r5 < 0 then\n\t\tr6 = r6 - 1\n\t\tr5 = r5 + m\n\tend\n\tif r6 < 0 then\n\t\tr7 = r7 - 1\n\t\tr6 = r6 + m\n\tend\n\tif r7 < 0 then\n\t\tr8 = r8 - 1\n\t\tr7 = r7 + m\n\tend\n\tif r8 < 0 then\n\t\tr9 = r9 - 1\n\t\tr8 = r8 + m\n\tend\n\tif r9 < 0 then\n\t\tr10 = r10 - 1\n\t\tr9 = r9 + m\n\tend\n\tif r10 < 0 then\n\t\tr11 = r11 - 1\n\t\tr10 = r10 + m\n\tend\n\tif r11 < 0 then\n\t\tr12 = r12 - 1\n\t\tr11 = r11 + m\n\tend\n\n\treturn {r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12}\nend\n\nlocal function add(a, b)\n\tlocal r1 = a[1] + b[1]\n\tlocal r2 = a[2] + b[2]\n\tlocal r3 = a[3] + b[3]\n\tlocal r4 = a[4] + b[4]\n\tlocal r5 = a[5] + b[5]\n\tlocal r6 = a[6] + b[6]\n\tlocal r7 = a[7] + b[7]\n\tlocal r8 = a[8] + b[8]\n\tlocal r9 = a[9] + b[9]\n\tlocal r10 = a[10] + b[10]\n\tlocal r11 = a[11] + b[11]\n\tlocal r12 = a[12] + b[12]\n\n\tif r1 > n then\n\t\tr2 = r2 + 1\n\t\tr1 = r1 - m\n\tend\n\tif r2 > n then\n\t\tr3 = r3 + 1\n\t\tr2 = r2 - m\n\tend\n\tif r3 > n then\n\t\tr4 = r4 + 1\n\t\tr3 = r3 - m\n\tend\n\tif r4 > n then\n\t\tr5 = r5 + 1\n\t\tr4 = r4 - m\n\tend\n\tif r5 > n then\n\t\tr6 = r6 + 1\n\t\tr5 = r5 - m\n\tend\n\tif r6 > n then\n\t\tr7 = r7 + 1\n\t\tr6 = r6 - m\n\tend\n\tif r7 > n then\n\t\tr8 = r8 + 1\n\t\tr7 = r7 - m\n\tend\n\tif r8 > n then\n\t\tr9 = r9 + 1\n\t\tr8 = r8 - m\n\tend\n\tif r9 > n then\n\t\tr10 = r10 + 1\n\t\tr9 = r9 - m\n\tend\n\tif r10 > n then\n\t\tr11 = r11 + 1\n\t\tr10 = r10 - m\n\tend\n\tif r11 > n then\n\t\tr12 = r12 + 1\n\t\tr11 = r11 - m\n\tend\n\n\tlocal result = {r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12}\n\n\treturn reduce(result)\nend\n\nlocal function shr(a)\n\tlocal r1 = a[1]\n\tlocal r2 = a[2]\n\tlocal r3 = a[3]\n\tlocal r4 = a[4]\n\tlocal r5 = a[5]\n\tlocal r6 = a[6]\n\tlocal r7 = a[7]\n\tlocal r8 = a[8]\n\tlocal r9 = a[9]\n\tlocal r10 = a[10]\n\tlocal r11 = a[11]\n\tlocal r12 = a[12]\n\n\tr1 = r1 / 2\n\tr1 = r1 - r1 % 1\n\tr1 = r1 + (r2 % 2) * 0x8000\n\tr2 = r2 / 2\n\tr2 = r2 - r2 % 1\n\tr2 = r2 + (r3 % 2) * 0x8000\n\tr3 = r3 / 2\n\tr3 = r3 - r3 % 1\n\tr3 = r3 + (r4 % 2) * 0x8000\n\tr4 = r4 / 2\n\tr4 = r4 - r4 % 1\n\tr4 = r4 + (r5 % 2) * 0x8000\n\tr5 = r5 / 2\n\tr5 = r5 - r5 % 1\n\tr5 = r5 + (r6 % 2) * 0x8000\n\tr6 = r6 / 2\n\tr6 = r6 - r6 % 1\n\tr6 = r6 + (r7 % 2) * 0x8000\n\tr7 = r7 / 2\n\tr7 = r7 - r7 % 1\n\tr7 = r7 + (r8 % 2) * 0x8000\n\tr8 = r8 / 2\n\tr8 = r8 - r8 % 1\n\tr8 = r8 + (r9 % 2) * 0x8000\n\tr9 = r9 / 2\n\tr9 = r9 - r9 % 1\n\tr9 = r9 + (r10 % 2) * 0x8000\n\tr10 = r10 / 2\n\tr10 = r10 - r10 % 1\n\tr10 = r10 + (r11 % 2) * 0x8000\n\tr11 = r11 / 2\n\tr11 = r11 - r11 % 1\n\tr11 = r11 + (r12 % 2) * 0x8000\n\tr12 = r12 / 2\n\tr12 = r12 - r12 % 1\n\n\tlocal result = {r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12}\n\n\treturn result\nend\n\nlocal function sub192(a, b)\n\tlocal r1 = a[1] - b[1]\n\tlocal r2 = a[2] - b[2]\n\tlocal r3 = a[3] - b[3]\n\tlocal r4 = a[4] - b[4]\n\tlocal r5 = a[5] - b[5]\n\tlocal r6 = a[6] - b[6]\n\tlocal r7 = a[7] - b[7]\n\tlocal r8 = a[8] - b[8]\n\tlocal r9 = a[9] - b[9]\n\tlocal r10 = a[10] - b[10]\n\tlocal r11 = a[11] - b[11]\n\tlocal r12 = a[12] - b[12]\n\n\tif r1 < 0 then\n\t\tr2 = r2 - 1\n\t\tr1 = r1 + m\n\tend\n\tif r2 < 0 then\n\t\tr3 = r3 - 1\n\t\tr2 = r2 + m\n\tend\n\tif r3 < 0 then\n\t\tr4 = r4 - 1\n\t\tr3 = r3 + m\n\tend\n\tif r4 < 0 then\n\t\tr5 = r5 - 1\n\t\tr4 = r4 + m\n\tend\n\tif r5 < 0 then\n\t\tr6 = r6 - 1\n\t\tr5 = r5 + m\n\tend\n\tif r6 < 0 then\n\t\tr7 = r7 - 1\n\t\tr6 = r6 + m\n\tend\n\tif r7 < 0 then\n\t\tr8 = r8 - 1\n\t\tr7 = r7 + m\n\tend\n\tif r8 < 0 then\n\t\tr9 = r9 - 1\n\t\tr8 = r8 + m\n\tend\n\tif r9 < 0 then\n\t\tr10 = r10 - 1\n\t\tr9 = r9 + m\n\tend\n\tif r10 < 0 then\n\t\tr11 = r11 - 1\n\t\tr10 = r10 + m\n\tend\n\tif r11 < 0 then\n\t\tr12 = r12 - 1\n\t\tr11 = r11 + m\n\tend\n\n\tlocal result = {r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12}\n\t\n\treturn result\nend\n\nlocal function sub(a, b)\n\tlocal r1 = a[1] - b[1]\n\tlocal r2 = a[2] - b[2]\n\tlocal r3 = a[3] - b[3]\n\tlocal r4 = a[4] - b[4]\n\tlocal r5 = a[5] - b[5]\n\tlocal r6 = a[6] - b[6]\n\tlocal r7 = a[7] - b[7]\n\tlocal r8 = a[8] - b[8]\n\tlocal r9 = a[9] - b[9]\n\tlocal r10 = a[10] - b[10]\n\tlocal r11 = a[11] - b[11]\n\tlocal r12 = a[12] - b[12]\n\n\tif r1 < 0 then\n\t\tr2 = r2 - 1\n\t\tr1 = r1 + m\n\tend\n\tif r2 < 0 then\n\t\tr3 = r3 - 1\n\t\tr2 = r2 + m\n\tend\n\tif r3 < 0 then\n\t\tr4 = r4 - 1\n\t\tr3 = r3 + m\n\tend\n\tif r4 < 0 then\n\t\tr5 = r5 - 1\n\t\tr4 = r4 + m\n\tend\n\tif r5 < 0 then\n\t\tr6 = r6 - 1\n\t\tr5 = r5 + m\n\tend\n\tif r6 < 0 then\n\t\tr7 = r7 - 1\n\t\tr6 = r6 + m\n\tend\n\tif r7 < 0 then\n\t\tr8 = r8 - 1\n\t\tr7 = r7 + m\n\tend\n\tif r8 < 0 then\n\t\tr9 = r9 - 1\n\t\tr8 = r8 + m\n\tend\n\tif r9 < 0 then\n\t\tr10 = r10 - 1\n\t\tr9 = r9 + m\n\tend\n\tif r10 < 0 then\n\t\tr11 = r11 - 1\n\t\tr10 = r10 + m\n\tend\n\tif r11 < 0 then\n\t\tr12 = r12 - 1\n\t\tr11 = r11 + m\n\tend\n\n\tlocal result = {r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12}\n\n\tif r12 < 0 then\n\t\tresult = add(result, p)\n\tend\n\n\treturn result\nend\n\nlocal function add384(a, b)\n\tlocal r1 = a[1] + b[1]\n\tlocal r2 = a[2] + b[2]\n\tlocal r3 = a[3] + b[3]\n\tlocal r4 = a[4] + b[4]\n\tlocal r5 = a[5] + b[5]\n\tlocal r6 = a[6] + b[6]\n\tlocal r7 = a[7] + b[7]\n\tlocal r8 = a[8] + b[8]\n\tlocal r9 = a[9] + b[9]\n\tlocal r10 = a[10] + b[10]\n\tlocal r11 = a[11] + b[11]\n\tlocal r12 = a[12] + b[12]\n\tlocal r13 = a[13] + b[13]\n\tlocal r14 = a[14] + b[14]\n\tlocal r15 = a[15] + b[15]\n\tlocal r16 = a[16] + b[16]\n\tlocal r17 = a[17] + b[17]\n\tlocal r18 = a[18] + b[18]\n\tlocal r19 = a[19] + b[19]\n\tlocal r20 = a[20] + b[20]\n\tlocal r21 = a[21] + b[21]\n\tlocal r22 = a[22] + b[22]\n\tlocal r23 = a[23] + b[23]\n\tlocal r24 = a[24] + b[24]\n\n\tif r1 > n then\n\t\tr2 = r2 + 1\n\t\tr1 = r1 - m\n\tend\n\tif r2 > n then\n\t\tr3 = r3 + 1\n\t\tr2 = r2 - m\n\tend\n\tif r3 > n then\n\t\tr4 = r4 + 1\n\t\tr3 = r3 - m\n\tend\n\tif r4 > n then\n\t\tr5 = r5 + 1\n\t\tr4 = r4 - m\n\tend\n\tif r5 > n then\n\t\tr6 = r6 + 1\n\t\tr5 = r5 - m\n\tend\n\tif r6 > n then\n\t\tr7 = r7 + 1\n\t\tr6 = r6 - m\n\tend\n\tif r7 > n then\n\t\tr8 = r8 + 1\n\t\tr7 = r7 - m\n\tend\n\tif r8 > n then\n\t\tr9 = r9 + 1\n\t\tr8 = r8 - m\n\tend\n\tif r9 > n then\n\t\tr10 = r10 + 1\n\t\tr9 = r9 - m\n\tend\n\tif r10 > n then\n\t\tr11 = r11 + 1\n\t\tr10 = r10 - m\n\tend\n\tif r11 > n then\n\t\tr12 = r12 + 1\n\t\tr11 = r11 - m\n\tend\n\tif r12 > n then\n\t\tr13 = r13 + 1\n\t\tr12 = r12 - m\n\tend\n\tif r13 > n then\n\t\tr14 = r14 + 1\n\t\tr13 = r13 - m\n\tend\n\tif r14 > n then\n\t\tr15 = r15 + 1\n\t\tr14 = r14 - m\n\tend\n\tif r15 > n then\n\t\tr16 = r16 + 1\n\t\tr15 = r15 - m\n\tend\n\tif r16 > n then\n\t\tr17 = r17 + 1\n\t\tr16 = r16 - m\n\tend\n\tif r17 > n then\n\t\tr18 = r18 + 1\n\t\tr17 = r17 - m\n\tend\n\tif r18 > n then\n\t\tr19 = r19 + 1\n\t\tr18 = r18 - m\n\tend\n\tif r19 > n then\n\t\tr20 = r20 + 1\n\t\tr19 = r19 - m\n\tend\n\tif r20 > n then\n\t\tr21 = r21 + 1\n\t\tr20 = r20 - m\n\tend\n\tif r21 > n then\n\t\tr22 = r22 + 1\n\t\tr21 = r21 - m\n\tend\n\tif r22 > n then\n\t\tr23 = r23 + 1\n\t\tr22 = r22 - m\n\tend\n\tif r23 > n then\n\t\tr24 = r24 + 1\n\t\tr23 = r23 - m\n\tend\n\n\tlocal result = {r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, r13, r14, r15, r16, r17, r18, r19, r20, r21, r22, r23, r24}\n\n\treturn result\nend\n\nlocal function mul384(a, b)\n\tlocal a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12 = unpack(a)\n\tlocal b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12 = unpack(b)\n\n\tlocal r1 = a1 * b1\n\n\tlocal r2 = a1 * b2\n\tr2 = r2 + a2 * b1\n\n\tlocal r3 = a1 * b3\n\tr3 = r3 + a2 * b2\n\tr3 = r3 + a3 * b1\n\n\tlocal r4 = a1 * b4\n\tr4 = r4 + a2 * b3\n\tr4 = r4 + a3 * b2\n\tr4 = r4 + a4 * b1\n\n\tlocal r5 = a1 * b5\n\tr5 = r5 + a2 * b4\n\tr5 = r5 + a3 * b3\n\tr5 = r5 + a4 * b2\n\tr5 = r5 + a5 * b1\n\n\tlocal r6 = a1 * b6\n\tr6 = r6 + a2 * b5\n\tr6 = r6 + a3 * b4\n\tr6 = r6 + a4 * b3\n\tr6 = r6 + a5 * b2\n\tr6 = r6 + a6 * b1\n\n\tlocal r7 = a1 * b7\n\tr7 = r7 + a2 * b6\n\tr7 = r7 + a3 * b5\n\tr7 = r7 + a4 * b4\n\tr7 = r7 + a5 * b3\n\tr7 = r7 + a6 * b2\n\tr7 = r7 + a7 * b1\n\n\tlocal r8 = a1 * b8\n\tr8 = r8 + a2 * b7\n\tr8 = r8 + a3 * b6\n\tr8 = r8 + a4 * b5\n\tr8 = r8 + a5 * b4\n\tr8 = r8 + a6 * b3\n\tr8 = r8 + a7 * b2\n\tr8 = r8 + a8 * b1\n\n\tlocal r9 = a1 * b9\n\tr9 = r9 + a2 * b8\n\tr9 = r9 + a3 * b7\n\tr9 = r9 + a4 * b6\n\tr9 = r9 + a5 * b5\n\tr9 = r9 + a6 * b4\n\tr9 = r9 + a7 * b3\n\tr9 = r9 + a8 * b2\n\tr9 = r9 + a9 * b1\n\n\tlocal r10 = a1 * b10\n\tr10 = r10 + a2 * b9\n\tr10 = r10 + a3 * b8\n\tr10 = r10 + a4 * b7\n\tr10 = r10 + a5 * b6\n\tr10 = r10 + a6 * b5\n\tr10 = r10 + a7 * b4\n\tr10 = r10 + a8 * b3\n\tr10 = r10 + a9 * b2\n\tr10 = r10 + a10 * b1\n\n\tlocal r11 = a1 * b11\n\tr11 = r11 + a2 * b10\n\tr11 = r11 + a3 * b9\n\tr11 = r11 + a4 * b8\n\tr11 = r11 + a5 * b7\n\tr11 = r11 + a6 * b6\n\tr11 = r11 + a7 * b5\n\tr11 = r11 + a8 * b4\n\tr11 = r11 + a9 * b3\n\tr11 = r11 + a10 * b2\n\tr11 = r11 + a11 * b1\n\n\tlocal r12 = a1 * b12\n\tr12 = r12 + a2 * b11\n\tr12 = r12 + a3 * b10\n\tr12 = r12 + a4 * b9\n\tr12 = r12 + a5 * b8\n\tr12 = r12 + a6 * b7\n\tr12 = r12 + a7 * b6\n\tr12 = r12 + a8 * b5\n\tr12 = r12 + a9 * b4\n\tr12 = r12 + a10 * b3\n\tr12 = r12 + a11 * b2\n\tr12 = r12 + a12 * b1\n\n\tlocal r13 = a2 * b12\n\tr13 = r13 + a3 * b11\n\tr13 = r13 + a4 * b10\n\tr13 = r13 + a5 * b9\n\tr13 = r13 + a6 * b8\n\tr13 = r13 + a7 * b7\n\tr13 = r13 + a8 * b6\n\tr13 = r13 + a9 * b5\n\tr13 = r13 + a10 * b4\n\tr13 = r13 + a11 * b3\n\tr13 = r13 + a12 * b2\n\n\tlocal r14 = a3 * b12\n\tr14 = r14 + a4 * b11\n\tr14 = r14 + a5 * b10\n\tr14 = r14 + a6 * b9\n\tr14 = r14 + a7 * b8\n\tr14 = r14 + a8 * b7\n\tr14 = r14 + a9 * b6\n\tr14 = r14 + a10 * b5\n\tr14 = r14 + a11 * b4\n\tr14 = r14 + a12 * b3\n\n\tlocal r15 = a4 * b12\n\tr15 = r15 + a5 * b11\n\tr15 = r15 + a6 * b10\n\tr15 = r15 + a7 * b9\n\tr15 = r15 + a8 * b8\n\tr15 = r15 + a9 * b7\n\tr15 = r15 + a10 * b6\n\tr15 = r15 + a11 * b5\n\tr15 = r15 + a12 * b4\n\n\tlocal r16 = a5 * b12\n\tr16 = r16 + a6 * b11\n\tr16 = r16 + a7 * b10\n\tr16 = r16 + a8 * b9\n\tr16 = r16 + a9 * b8\n\tr16 = r16 + a10 * b7\n\tr16 = r16 + a11 * b6\n\tr16 = r16 + a12 * b5\n\n\tlocal r17 = a6 * b12\n\tr17 = r17 + a7 * b11\n\tr17 = r17 + a8 * b10\n\tr17 = r17 + a9 * b9\n\tr17 = r17 + a10 * b8\n\tr17 = r17 + a11 * b7\n\tr17 = r17 + a12 * b6\n\n\tlocal r18 = a7 * b12\n\tr18 = r18 + a8 * b11\n\tr18 = r18 + a9 * b10\n\tr18 = r18 + a10 * b9\n\tr18 = r18 + a11 * b8\n\tr18 = r18 + a12 * b7\n\n\tlocal r19 = a8 * b12\n\tr19 = r19 + a9 * b11\n\tr19 = r19 + a10 * b10\n\tr19 = r19 + a11 * b9\n\tr19 = r19 + a12 * b8\n\n\tlocal r20 = a9 * b12\n\tr20 = r20 + a10 * b11\n\tr20 = r20 + a11 * b10\n\tr20 = r20 + a12 * b9\n\n\tlocal r21 = a10 * b12\n\tr21 = r21 + a11 * b11\n\tr21 = r21 + a12 * b10\n\n\tlocal r22 = a11 * b12\n\tr22 = r22 + a12 * b11\n\n\tlocal r23 = a12 * b12\n\n\tlocal r24 = 0\n\n\tr2 = r2 + (r1 / m)\n\tr2 = r2 - r2 % 1\n\tr1 = r1 % m\n\tr3 = r3 + (r2 / m)\n\tr3 = r3 - r3 % 1\n\tr2 = r2 % m\n\tr4 = r4 + (r3 / m)\n\tr4 = r4 - r4 % 1\n\tr3 = r3 % m\n\tr5 = r5 + (r4 / m)\n\tr5 = r5 - r5 % 1\n\tr4 = r4 % m\n\tr6 = r6 + (r5 / m)\n\tr6 = r6 - r6 % 1\n\tr5 = r5 % m\n\tr7 = r7 + (r6 / m)\n\tr7 = r7 - r7 % 1\n\tr6 = r6 % m\n\tr8 = r8 + (r7 / m)\n\tr8 = r8 - r8 % 1\n\tr7 = r7 % m\n\tr9 = r9 + (r8 / m)\n\tr9 = r9 - r9 % 1\n\tr8 = r8 % m\n\tr10 = r10 + (r9 / m)\n\tr10 = r10 - r10 % 1\n\tr9 = r9 % m\n\tr11 = r11 + (r10 / m)\n\tr11 = r11 - r11 % 1\n\tr10 = r10 % m\n\tr12 = r12 + (r11 / m)\n\tr12 = r12 - r12 % 1\n\tr11 = r11 % m\n\tr13 = r13 + (r12 / m)\n\tr13 = r13 - r13 % 1\n\tr12 = r12 % m\n\tr14 = r14 + (r13 / m)\n\tr14 = r14 - r14 % 1\n\tr13 = r13 % m\n\tr15 = r15 + (r14 / m)\n\tr15 = r15 - r15 % 1\n\tr14 = r14 % m\n\tr16 = r16 + (r15 / m)\n\tr16 = r16 - r16 % 1\n\tr15 = r15 % m\n\tr17 = r17 + (r16 / m)\n\tr17 = r17 - r17 % 1\n\tr16 = r16 % m\n\tr18 = r18 + (r17 / m)\n\tr18 = r18 - r18 % 1\n\tr17 = r17 % m\n\tr19 = r19 + (r18 / m)\n\tr19 = r19 - r19 % 1\n\tr18 = r18 % m\n\tr20 = r20 + (r19 / m)\n\tr20 = r20 - r20 % 1\n\tr19 = r19 % m\n\tr21 = r21 + (r20 / m)\n\tr21 = r21 - r21 % 1\n\tr20 = r20 % m\n\tr22 = r22 + (r21 / m)\n\tr22 = r22 - r22 % 1\n\tr21 = r21 % m\n\tr23 = r23 + (r22 / m)\n\tr23 = r23 - r23 % 1\n\tr22 = r22 % m\n\tr24 = r24 + (r23 / m)\n\tr24 = r24 - r24 % 1\n\tr23 = r23 % m\n\n\tlocal result = {r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, r13, r14, r15, r16, r17, r18, r19, r20, r21, r22, r23, r24}\n\n\treturn result\nend\n\nlocal function REDC(T)\n\tlocal m = {unpack(mul384({unpack(T, 1, 12)}, p2), 1, 12)}\n\tlocal t = {unpack(add384(T, mul384(m, p)), 13, 24)}\n\n\treturn reduce(t)\nend\n\nlocal function mul(a, b)\n\treturn REDC(mul384(a, b))\nend\n\nlocal function sqr(a)\n\tlocal a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12 = unpack(a)\n\n\tlocal r1 = a1 * a1\n\n\tlocal r2 = a1 * a2 * 2\n\n\tlocal r3 = a1 * a3 * 2\n\tr3 = r3 + a2 * a2\n\n\tlocal r4 = a1 * a4 * 2\n\tr4 = r4 + a2 * a3 * 2\n\n\tlocal r5 = a1 * a5 * 2\n\tr5 = r5 + a2 * a4 * 2\n\tr5 = r5 + a3 * a3\n\n\tlocal r6 = a1 * a6 * 2\n\tr6 = r6 + a2 * a5 * 2\n\tr6 = r6 + a3 * a4 * 2\n\n\tlocal r7 = a1 * a7 * 2\n\tr7 = r7 + a2 * a6 * 2\n\tr7 = r7 + a3 * a5 * 2\n\tr7 = r7 + a4 * a4\n\n\tlocal r8 = a1 * a8 * 2\n\tr8 = r8 + a2 * a7 * 2\n\tr8 = r8 + a3 * a6 * 2\n\tr8 = r8 + a4 * a5 * 2\n\n\tlocal r9 = a1 * a9 * 2\n\tr9 = r9 + a2 * a8 * 2\n\tr9 = r9 + a3 * a7 * 2\n\tr9 = r9 + a4 * a6 * 2\n\tr9 = r9 + a5 * a5\n\n\tlocal r10 = a1 * a10 * 2\n\tr10 = r10 + a2 * a9 * 2\n\tr10 = r10 + a3 * a8 * 2\n\tr10 = r10 + a4 * a7 * 2\n\tr10 = r10 + a5 * a6 * 2\n\n\tlocal r11 = a1 * a11 * 2\n\tr11 = r11 + a2 * a10 * 2\n\tr11 = r11 + a3 * a9 * 2\n\tr11 = r11 + a4 * a8 * 2\n\tr11 = r11 + a5 * a7 * 2\n\tr11 = r11 + a6 * a6\n\n\tlocal r12 = a1 * a12 * 2\n\tr12 = r12 + a2 * a11 * 2\n\tr12 = r12 + a3 * a10 * 2\n\tr12 = r12 + a4 * a9 * 2\n\tr12 = r12 + a5 * a8 * 2\n\tr12 = r12 + a6 * a7 * 2\n\n\tlocal r13 = a2 * a12 * 2\n\tr13 = r13 + a3 * a11 * 2\n\tr13 = r13 + a4 * a10 * 2\n\tr13 = r13 + a5 * a9 * 2\n\tr13 = r13 + a6 * a8 * 2\n\tr13 = r13 + a7 * a7\n\n\tlocal r14 = a3 * a12 * 2\n\tr14 = r14 + a4 * a11 * 2\n\tr14 = r14 + a5 * a10 * 2\n\tr14 = r14 + a6 * a9 * 2\n\tr14 = r14 + a7 * a8 * 2\n\n\tlocal r15 = a4 * a12 * 2\n\tr15 = r15 + a5 * a11 * 2\n\tr15 = r15 + a6 * a10 * 2\n\tr15 = r15 + a7 * a9 * 2\n\tr15 = r15 + a8 * a8\n\n\tlocal r16 = a5 * a12 * 2\n\tr16 = r16 + a6 * a11 * 2\n\tr16 = r16 + a7 * a10 * 2\n\tr16 = r16 + a8 * a9 * 2\n\n\tlocal r17 = a6 * a12 * 2\n\tr17 = r17 + a7 * a11 * 2\n\tr17 = r17 + a8 * a10 * 2\n\tr17 = r17 + a9 * a9\n\n\tlocal r18 = a7 * a12 * 2\n\tr18 = r18 + a8 * a11 * 2\n\tr18 = r18 + a9 * a10 * 2\n\n\tlocal r19 = a8 * a12 * 2\n\tr19 = r19 + a9 * a11 * 2\n\tr19 = r19 + a10 * a10\n\n\tlocal r20 = a9 * a12 * 2\n\tr20 = r20 + a10 * a11 * 2\n\n\tlocal r21 = a10 * a12 * 2\n\tr21 = r21 + a11 * a11\n\n\tlocal r22 = a11 * a12 * 2\n\n\tlocal r23 = a12 * a12\n\n\tlocal r24 = 0\n\n\tr2 = r2 + (r1 / m)\n\tr2 = r2 - r2 % 1\n\tr1 = r1 % m\n\tr3 = r3 + (r2 / m)\n\tr3 = r3 - r3 % 1\n\tr2 = r2 % m\n\tr4 = r4 + (r3 / m)\n\tr4 = r4 - r4 % 1\n\tr3 = r3 % m\n\tr5 = r5 + (r4 / m)\n\tr5 = r5 - r5 % 1\n\tr4 = r4 % m\n\tr6 = r6 + (r5 / m)\n\tr6 = r6 - r6 % 1\n\tr5 = r5 % m\n\tr7 = r7 + (r6 / m)\n\tr7 = r7 - r7 % 1\n\tr6 = r6 % m\n\tr8 = r8 + (r7 / m)\n\tr8 = r8 - r8 % 1\n\tr7 = r7 % m\n\tr9 = r9 + (r8 / m)\n\tr9 = r9 - r9 % 1\n\tr8 = r8 % m\n\tr10 = r10 + (r9 / m)\n\tr10 = r10 - r10 % 1\n\tr9 = r9 % m\n\tr11 = r11 + (r10 / m)\n\tr11 = r11 - r11 % 1\n\tr10 = r10 % m\n\tr12 = r12 + (r11 / m)\n\tr12 = r12 - r12 % 1\n\tr11 = r11 % m\n\tr13 = r13 + (r12 / m)\n\tr13 = r13 - r13 % 1\n\tr12 = r12 % m\n\tr14 = r14 + (r13 / m)\n\tr14 = r14 - r14 % 1\n\tr13 = r13 % m\n\tr15 = r15 + (r14 / m)\n\tr15 = r15 - r15 % 1\n\tr14 = r14 % m\n\tr16 = r16 + (r15 / m)\n\tr16 = r16 - r16 % 1\n\tr15 = r15 % m\n\tr17 = r17 + (r16 / m)\n\tr17 = r17 - r17 % 1\n\tr16 = r16 % m\n\tr18 = r18 + (r17 / m)\n\tr18 = r18 - r18 % 1\n\tr17 = r17 % m\n\tr19 = r19 + (r18 / m)\n\tr19 = r19 - r19 % 1\n\tr18 = r18 % m\n\tr20 = r20 + (r19 / m)\n\tr20 = r20 - r20 % 1\n\tr19 = r19 % m\n\tr21 = r21 + (r20 / m)\n\tr21 = r21 - r21 % 1\n\tr20 = r20 % m\n\tr22 = r22 + (r21 / m)\n\tr22 = r22 - r22 % 1\n\tr21 = r21 % m\n\tr23 = r23 + (r22 / m)\n\tr23 = r23 - r23 % 1\n\tr22 = r22 % m\n\tr24 = r24 + (r23 / m)\n\tr24 = r24 - r24 % 1\n\tr23 = r23 % m\n\n\tlocal result = {r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, r13, r14, r15, r16, r17, r18, r19, r20, r21, r22, r23, r24}\n\n\treturn REDC(result)\nend\n\nlocal function mont(a)\n\treturn mul(a, r2)\nend\n\nlocal function invMont(a)\n\tlocal a = {unpack(a)}\n\n\tfor i = 13, 24 do\n\t\ta[i] = 0\n\tend\n\n\treturn REDC(a)\nend\n\nreturn {\n\teq = eq,\n\tadd = add,\n\tshr = shr,\n\tsub192 = sub192,\n\tsub = sub,\n\tmul = mul,\n\tsqr = sqr,\n\tmont = mont,\n\tinvMont = invMont,\n}\n", "sys/modules/opus/crypto/ecc/fq.lua": "-- Fq Integer Arithmetic\n\nlocal unpack = table.unpack\n\nlocal n = 0xffff\nlocal m = 0x10000\n\nlocal q = {1372, 62520, 47765, 8105, 45059, 9616, 65535, 65535, 65535, 65535, 65535, 65532}\nlocal qn = {1372, 62520, 47765, 8105, 45059, 9616, 65535, 65535, 65535, 65535, 65535, 65532, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}\n\nlocal function eq(a, b)\n\tfor i = 1, 12 do\n\t\tif a[i] ~= b[i] then\n\t\t\treturn false\n\t\tend\n\tend\n\n\treturn true\nend\n\nlocal function cmp(a, b)\n\tfor i = 12, 1, -1 do\n\t\tif a[i] > b[i] then\n\t\t\treturn 1\n\t\telseif a[i] < b[i] then\n\t\t\treturn -1\n\t\tend\n\tend\n\n\treturn 0\nend\n\nlocal function cmp384(a, b)\n\tfor i = 24, 1, -1 do\n\t\tif a[i] > b[i] then\n\t\t\treturn 1\n\t\telseif a[i] < b[i] then\n\t\t\treturn -1\n\t\tend\n\tend\n\n\treturn 0\nend\n\nlocal function bytes(x)\n\tlocal result = {}\n\n\tfor i = 0, 11 do\n\t\tlocal m = x[i + 1] % 256\n\t\tresult[2 * i + 1] = m\n\t\tresult[2 * i + 2] = (x[i + 1] - m) / 256\n\tend\n\n\treturn result\nend\n\nlocal function fromBytes(enc)\n\tlocal result = {}\n\n\tfor i = 0, 11 do\n\t\tresult[i + 1] = enc[2 * i + 1] % 256\n\t\tresult[i + 1] = result[i + 1] + enc[2 * i + 2] * 256\n\tend\n\n\treturn result\nend\n\nlocal function sub192(a, b)\n\tlocal r1 = a[1] - b[1]\n\tlocal r2 = a[2] - b[2]\n\tlocal r3 = a[3] - b[3]\n\tlocal r4 = a[4] - b[4]\n\tlocal r5 = a[5] - b[5]\n\tlocal r6 = a[6] - b[6]\n\tlocal r7 = a[7] - b[7]\n\tlocal r8 = a[8] - b[8]\n\tlocal r9 = a[9] - b[9]\n\tlocal r10 = a[10] - b[10]\n\tlocal r11 = a[11] - b[11]\n\tlocal r12 = a[12] - b[12]\n\n\tif r1 < 0 then\n\t\tr2 = r2 - 1\n\t\tr1 = r1 + m\n\tend\n\tif r2 < 0 then\n\t\tr3 = r3 - 1\n\t\tr2 = r2 + m\n\tend\n\tif r3 < 0 then\n\t\tr4 = r4 - 1\n\t\tr3 = r3 + m\n\tend\n\tif r4 < 0 then\n\t\tr5 = r5 - 1\n\t\tr4 = r4 + m\n\tend\n\tif r5 < 0 then\n\t\tr6 = r6 - 1\n\t\tr5 = r5 + m\n\tend\n\tif r6 < 0 then\n\t\tr7 = r7 - 1\n\t\tr6 = r6 + m\n\tend\n\tif r7 < 0 then\n\t\tr8 = r8 - 1\n\t\tr7 = r7 + m\n\tend\n\tif r8 < 0 then\n\t\tr9 = r9 - 1\n\t\tr8 = r8 + m\n\tend\n\tif r9 < 0 then\n\t\tr10 = r10 - 1\n\t\tr9 = r9 + m\n\tend\n\tif r10 < 0 then\n\t\tr11 = r11 - 1\n\t\tr10 = r10 + m\n\tend\n\tif r11 < 0 then\n\t\tr12 = r12 - 1\n\t\tr11 = r11 + m\n\tend\n\n\tlocal result = {r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12}\n\n\treturn result\nend\n\nlocal function reduce(a)\n\tlocal result = {unpack(a)}\n\n\tif cmp(result, q) >= 0 then\n\t\tresult = sub192(result, q)\n\tend\n\n\treturn result\nend\n\nlocal function add(a, b)\n\tlocal r1 = a[1] + b[1]\n\tlocal r2 = a[2] + b[2]\n\tlocal r3 = a[3] + b[3]\n\tlocal r4 = a[4] + b[4]\n\tlocal r5 = a[5] + b[5]\n\tlocal r6 = a[6] + b[6]\n\tlocal r7 = a[7] + b[7]\n\tlocal r8 = a[8] + b[8]\n\tlocal r9 = a[9] + b[9]\n\tlocal r10 = a[10] + b[10]\n\tlocal r11 = a[11] + b[11]\n\tlocal r12 = a[12] + b[12]\n\n\tif r1 > n then\n\t\tr2 = r2 + 1\n\t\tr1 = r1 - m\n\tend\n\tif r2 > n then\n\t\tr3 = r3 + 1\n\t\tr2 = r2 - m\n\tend\n\tif r3 > n then\n\t\tr4 = r4 + 1\n\t\tr3 = r3 - m\n\tend\n\tif r4 > n then\n\t\tr5 = r5 + 1\n\t\tr4 = r4 - m\n\tend\n\tif r5 > n then\n\t\tr6 = r6 + 1\n\t\tr5 = r5 - m\n\tend\n\tif r6 > n then\n\t\tr7 = r7 + 1\n\t\tr6 = r6 - m\n\tend\n\tif r7 > n then\n\t\tr8 = r8 + 1\n\t\tr7 = r7 - m\n\tend\n\tif r8 > n then\n\t\tr9 = r9 + 1\n\t\tr8 = r8 - m\n\tend\n\tif r9 > n then\n\t\tr10 = r10 + 1\n\t\tr9 = r9 - m\n\tend\n\tif r10 > n then\n\t\tr11 = r11 + 1\n\t\tr10 = r10 - m\n\tend\n\tif r11 > n then\n\t\tr12 = r12 + 1\n\t\tr11 = r11 - m\n\tend\n\n\tlocal result = {r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12}\n\n\treturn reduce(result)\nend\n\nlocal function sub(a, b)\n\tlocal result = sub192(a, b)\n\n\tif result[12] < 0 then\n\t\tresult = add(result, q)\n\tend\n\n\treturn result\nend\n\nlocal function add384(a, b)\n\tlocal r1 = a[1] + b[1]\n\tlocal r2 = a[2] + b[2]\n\tlocal r3 = a[3] + b[3]\n\tlocal r4 = a[4] + b[4]\n\tlocal r5 = a[5] + b[5]\n\tlocal r6 = a[6] + b[6]\n\tlocal r7 = a[7] + b[7]\n\tlocal r8 = a[8] + b[8]\n\tlocal r9 = a[9] + b[9]\n\tlocal r10 = a[10] + b[10]\n\tlocal r11 = a[11] + b[11]\n\tlocal r12 = a[12] + b[12]\n\tlocal r13 = a[13] + b[13]\n\tlocal r14 = a[14] + b[14]\n\tlocal r15 = a[15] + b[15]\n\tlocal r16 = a[16] + b[16]\n\tlocal r17 = a[17] + b[17]\n\tlocal r18 = a[18] + b[18]\n\tlocal r19 = a[19] + b[19]\n\tlocal r20 = a[20] + b[20]\n\tlocal r21 = a[21] + b[21]\n\tlocal r22 = a[22] + b[22]\n\tlocal r23 = a[23] + b[23]\n\tlocal r24 = a[24] + b[24]\n\n\tif r1 > n then\n\t\tr2 = r2 + 1\n\t\tr1 = r1 - m\n\tend\n\tif r2 > n then\n\t\tr3 = r3 + 1\n\t\tr2 = r2 - m\n\tend\n\tif r3 > n then\n\t\tr4 = r4 + 1\n\t\tr3 = r3 - m\n\tend\n\tif r4 > n then\n\t\tr5 = r5 + 1\n\t\tr4 = r4 - m\n\tend\n\tif r5 > n then\n\t\tr6 = r6 + 1\n\t\tr5 = r5 - m\n\tend\n\tif r6 > n then\n\t\tr7 = r7 + 1\n\t\tr6 = r6 - m\n\tend\n\tif r7 > n then\n\t\tr8 = r8 + 1\n\t\tr7 = r7 - m\n\tend\n\tif r8 > n then\n\t\tr9 = r9 + 1\n\t\tr8 = r8 - m\n\tend\n\tif r9 > n then\n\t\tr10 = r10 + 1\n\t\tr9 = r9 - m\n\tend\n\tif r10 > n then\n\t\tr11 = r11 + 1\n\t\tr10 = r10 - m\n\tend\n\tif r11 > n then\n\t\tr12 = r12 + 1\n\t\tr11 = r11 - m\n\tend\n\tif r12 > n then\n\t\tr13 = r13 + 1\n\t\tr12 = r12 - m\n\tend\n\tif r13 > n then\n\t\tr14 = r14 + 1\n\t\tr13 = r13 - m\n\tend\n\tif r14 > n then\n\t\tr15 = r15 + 1\n\t\tr14 = r14 - m\n\tend\n\tif r15 > n then\n\t\tr16 = r16 + 1\n\t\tr15 = r15 - m\n\tend\n\tif r16 > n then\n\t\tr17 = r17 + 1\n\t\tr16 = r16 - m\n\tend\n\tif r17 > n then\n\t\tr18 = r18 + 1\n\t\tr17 = r17 - m\n\tend\n\tif r18 > n then\n\t\tr19 = r19 + 1\n\t\tr18 = r18 - m\n\tend\n\tif r19 > n then\n\t\tr20 = r20 + 1\n\t\tr19 = r19 - m\n\tend\n\tif r20 > n then\n\t\tr21 = r21 + 1\n\t\tr20 = r20 - m\n\tend\n\tif r21 > n then\n\t\tr22 = r22 + 1\n\t\tr21 = r21 - m\n\tend\n\tif r22 > n then\n\t\tr23 = r23 + 1\n\t\tr22 = r22 - m\n\tend\n\tif r23 > n then\n\t\tr24 = r24 + 1\n\t\tr23 = r23 - m\n\tend\n\n\tlocal result = {r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, r13, r14, r15, r16, r17, r18, r19, r20, r21, r22, r23, r24}\n\n\treturn result\nend\n\nlocal function sub384(a, b)\n\tlocal r1 = a[1] - b[1]\n\tlocal r2 = a[2] - b[2]\n\tlocal r3 = a[3] - b[3]\n\tlocal r4 = a[4] - b[4]\n\tlocal r5 = a[5] - b[5]\n\tlocal r6 = a[6] - b[6]\n\tlocal r7 = a[7] - b[7]\n\tlocal r8 = a[8] - b[8]\n\tlocal r9 = a[9] - b[9]\n\tlocal r10 = a[10] - b[10]\n\tlocal r11 = a[11] - b[11]\n\tlocal r12 = a[12] - b[12]\n\tlocal r13 = a[13] - b[13]\n\tlocal r14 = a[14] - b[14]\n\tlocal r15 = a[15] - b[15]\n\tlocal r16 = a[16] - b[16]\n\tlocal r17 = a[17] - b[17]\n\tlocal r18 = a[18] - b[18]\n\tlocal r19 = a[19] - b[19]\n\tlocal r20 = a[20] - b[20]\n\tlocal r21 = a[21] - b[21]\n\tlocal r22 = a[22] - b[22]\n\tlocal r23 = a[23] - b[23]\n\tlocal r24 = a[24] - b[24]\n\n\tif r1 < 0 then\n\t\tr2 = r2 - 1\n\t\tr1 = r1 + m\n\tend\n\tif r2 < 0 then\n\t\tr3 = r3 - 1\n\t\tr2 = r2 + m\n\tend\n\tif r3 < 0 then\n\t\tr4 = r4 - 1\n\t\tr3 = r3 + m\n\tend\n\tif r4 < 0 then\n\t\tr5 = r5 - 1\n\t\tr4 = r4 + m\n\tend\n\tif r5 < 0 then\n\t\tr6 = r6 - 1\n\t\tr5 = r5 + m\n\tend\n\tif r6 < 0 then\n\t\tr7 = r7 - 1\n\t\tr6 = r6 + m\n\tend\n\tif r7 < 0 then\n\t\tr8 = r8 - 1\n\t\tr7 = r7 + m\n\tend\n\tif r8 < 0 then\n\t\tr9 = r9 - 1\n\t\tr8 = r8 + m\n\tend\n\tif r9 < 0 then\n\t\tr10 = r10 - 1\n\t\tr9 = r9 + m\n\tend\n\tif r10 < 0 then\n\t\tr11 = r11 - 1\n\t\tr10 = r10 + m\n\tend\n\tif r11 < 0 then\n\t\tr12 = r12 - 1\n\t\tr11 = r11 + m\n\tend\n\tif r12 < 0 then\n\t\tr13 = r13 - 1\n\t\tr12 = r12 + m\n\tend\n\tif r13 < 0 then\n\t\tr14 = r14 - 1\n\t\tr13 = r13 + m\n\tend\n\tif r14 < 0 then\n\t\tr15 = r15 - 1\n\t\tr14 = r14 + m\n\tend\n\tif r15 < 0 then\n\t\tr16 = r16 - 1\n\t\tr15 = r15 + m\n\tend\n\tif r16 < 0 then\n\t\tr17 = r17 - 1\n\t\tr16 = r16 + m\n\tend\n\tif r17 < 0 then\n\t\tr18 = r18 - 1\n\t\tr17 = r17 + m\n\tend\n\tif r18 < 0 then\n\t\tr19 = r19 - 1\n\t\tr18 = r18 + m\n\tend\n\tif r19 < 0 then\n\t\tr20 = r20 - 1\n\t\tr19 = r19 + m\n\tend\n\tif r20 < 0 then\n\t\tr21 = r21 - 1\n\t\tr20 = r20 + m\n\tend\n\tif r21 < 0 then\n\t\tr22 = r22 - 1\n\t\tr21 = r21 + m\n\tend\n\tif r22 < 0 then\n\t\tr23 = r23 - 1\n\t\tr22 = r22 + m\n\tend\n\tif r23 < 0 then\n\t\tr24 = r24 - 1\n\t\tr23 = r23 + m\n\tend\n\n\tlocal result = {r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, r13, r14, r15, r16, r17, r18, r19, r20, r21, r22, r23, r24}\n\n\treturn result\nend\n\nlocal function mul384(a, b)\n\tlocal a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12 = unpack(a)\n\tlocal b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12 = unpack(b)\n\n\tlocal r1 = a1 * b1\n\n\tlocal r2 = a1 * b2\n\tr2 = r2 + a2 * b1\n\n\tlocal r3 = a1 * b3\n\tr3 = r3 + a2 * b2\n\tr3 = r3 + a3 * b1\n\n\tlocal r4 = a1 * b4\n\tr4 = r4 + a2 * b3\n\tr4 = r4 + a3 * b2\n\tr4 = r4 + a4 * b1\n\n\tlocal r5 = a1 * b5\n\tr5 = r5 + a2 * b4\n\tr5 = r5 + a3 * b3\n\tr5 = r5 + a4 * b2\n\tr5 = r5 + a5 * b1\n\n\tlocal r6 = a1 * b6\n\tr6 = r6 + a2 * b5\n\tr6 = r6 + a3 * b4\n\tr6 = r6 + a4 * b3\n\tr6 = r6 + a5 * b2\n\tr6 = r6 + a6 * b1\n\n\tlocal r7 = a1 * b7\n\tr7 = r7 + a2 * b6\n\tr7 = r7 + a3 * b5\n\tr7 = r7 + a4 * b4\n\tr7 = r7 + a5 * b3\n\tr7 = r7 + a6 * b2\n\tr7 = r7 + a7 * b1\n\n\tlocal r8 = a1 * b8\n\tr8 = r8 + a2 * b7\n\tr8 = r8 + a3 * b6\n\tr8 = r8 + a4 * b5\n\tr8 = r8 + a5 * b4\n\tr8 = r8 + a6 * b3\n\tr8 = r8 + a7 * b2\n\tr8 = r8 + a8 * b1\n\n\tlocal r9 = a1 * b9\n\tr9 = r9 + a2 * b8\n\tr9 = r9 + a3 * b7\n\tr9 = r9 + a4 * b6\n\tr9 = r9 + a5 * b5\n\tr9 = r9 + a6 * b4\n\tr9 = r9 + a7 * b3\n\tr9 = r9 + a8 * b2\n\tr9 = r9 + a9 * b1\n\n\tlocal r10 = a1 * b10\n\tr10 = r10 + a2 * b9\n\tr10 = r10 + a3 * b8\n\tr10 = r10 + a4 * b7\n\tr10 = r10 + a5 * b6\n\tr10 = r10 + a6 * b5\n\tr10 = r10 + a7 * b4\n\tr10 = r10 + a8 * b3\n\tr10 = r10 + a9 * b2\n\tr10 = r10 + a10 * b1\n\n\tlocal r11 = a1 * b11\n\tr11 = r11 + a2 * b10\n\tr11 = r11 + a3 * b9\n\tr11 = r11 + a4 * b8\n\tr11 = r11 + a5 * b7\n\tr11 = r11 + a6 * b6\n\tr11 = r11 + a7 * b5\n\tr11 = r11 + a8 * b4\n\tr11 = r11 + a9 * b3\n\tr11 = r11 + a10 * b2\n\tr11 = r11 + a11 * b1\n\n\tlocal r12 = a1 * b12\n\tr12 = r12 + a2 * b11\n\tr12 = r12 + a3 * b10\n\tr12 = r12 + a4 * b9\n\tr12 = r12 + a5 * b8\n\tr12 = r12 + a6 * b7\n\tr12 = r12 + a7 * b6\n\tr12 = r12 + a8 * b5\n\tr12 = r12 + a9 * b4\n\tr12 = r12 + a10 * b3\n\tr12 = r12 + a11 * b2\n\tr12 = r12 + a12 * b1\n\n\tlocal r13 = a2 * b12\n\tr13 = r13 + a3 * b11\n\tr13 = r13 + a4 * b10\n\tr13 = r13 + a5 * b9\n\tr13 = r13 + a6 * b8\n\tr13 = r13 + a7 * b7\n\tr13 = r13 + a8 * b6\n\tr13 = r13 + a9 * b5\n\tr13 = r13 + a10 * b4\n\tr13 = r13 + a11 * b3\n\tr13 = r13 + a12 * b2\n\n\tlocal r14 = a3 * b12\n\tr14 = r14 + a4 * b11\n\tr14 = r14 + a5 * b10\n\tr14 = r14 + a6 * b9\n\tr14 = r14 + a7 * b8\n\tr14 = r14 + a8 * b7\n\tr14 = r14 + a9 * b6\n\tr14 = r14 + a10 * b5\n\tr14 = r14 + a11 * b4\n\tr14 = r14 + a12 * b3\n\n\tlocal r15 = a4 * b12\n\tr15 = r15 + a5 * b11\n\tr15 = r15 + a6 * b10\n\tr15 = r15 + a7 * b9\n\tr15 = r15 + a8 * b8\n\tr15 = r15 + a9 * b7\n\tr15 = r15 + a10 * b6\n\tr15 = r15 + a11 * b5\n\tr15 = r15 + a12 * b4\n\n\tlocal r16 = a5 * b12\n\tr16 = r16 + a6 * b11\n\tr16 = r16 + a7 * b10\n\tr16 = r16 + a8 * b9\n\tr16 = r16 + a9 * b8\n\tr16 = r16 + a10 * b7\n\tr16 = r16 + a11 * b6\n\tr16 = r16 + a12 * b5\n\n\tlocal r17 = a6 * b12\n\tr17 = r17 + a7 * b11\n\tr17 = r17 + a8 * b10\n\tr17 = r17 + a9 * b9\n\tr17 = r17 + a10 * b8\n\tr17 = r17 + a11 * b7\n\tr17 = r17 + a12 * b6\n\n\tlocal r18 = a7 * b12\n\tr18 = r18 + a8 * b11\n\tr18 = r18 + a9 * b10\n\tr18 = r18 + a10 * b9\n\tr18 = r18 + a11 * b8\n\tr18 = r18 + a12 * b7\n\n\tlocal r19 = a8 * b12\n\tr19 = r19 + a9 * b11\n\tr19 = r19 + a10 * b10\n\tr19 = r19 + a11 * b9\n\tr19 = r19 + a12 * b8\n\n\tlocal r20 = a9 * b12\n\tr20 = r20 + a10 * b11\n\tr20 = r20 + a11 * b10\n\tr20 = r20 + a12 * b9\n\n\tlocal r21 = a10 * b12\n\tr21 = r21 + a11 * b11\n\tr21 = r21 + a12 * b10\n\n\tlocal r22 = a11 * b12\n\tr22 = r22 + a12 * b11\n\n\tlocal r23 = a12 * b12\n\n\tlocal r24 = 0\n\n\tr2 = r2 + (r1 / m)\n\tr2 = r2 - r2 % 1\n\tr1 = r1 % m\n\tr3 = r3 + (r2 / m)\n\tr3 = r3 - r3 % 1\n\tr2 = r2 % m\n\tr4 = r4 + (r3 / m)\n\tr4 = r4 - r4 % 1\n\tr3 = r3 % m\n\tr5 = r5 + (r4 / m)\n\tr5 = r5 - r5 % 1\n\tr4 = r4 % m\n\tr6 = r6 + (r5 / m)\n\tr6 = r6 - r6 % 1\n\tr5 = r5 % m\n\tr7 = r7 + (r6 / m)\n\tr7 = r7 - r7 % 1\n\tr6 = r6 % m\n\tr8 = r8 + (r7 / m)\n\tr8 = r8 - r8 % 1\n\tr7 = r7 % m\n\tr9 = r9 + (r8 / m)\n\tr9 = r9 - r9 % 1\n\tr8 = r8 % m\n\tr10 = r10 + (r9 / m)\n\tr10 = r10 - r10 % 1\n\tr9 = r9 % m\n\tr11 = r11 + (r10 / m)\n\tr11 = r11 - r11 % 1\n\tr10 = r10 % m\n\tr12 = r12 + (r11 / m)\n\tr12 = r12 - r12 % 1\n\tr11 = r11 % m\n\tr13 = r13 + (r12 / m)\n\tr13 = r13 - r13 % 1\n\tr12 = r12 % m\n\tr14 = r14 + (r13 / m)\n\tr14 = r14 - r14 % 1\n\tr13 = r13 % m\n\tr15 = r15 + (r14 / m)\n\tr15 = r15 - r15 % 1\n\tr14 = r14 % m\n\tr16 = r16 + (r15 / m)\n\tr16 = r16 - r16 % 1\n\tr15 = r15 % m\n\tr17 = r17 + (r16 / m)\n\tr17 = r17 - r17 % 1\n\tr16 = r16 % m\n\tr18 = r18 + (r17 / m)\n\tr18 = r18 - r18 % 1\n\tr17 = r17 % m\n\tr19 = r19 + (r18 / m)\n\tr19 = r19 - r19 % 1\n\tr18 = r18 % m\n\tr20 = r20 + (r19 / m)\n\tr20 = r20 - r20 % 1\n\tr19 = r19 % m\n\tr21 = r21 + (r20 / m)\n\tr21 = r21 - r21 % 1\n\tr20 = r20 % m\n\tr22 = r22 + (r21 / m)\n\tr22 = r22 - r22 % 1\n\tr21 = r21 % m\n\tr23 = r23 + (r22 / m)\n\tr23 = r23 - r23 % 1\n\tr22 = r22 % m\n\tr24 = r24 + (r23 / m)\n\tr24 = r24 - r24 % 1\n\tr23 = r23 % m\n\n\tlocal result = {r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, r13, r14, r15, r16, r17, r18, r19, r20, r21, r22, r23, r24}\n\n\treturn result\nend\n\nlocal function reduce384(a)\n\tlocal result = {unpack(a)}\n\n\twhile cmp384(result, qn) >= 0 do\n\t\tlocal qn = {unpack(qn)}\n\t\tlocal qn2 = add384(qn, qn)\n\t\twhile cmp384(result, qn2) > 0 do\n\t\t\tqn = qn2\n\t\t\tqn2 = add384(qn2, qn2)\n\t\tend\n\t\tresult = sub384(result, qn)\n\tend\n\n\tresult = {unpack(result, 1, 12)}\n\n\treturn result\nend\n\nlocal function mul(a, b)\n\treturn reduce384(mul384(a, b))\nend\n\nreturn {\n\teq = eq,\n\tcmp = cmp,\n\tbytes = bytes,\n\tfromBytes = fromBytes,\n\treduce = reduce,\n\tadd = add,\n\tsub = sub,\n\tmul = mul,\n}\n", "sys/modules/opus/crypto/ecc/elliptic.lua": "---- Elliptic Curve Arithmetic\n\n---- About the Curve Itself\n-- Field Size: 192 bits\n-- Field Modulus (p): 65533 * 2^176 + 3\n-- Equation: x^2 + y^2 = 1 + 108 * x^2 * y^2\n-- Parameters: Edwards Curve with c = 1, and d = 108\n-- Curve Order (n): 4 * 1569203598118192102418711808268118358122924911136798015831\n-- Cofactor (h): 4\n-- Generator Order (q): 1569203598118192102418711808268118358122924911136798015831\n---- About the Curve's Security\n-- Current best attack security: 94.822 bits (Pollard's Rho)\n-- Rho Security: log2(0.884 * sqrt(q)) = 94.822\n-- Transfer Security? Yes: p ~= q; k > 20\n-- Field Discriminant Security? Yes: t = 67602300638727286331433024168; s = 2^2; |D| = 5134296629560551493299993292204775496868940529592107064435 > 2^100\n-- Rigidity? A little, the parameters are somewhat small.\n-- XZ/YZ Ladder Security? No: Single coordinate ladders are insecure, so they can't be used.\n-- Small Subgroup Security? Yes: Secret keys are calculated modulo 4q.\n-- Invalid Curve Security? Yes: Any point to be multiplied is checked beforehand.\n-- Invalid Curve Twist Security? No: The curve is not protected against single coordinate ladder attacks, so don't use them.\n-- Completeness? Yes: The curve is an Edwards Curve with non-square d and square a, so the curve is complete.\n-- Indistinguishability? No: The curve does not support indistinguishability maps.\n\nlocal fp = require('opus.crypto.ecc.fp')\nlocal Util = require('opus.util')\n\nlocal eq = fp.eq\nlocal mul = fp.mul\nlocal sqr = fp.sqr\nlocal add = fp.add\nlocal sub = fp.sub\nlocal shr = fp.shr\nlocal mont = fp.mont\nlocal invMont = fp.invMont\nlocal sub192 = fp.sub192\nlocal unpack = table.unpack\n\nlocal bits = 192\nlocal pMinusTwoBinary = {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1}\nlocal pMinusThreeOverFourBinary = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0}\nlocal ZERO = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}\nlocal ONE = mont({1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0})\n\nlocal p = mont({3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 65533})\nlocal G = {\n\tmont({30457, 58187, 5603, 63215, 8936, 58151, 26571, 7272, 26680, 23486, 32353, 59456}),\n\tmont({3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}),\n\tmont({1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0})\n}\nlocal GTable = {G}\n\nlocal d = mont({108, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0})\n\nlocal function generator()\n\treturn G\nend\n\nlocal function expMod(a, t)\n\tlocal a = {unpack(a)}\n\tlocal result = {unpack(ONE)}\n\n\tfor i = 1, bits do\n\t\tif t[i] == 1 then\n\t\t\tresult = mul(result, a)\n\t\tend\n\t\ta = mul(a, a)\n\tend\n\n\treturn result\nend\n\n-- We're using Projective Coordinates\n-- For Edwards curves\n-- The identity element is represented by (0:1:1)\nlocal function pointDouble(P1)\n\tlocal X1, Y1, Z1 = unpack(P1)\n\n\tlocal b = add(X1, Y1)\n\tlocal B = sqr(b)\n\tlocal C = sqr(X1)\n\tlocal D = sqr(Y1)\n\tlocal E = add(C, D)\n\tlocal H = sqr(Z1)\n\tlocal J = sub(E, add(H, H))\n\tlocal X3 = mul(sub(B, E), J)\n\tlocal Y3 = mul(E, sub(C, D))\n\tlocal Z3 = mul(E, J)\n\n\tlocal P3 = {X3, Y3, Z3}\n\n\treturn P3\nend\n\nlocal function pointAdd(P1, P2)\n\tlocal X1, Y1, Z1 = unpack(P1)\n\tlocal X2, Y2, Z2 = unpack(P2)\n\n\tlocal A = mul(Z1, Z2)\n\tlocal B = sqr(A)\n\tlocal C = mul(X1, X2)\n\tlocal D = mul(Y1, Y2)\n\tlocal E = mul(d, mul(C, D))\n\tlocal F = sub(B, E)\n\tlocal G = add(B, E)\n\tlocal X3 = mul(A, mul(F, sub(mul(add(X1, Y1), add(X2, Y2)), add(C, D))))\n\tlocal Y3 = mul(A, mul(G, sub(D, C)))\n\tlocal Z3 = mul(F, G)\n\n\tlocal P3 = {X3, Y3, Z3}\n\n\treturn P3\nend\n\nlocal function pointNeg(P1)\n\tlocal X1, Y1, Z1 = unpack(P1)\n\n\tlocal X3 = sub(p, X1)\n\tlocal Y3 = {unpack(Y1)}\n\tlocal Z3 = {unpack(Z1)}\n\n\tlocal P3 = {X3, Y3, Z3}\n\n\treturn P3\nend\n\nlocal function pointSub(P1, P2)\n\treturn pointAdd(P1, pointNeg(P2))\nend\n\nlocal function pointScale(P1)\n\tlocal X1, Y1, Z1 = unpack(P1)\n\n\tlocal A = expMod(Z1, pMinusTwoBinary)\n\tlocal X3 = mul(X1, A)\n\tlocal Y3 = mul(Y1, A)\n\tlocal Z3 = {unpack(ONE)}\n\n\tlocal P3 = {X3, Y3, Z3}\n\n\treturn P3\nend\n\nlocal function pointEq(P1, P2)\n\tlocal X1, Y1, Z1 = unpack(P1)\n\tlocal X2, Y2, Z2 = unpack(P2)\n\n\tlocal A1 = mul(X1, Z2)\n\tlocal B1 = mul(Y1, Z2)\n\tlocal A2 = mul(X2, Z1)\n\tlocal B2 = mul(Y2, Z1)\n\n\treturn eq(A1, A2) and eq(B1, B2)\nend\n\nlocal function isOnCurve(P1)\n\tlocal X1, Y1, Z1 = unpack(P1)\n\n\tlocal X12 = sqr(X1)\n\tlocal Y12 = sqr(Y1)\n\tlocal Z12 = sqr(Z1)\n\tlocal Z14 = sqr(Z12)\n\tlocal a = add(X12, Y12)\n\ta = mul(a, Z12)\n\tlocal b = mul(d, mul(X12, Y12))\n\tb = add(Z14, b)\n\n\treturn eq(a, b)\nend\n\nlocal function mods(d)\n\t-- w = 5\n\tlocal result = d[1] % 32\n\n\tif result >= 16 then\n\t\tresult = result - 32\n\tend\n\n\treturn result\nend\n\nlocal function NAF(d)\n\tlocal t = {}\n\tlocal d = {unpack(d)}\n\n\twhile d[12] >= 0 and not eq(d, ZERO) do\n\t\tif d[1] % 2 == 1 then\n\t\t\tt[#t + 1] = mods(d)\n\t\t\td = sub192(d, {t[#t], 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0})\n\t\telse\n\t\t\tt[#t + 1] = 0\n\t\tend\n\n\t\td = shr(d)\n\tend\n\n\treturn t\nend\n\nlocal function scalarMul(s, P1)\n\tlocal naf = NAF(s)\n\tlocal PTable = {P1}\n\tlocal P2 = pointDouble(P1)\n\n\tfor i = 3, 31, 2 do\n\t\tPTable[i] = pointAdd(PTable[i - 2], P2)\n\tend\n\n\tlocal Q = {{unpack(ZERO)}, {unpack(ONE)}, {unpack(ONE)}}\n\tfor i = #naf, 1, -1 do -- can this loop be optimized ?\n\t\tlocal n = naf[i]\n\t\tQ = pointDouble(Q)\n\t\tif n > 0 then\n\t\t\tQ = pointAdd(Q, PTable[n])\n\t\telseif n < 0 then\n\t\t\tQ = pointSub(Q, PTable[-n])\n\t\tend\n\tend\n\n\treturn Q\nend\n\nlocal throttle = Util.throttle()\nfor i = 2, 196 do\n\tGTable[i] = pointDouble(GTable[i - 1])\n\tthrottle()\nend\n\nlocal function scalarMulG(s)\n\tlocal result = {{unpack(ZERO)}, {unpack(ONE)}, {unpack(ONE)}}\n\tlocal k = 1\n\n\tfor i = 1, 12 do\n\t\tlocal w = s[i]\n\n\t\tfor j = 1, 16 do\n\t\t\tif w % 2 == 1 then\n\t\t\t\tresult = pointAdd(result, GTable[k])\n\t\t\tend\n\n\t\t\tk = k + 1\n\n\t\t\tw = w / 2\n\t\t\tw = w - w % 1\n\t\tend\n\tend\n\n\treturn result\nend\n\nlocal function pointEncode(P1)\n\tP1 = pointScale(P1)\n\n\tlocal result = {}\n\tlocal x, y = unpack(P1)\n\n\tresult[1] = x[1] % 2\n\n\tfor i = 1, 12 do\n\t\tlocal m = y[i] % 256\n\t\tresult[2 * i] = m\n\t\tresult[2 * i + 1] = (y[i] - m) / 256\n\tend\n\n\treturn result\nend\n\nlocal function pointDecode(enc)\n\tlocal y = {}\n\tfor i = 1, 12 do\n\t\ty[i] = enc[2 * i]\n\t\ty[i] = y[i] + enc[2 * i + 1] * 256\n\tend\n\n\tlocal y2 = sqr(y)\n\tlocal u = sub(y2, ONE)\n\tlocal v = sub(mul(d, y2), ONE)\n\tlocal u2 = sqr(u)\n\tlocal u3 = mul(u, u2)\n\tlocal u5 = mul(u3, u2)\n\tlocal v3 = mul(v, sqr(v))\n\tlocal w = mul(u5, v3)\n\tlocal x = mul(u3, mul(v, expMod(w, pMinusThreeOverFourBinary)))\n\n\tif x[1] % 2 ~= enc[1] then\n\t\tx = sub(p, x)\n\tend\n\n\tlocal P3 = {x, y, {unpack(ONE)}}\n\n\treturn P3\nend\n\nreturn {\n\tgenerator = generator,\n\tpointDouble = pointDouble,\n\tpointAdd = pointAdd,\n\tpointNeg = pointNeg,\n\tpointSub = pointSub,\n\tpointScale = pointScale,\n\tpointEq = pointEq,\n\tisOnCurve = isOnCurve,\n\tscalarMul = scalarMul,\n\tscalarMulG = scalarMulG,\n\tpointEncode = pointEncode,\n\tpointDecode = pointDecode,\n}\n", "sys/modules/opus/compress/tar.lua": "\n-- see: https://github.com/luarocks/luarocks/blob/master/src/luarocks/tools/tar.lua\n-- A pure-Lua implementation of untar (unpacking .tar archives)\nlocal Util = require('opus.util')\n\nlocal fs = _G.fs\nlocal _sub = string.sub\n\nlocal blocksize = 512\n\nlocal function get_typeflag(flag)\n\tif flag == \"0\" or flag == \"\\0\" then return \"file\"\n\telseif flag == \"1\" then return \"link\"\n\telseif flag == \"2\" then return \"symlink\" -- \"reserved\" in POSIX, \"symlink\" in GNU\n\telseif flag == \"3\" then return \"character\"\n\telseif flag == \"4\" then return \"block\"\n\telseif flag == \"5\" then return \"directory\"\n\telseif flag == \"6\" then return \"fifo\"\n\telseif flag == \"7\" then return \"contiguous\" -- \"reserved\" in POSIX, \"contiguous\" in GNU\n\telseif flag == \"x\" then return \"next file\"\n\telseif flag == \"g\" then return \"global extended header\"\n\telseif flag == \"L\" then return \"long name\"\n\telseif flag == \"K\" then return \"long link name\"\n\tend\n\treturn \"unknown\"\nend\n\nlocal function octal_to_number(octal)\n\tlocal exp = 0\n\tlocal number = 0\n\toctal = octal:gsub(\"%s\", \"\")\n\tfor i = #octal,1,-1 do\n\t\tlocal digit = tonumber(octal:sub(i,i))\n\t\tif not digit then\n\t\t\tbreak\n\t\tend\n\t\tnumber = number + (digit * 8^exp)\n\t\texp = exp + 1\n\tend\n\treturn number\nend\n\nlocal function checksum_header(block)\n\tlocal sum = 256\n\tfor i = 1,148 do\n\t\tlocal b = block:byte(i) or 0\n\t\tsum = sum + b\n\tend\n\tfor i = 157,500 do\n\t\tlocal b = block:byte(i) or 0\n\t\tsum = sum + b\n\tend\n\treturn sum\nend\n\nlocal function nullterm(s)\n\treturn s:match(\"^[^%z]*\")\nend\n\nlocal function read_header_block(block)\n\tlocal header = {}\n\theader.name = nullterm(block:sub(1,100))\n\theader.mode = nullterm(block:sub(101,108)):gsub(\" \", \"\")\n\theader.uid = octal_to_number(nullterm(block:sub(109,116)))\n\theader.gid = octal_to_number(nullterm(block:sub(117,124)))\n\theader.size = octal_to_number(nullterm(block:sub(125,136)))\n\theader.mtime = octal_to_number(nullterm(block:sub(137,148)))\n\theader.chksum = octal_to_number(nullterm(block:sub(149,156)))\n\theader.typeflag = get_typeflag(block:sub(157,157))\n\theader.linkname = nullterm(block:sub(158,257))\n\theader.magic = block:sub(258,263)\n\theader.version = block:sub(264,265)\n\theader.uname = nullterm(block:sub(266,297))\n\theader.gname = nullterm(block:sub(298,329))\n\theader.devmajor = octal_to_number(nullterm(block:sub(330,337)))\n\theader.devminor = octal_to_number(nullterm(block:sub(338,345)))\n\theader.prefix = block:sub(346,500)\n\tif not checksum_header(block) == header.chksum then\n\t\treturn false, \"Failed header checksum\"\n\tend\n\treturn header\nend\n\nlocal function untar_stream(tar_handle, destdir, verbose)\n\tassert(type(destdir) == \"string\")\n\n\tlocal long_name, long_link_name\n\tlocal ok, err\n\n\tlocal make_dir = function(a)\n\t\tif not fs.exists(a) then\n\t\t\tfs.makeDir(a)\n\t\tend\n\t\treturn true\n\tend\n\n\twhile true do\n\t\tlocal block\n\t\trepeat\n\t\t\tblock = tar_handle:read(blocksize)\n\t\tuntil (not block) or checksum_header(block) > 256\n\t\tif not block then break end\n\t\tif #block < blocksize then\n\t\t\tok, err = nil, \"Invalid block size -- corrupted file?\"\n\t\t\tbreak\n\t\tend\n\t\tlocal header\n\t\theader, err = read_header_block(block)\n\t\tif not header then\n\t\t\tok = false\n\t\t\tbreak\n\t\tend\n\n\t\tlocal file_data = tar_handle:read(math.ceil(header.size / blocksize) * blocksize):sub(1,header.size)\n\n\t\tif header.typeflag == \"long name\" then\n\t\t\tlong_name = nullterm(file_data)\n\t\telseif header.typeflag == \"long link name\" then\n\t\t\tlong_link_name = nullterm(file_data)\n\t\telse\n\t\t\tif long_name then\n\t\t\t\theader.name = long_name\n\t\t\t\tlong_name = nil\n\t\t\tend\n\t\t\tif long_link_name then\n\t\t\t\theader.name = long_link_name\n\t\t\t\tlong_link_name = nil\n\t\t\tend\n\t\tend\n\t\tlocal pathname = fs.combine(destdir, header.name)\n\n\t\tif header.typeflag == \"directory\" then\n\t\t\tok, err = make_dir(pathname)\n\t\t\tif not ok then\n\t\t\t\tbreak\n\t\t\tend\n\t\telseif header.typeflag == \"file\" then\n\t\t\tlocal dirname = fs.getDir(pathname)\n\t\t\tif dirname ~= \"\" then\n\t\t\t\tok, err = make_dir(dirname)\n\t\t\t\tif not ok then\n\t\t\t\t\tbreak\n\t\t\t\tend\n\t\t\tend\n\t\t\tlocal file_handle\n\t\t\tif verbose then\n\t\t\t\tprint(pathname)\n\t\t\tend\n\t\t\tfile_handle, err = io.open(pathname, \"wb\")\n\t\t\tif not file_handle then\n\t\t\t\tok = nil\n\t\t\t\tbreak\n\t\t\tend\n\t\t\tfile_handle:write(file_data)\n\t\t\tfile_handle:close()\n\t\tend\n\tend\n\n\treturn ok, err\nend\n\nlocal function untar_string(str, destdir, verbose)\n\tlocal ctr = 1\n\tlocal len = #str\n\tlocal handle = {\n\t\tread = function(_, n)\n\t\t\tif ctr < len then\n\t\t\t\tlocal s = _sub(str, ctr, ctr + n - 1)\n\t\t\t\tctr = ctr + n\n\t\t\t\treturn s\n\t\t\tend\n\t\tend\n\t}\n\treturn untar_stream(handle, destdir, verbose)\nend\n\nlocal function untar(filename, destdir, verbose)\n\tassert(type(filename) == \"string\")\n\tassert(type(destdir) == \"string\")\n\n\tlocal tar_handle = io.open(filename, \"rb\")\n\tif not tar_handle then return nil, \"Error opening file \"..filename end\n\n\tlocal ok, err = untar_stream(tar_handle, destdir, verbose)\n\n\ttar_handle:close()\n\treturn ok, err\nend\n\nlocal function create_header_block(filename, abspath)\n\tlocal block = ('\\0'):rep(blocksize)\n\n\tlocal function number_to_octal(n)\n\t\treturn ('%o'):format(n)\n\tend\n\n\tlocal function ins(pos, istr)\n\t\tblock = block:sub(1, pos - 1) .. istr .. block:sub(pos + #istr)\n\tend\n\n\tins(1, filename) -- header\n\tins(125, number_to_octal(fs.getSize(abspath)))\n\tins(157, '0') -- typeflag\n\n\tins(149, number_to_octal(checksum_header(block)))\n\n\treturn block\nend\n\nlocal function tar_stream(tar_handle, root, files)\n\tif not files then\n\t\tfiles = { }\n\t\tlocal function recurse(rel)\n\t\t\tlocal abs = fs.combine(root, rel)\n\t\t\tfor _,f in ipairs(fs.list(abs)) do\n\t\t\t\tlocal fullName = fs.combine(abs, f)\n\t\t\t\tif fs.isDir(fullName) then -- skip virtual dirs\n\t\t\t\t\trecurse(fs.combine(rel, f))\n\t\t\t\telse\n\t\t\t\t\ttable.insert(files, fs.combine(rel, f))\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\t\trecurse('')\n\tend\n\n\tfor _, file in pairs(files) do\n\t\tlocal abs = fs.combine(root, file)\n\t\tlocal block = create_header_block(file, abs)\n\t\ttar_handle:write(block)\n\t\tlocal f = Util.readFile(abs, 'rb')\n\t\ttar_handle:write(f)\n\t\tlocal padding = #f % blocksize\n\t\tif padding > 0 then\n\t\t\ttar_handle:write(('\\0'):rep(blocksize - padding))\n\t\tend\n\tend\nend\n\nlocal function tar_string(root, files)\n\tlocal t = { }\n\tlocal handle = {\n\t\twrite = function(_, s)\n\t\t\ttable.insert(t, s)\n\t\tend\n\t}\n\ttar_stream(handle, root, files)\n\treturn table.concat(t)\nend\n\n-- the bare minimum for this program to untar\nlocal function tar(filename, root, files)\n\tassert(type(filename) == \"string\")\n\tassert(type(root) == \"string\")\n\n\tlocal tar_handle = io.open(filename, \"wb\")\n\tif not tar_handle then return nil, \"Error opening file \"..filename end\n\n\tlocal ok, err = tar_stream(tar_handle, root, files)\n\n\ttar_handle:close()\n\treturn ok, err\nend\n\nreturn {\n\ttar = tar,\n\tuntar = untar,\n\ttar_string = tar_string,\n\tuntar_string = untar_string,\n}\n", "sys/modules/opus/compress/lzw.lua": "-- see: https://github.com/Rochet2/lualzw\n-- MIT License - Copyright (c) 2016 Rochet2\n\nlocal char    = string.char\nlocal type    = type\nlocal sub     = string.sub\nlocal tconcat = table.concat\n\nlocal SIGC = 'LZWC'\n\nlocal basedictcompress = {}\nlocal basedictdecompress = {}\nfor i = 0, 255 do\n\tlocal ic, iic = char(i), char(i, 0)\n\tbasedictcompress[ic] = iic\n\tbasedictdecompress[iic] = ic\nend\n\nlocal function dictAddA(str, dict, a, b)\n\tif a >= 256 then\n\t\ta, b = 0, b+1\n\t\tif b >= 256 then\n\t\t\tdict = {}\n\t\t\tb = 1\n\t\tend\n\tend\n\tdict[str] = char(a,b)\n\ta = a+1\n\treturn dict, a, b\nend\n\nlocal function compress(input)\n\tif type(input) ~= \"string\" then\n\t\terror (\"string expected, got \"..type(input))\n\tend\n\tlocal len = #input\n\tif len <= 1 then\n\t\treturn input\n\tend\n\n\tlocal dict = {}\n\tlocal a, b = 0, 1\n\n\tlocal result = { SIGC }\n\tlocal resultlen = 1\n\tlocal n = 2\n\tlocal word = \"\"\n\tfor i = 1, len do\n\t\tlocal c = sub(input, i, i)\n\t\tlocal wc = word..c\n\t\tif not (basedictcompress[wc] or dict[wc]) then\n\t\t\tlocal write = basedictcompress[word] or dict[word]\n\t\t\tif not write then\n\t\t\t\terror \"algorithm error, could not fetch word\"\n\t\t\tend\n\t\t\tresult[n] = write\n\t\t\tresultlen = resultlen + #write\n\t\t\tn = n+1\n\t\t\tif  len <= resultlen then\n\t\t\t\treturn input\n\t\t\tend\n\t\t\tdict, a, b = dictAddA(wc, dict, a, b)\n\t\t\tword = c\n\t\telse\n\t\t\tword = wc\n\t\tend\n\tend\n\tresult[n] = basedictcompress[word] or dict[word]\n\tresultlen = resultlen+#result[n]\n\tif  len <= resultlen then\n\t\treturn input\n\tend\n\treturn tconcat(result)\nend\n\nlocal function dictAddB(str, dict, a, b)\n\tif a >= 256 then\n\t\ta, b = 0, b+1\n\t\tif b >= 256 then\n\t\t\tdict = {}\n\t\t\tb = 1\n\t\tend\n\tend\n\tdict[char(a,b)] = str\n\ta = a+1\n\treturn dict, a, b\nend\n\nlocal function decompress(input)\n\tif type(input) ~= \"string\" then\n\t\terror( \"string expected, got \"..type(input))\n\tend\n\n\tif #input < 4 then\n\t\treturn input\n\tend\n\n\tlocal control = sub(input, 1, 4)\n\tif control ~= SIGC then\n\t\treturn input\n\tend\n\tinput = sub(input, 5)\n\tlocal len = #input\n\n\tif len < 2 then\n\t\terror(\"invalid input - not a compressed string\")\n\tend\n\n\tlocal dict = {}\n\tlocal a, b = 0, 1\n\n\tlocal result = {}\n\tlocal n = 1\n\tlocal last = sub(input, 1, 2)\n\tresult[n] = basedictdecompress[last] or dict[last]\n\tn = n+1\n\tfor i = 3, len, 2 do\n\t\tlocal code = sub(input, i, i+1)\n\t\tlocal lastStr = basedictdecompress[last] or dict[last]\n\t\tif not lastStr then\n\t\t\terror( \"could not find last from dict. Invalid input?\")\n\t\tend\n\t\tlocal toAdd = basedictdecompress[code] or dict[code]\n\t\tif toAdd then\n\t\t\tresult[n] = toAdd\n\t\t\tn = n+1\n\t\t\tdict, a, b = dictAddB(lastStr..sub(toAdd, 1, 1), dict, a, b)\n\t\telse\n\t\t\tlocal tmp = lastStr..sub(lastStr, 1, 1)\n\t\t\tresult[n] = tmp\n\t\t\tn = n+1\n\t\t\tdict, a, b = dictAddB(tmp, dict, a, b)\n\t\tend\n\t\tlast = code\n\tend\n\treturn tconcat(result)\nend\n\nreturn {\n    compress = compress,\n    decompress = decompress,\n}\n", "sys/modules/opus/http/pastebin.lua": "--- Parse the pastebin code from the given code or URL\nlocal function parseCode(paste)\n\tlocal patterns = {\n\t\t\"^([%a%d]+)$\",\n\t\t\"^https?://pastebin.com/([%a%d]+)$\",\n\t\t\"^pastebin.com/([%a%d]+)$\",\n\t\t\"^https?://pastebin.com/raw/([%a%d]+)$\",\n\t\t\"^pastebin.com/raw/([%a%d]+)$\",\n\t}\n\n\tfor i = 1, #patterns do\n\t\tlocal code = paste:match(patterns[i])\n\t\tif code then\n\t\treturn code\n\t\tend\n\tend\n\n\treturn nil\nend\n\n-- Download the contents of a paste\nlocal function download(code)\n\tif type(code) ~= \"string\" then\n\t\terror(\"bad argument #1 (expected string, got \" .. type(code) .. \")\", 2)\n\tend\n\n\tif not http then\n\t\treturn false, \"Pastebin requires http API\"\n\tend\n\n\t-- Add a cache buster so that spam protection is re-checked\n\tlocal cacheBuster = (\"%x\"):format(math.random(0, 2 ^ 30))\n\tlocal response, err = http.get(\n\t\t\"https://pastebin.com/raw/\" .. textutils.urlEncode(code) .. \"?cb=\" .. cacheBuster\n\t)\n\n\tif not response then\n\t\treturn response, err\n\tend\n\n\t-- If spam protection is activated, we get redirected to /paste with Content-Type: text/html\n\tlocal headers = response.getResponseHeaders()\n\tif not headers[\"Content-Type\"] or not headers[\"Content-Type\"]:find(\"^text/plain\") then\n\t\treturn false, \"Pastebin blocked due to spam protection\"\n\tend\n\n\tlocal contents = response.readAll()\n\tresponse.close()\n\treturn contents\nend\n\n-- Upload text to pastebin\nlocal function upload(name, text)\n\tif not http then\n\t\treturn false, \"Pastebin requires http API\"\n\tend\n\n\t-- POST the contents to pastebin\n\tlocal key = \"0ec2eb25b6166c0c27a394ae118ad829\"\n\tlocal response = http.post(\n\t\t\"https://pastebin.com/api/api_post.php\",\n\t\t\"api_option=paste&\" ..\n\t\t\"api_dev_key=\" .. key .. \"&\" ..\n\t\t\"api_paste_format=lua&\" ..\n\t\t\"api_paste_name=\" .. textutils.urlEncode(name) .. \"&\" ..\n\t\t\"api_paste_code=\" .. textutils.urlEncode(text)\n\t)\n\n\tif not response then\n\t\treturn false, \"Failed.\"\n\tend\n\n\tlocal contents = response.readAll()\n\tresponse.close()\n\n\treturn string.match(contents, \"[^/]+$\")\nend\n\n-- Download the contents to a file from pastebin\nlocal function get(code, path)\n\tif type(code) ~= \"string\" then\n\t\terror( \"bad argument #1 (expected string, got \" .. type(code) .. \")\", 2)\n\tend\n\n\tif type(path) ~= \"string\" then\n\t\terror(\"bad argument #2 (expected string, got \" .. type(path) .. \")\", 2)\n\tend\n\n\tlocal res, msg = download(code)\n\tif not res then\n\t\treturn res, msg\n\tend\n\n\tlocal file = fs.open(path, \"w\")\n\tfile.write(res)\n\tfile.close()\n\n\treturn true\nend\n\n-- Upload a file to pastebin.com\nlocal function put(path)\n\tif type(path) ~= \"string\" then\n\t\terror(\"bad argument #1 (expected string, got \" .. type(path) .. \")\", 2)\n\tend\n\n\t-- Determine file to upload\n\tif not fs.exists(path) or fs.isDir(path) then\n\t\treturn false, \"No such file\"\n\tend\n\n\t-- Read in the file\n\tlocal name = fs.getName(path)\n\tlocal file = fs.open(path, \"r\")\n\tlocal text = file.readAll()\n\tfile.close()\n\n\treturn upload(name, text)\nend\n\nreturn {\n\tdownload = download,\n\tupload = upload,\n\tget = get,\n\tput = put,\n\tparseCode = parseCode,\n}\n\n", "sys/modules/opus/fs/linkfs.lua": "local fs = _G.fs\n\nlocal linkfs = { }\n\n-- TODO: implement broken links\n\nlocal methods = { 'exists', 'getFreeSpace', 'getSize', 'attributes',\n\t'isDir', 'isReadOnly', 'list', 'makeDir', 'open', 'getDrive' }\n\nfor _,m in pairs(methods) do\n\tlinkfs[m] = function(node, dir, ...)\n\t\tdir = linkfs.resolve(node, dir)\n\t\treturn fs[m](dir, ...)\n\tend\nend\n\nfunction linkfs.resolve(node, dir)\n\treturn dir:gsub(node.mountPoint, node.source, 1)\nend\n\nfunction linkfs.mount(path, source)\n\tif not source then\n\t\terror('Source is required')\n\tend\n\tsource = fs.combine(source, '')\n\tif not fs.exists(source) then\n\t\terror('Source is missing')\n\tend\n\tif path == source then\n\t\treturn\n\tend\n\tif fs.isDir(source) then\n\t\treturn {\n\t\t\tsource = source,\n\t\t\tnodes = { },\n\t\t}\n\tend\n\treturn {\n\t\tsource = source\n\t}\nend\n\nfunction linkfs.copy(node, s, t)\n\ts = s:gsub(node.mountPoint, node.source, 1)\n\tt = t:gsub(node.mountPoint, node.source, 1)\n\treturn fs.copy(s, t)\nend\n\nfunction linkfs.delete(node, dir)\n\tif dir == node.mountPoint then\n\t\tfs.unmount(node.mountPoint)\n\telse\n\t\tdir = dir:gsub(node.mountPoint, node.source, 1)\n\t\treturn fs.delete(dir)\n\tend\nend\n\nfunction linkfs.find(node, spec)\n\tspec = spec:gsub(node.mountPoint, node.source, 1)\n\n\tlocal list = fs.find(spec)\n\tfor k,f in ipairs(list) do\n\t\tlist[k] = f:gsub(node.source, node.mountPoint, 1)\n\tend\n\n\treturn list\nend\n\nfunction linkfs.move(node, s, t)\n\ts = s:gsub(node.mountPoint, node.source, 1)\n\tt = t:gsub(node.mountPoint, node.source, 1)\n\treturn fs.move(s, t)\nend\n\nreturn linkfs", "sys/modules/opus/fs/urlfs.lua": "--local rttp = require('rttp')\nlocal Util = require('opus.util')\n\nlocal fs = _G.fs\n\nlocal urlfs = { }\n\nfunction urlfs.mount(path, url, force)\n\tif not url then\n\t\terror('URL is required')\n\tend\n\n\t-- only mount if the file does not exist already\n\tif not fs.exists(path) or force then\n\t\treturn {\n\t\t\turl = url,\n\t\t\tcreated = os.epoch('utc'),\n\t\t\tmodification = os.epoch('utc'),\n\t\t}\n\tend\nend\n\nfunction urlfs.attributes(node, path)\n\treturn path == node.mountPoint and {\n\t\tcreated = node.created,\n\t\tisDir = false,\n\t\tmodification = node.modification,\n\t\tsize = node.size or 0,\n\t}\nend\n\nfunction urlfs.delete(node, path)\n\tif path == node.mountPoint then\n\t\tfs.unmount(path)\n\tend\nend\n\nfunction urlfs.exists(node, path)\n\treturn path == node.mountPoint\nend\n\nfunction urlfs.getSize(node, path)\n\treturn path == node.mountPoint and node.size or 0\nend\n\nfunction urlfs.isReadOnly()\n\treturn false\nend\n\nfunction urlfs.isDir()\n\treturn false\nend\n\nfunction urlfs.getDrive()\n\treturn 'url'\nend\n\nfunction urlfs.open(node, fn, fl)\n\tif fl == 'w' or fl == 'wb' then\n\t\tfs.delete(fn)\n\t\treturn fs.open(fn, fl)\n\tend\n\n\tif fl ~= 'r' and fl ~= 'rb' then\n\t\terror('Unsupported mode')\n\tend\n\n\tlocal c = node.cache\n\tif not c then\n\t\tc = Util.httpGet(node.url)\n\t\tif c then\n\t\t\tnode.cache = c\n\t\t\tnode.size = #c\n\t\tend\n\tend\n\n\tif not c then\n\t\treturn\n\tend\n\n\tlocal ctr = 0\n\tlocal lines\n\n\tif fl == 'r' then\n\t\treturn {\n\t\t\tread = function()\n                ctr = ctr + 1\n                return c:sub(ctr, ctr)\n\t\t\tend,\n\t\t\treadLine = function()\n\t\t\t\tif not lines then\n\t\t\t\t\tlines = Util.split(c)\n\t\t\t\tend\n\t\t\t\tctr = ctr + 1\n\t\t\t\treturn lines[ctr]\n\t\t\tend,\n\t\t\treadAll = function()\n\t\t\t\treturn c\n\t\t\tend,\n\t\t\tclose = function()\n\t\t\t\tlines = nil\n\t\t\tend,\n\t\t}\n\tend\n\treturn {\n\t\treadAll = function()\n\t\t\treturn c\n\t\tend,\n\t\tread = function()\n\t\t\tctr = ctr + 1\n\t\t\treturn c:sub(ctr, ctr):byte()\n\t\tend,\n\t\tclose = function()\n\t\t\tctr = 0\n\t\tend,\n\t}\nend\n\nreturn urlfs\n", "sys/modules/opus/fs/ramfs.lua": "local Util   = require('opus.util')\n\nlocal fs = _G.fs\n\nlocal ramfs = { }\n\nfunction ramfs.mount(_, nodeType)\n\tif nodeType == 'directory' then\n\t\treturn {\n\t\t\tnodes = { },\n\t\t\tsize = 0,\n\t\t\tcreated = os.epoch('utc'),\n\t\t\tmodification = os.epoch('utc'),\n\t\t}\n\telseif nodeType == 'file' then\n\t\treturn {\n\t\t\tsize = 0,\n\t\t\tcreated = os.epoch('utc'),\n\t\t\tmodification = os.epoch('utc'),\n\t\t}\n\tend\n\terror('ramfs syntax: [directory, file]')\nend\n\nfunction ramfs.attributes(node)\n\treturn {\n\t\tcreated = node.created,\n\t\tisDir = not not node.nodes,\n\t\tmodification = node.modification,\n\t\tsize = node.size,\n\t}\nend\n\nfunction ramfs.delete(node, dir)\n\tif node.mountPoint == dir then\n\t\tfs.unmount(node.mountPoint)\n\tend\nend\n\nfunction ramfs.exists(node, fn)\n\treturn node.mountPoint == fn\nend\n\nfunction ramfs.getSize(node)\n\treturn node.size\nend\n\nfunction ramfs.isReadOnly()\n\treturn false\nend\n\nfunction ramfs.makeDir(_, dir)\n\tfs.mount(dir, 'ramfs', 'directory')\nend\n\nfunction ramfs.isDir(node, dir)\n\tif node.mountPoint == dir then\n\t\treturn not not node.nodes\n\tend\nend\n\nfunction ramfs.getDrive()\n\treturn 'ram'\nend\n\nfunction ramfs.getFreeSpace()\n\treturn math.huge\nend\n\nfunction ramfs.list(node, dir)\n\tif node.nodes and node.mountPoint == dir then\n\t\tlocal files = { }\n\t\tfor k in pairs(node.nodes) do\n\t\t\ttable.insert(files, k)\n\t\tend\n\t\treturn files\n\tend\n\terror('Not a directory')\nend\n\nfunction ramfs.open(node, fn, fl)\n\tlocal modes = Util.transpose { 'r', 'w', 'rb', 'wb', 'a' }\n\tif not modes[fl] then\n\t\terror('Unsupported mode')\n\tend\n\n\tif fl == 'a' then\n\t\tif node.mountPoint ~= fn then\n\t\t\tfl = 'w'\n\t\telse\n\t\t\tlocal c = type(node.contents) == 'table'\n\t\t\t\tand string.char(table.unpack(node.contents))\n\t\t\t\tor node.contents\n\t\t\t\tor ''\n\n\t\t\treturn {\n\t\t\t\twrite = function(str)\n\t\t\t\t\tc = c .. str\n\t\t\t\tend,\n\t\t\t\twriteLine = function(str)\n\t\t\t\t\tc = c .. str .. '\\n'\n\t\t\t\tend,\n\t\t\t\tflush = function()\n\t\t\t\t\tnode.contents = c\n\t\t\t\t\tnode.size = #c\n\t\t\t\tend,\n\t\t\t\tclose = function()\n\t\t\t\t\tnode.contents = c\n\t\t\t\t\tnode.size = #c\n\t\t\t\t\tc = nil\n\t\t\t\tend,\n\t\t\t}\n\t\tend\n\tend\n\n\tif fl == 'r' then\n\t\tif node.mountPoint ~= fn then\n\t\t\treturn\n\t\tend\n\n\t\tlocal c = type(node.contents) == 'table'\n\t\t\tand string.char(table.unpack(node.contents))\n\t\t\tor node.contents\n\n\t\tlocal ctr = 0\n\t\tlocal lines\n\t\treturn {\n\t\t\tread = function(n)\n\t\t\t\tn = n or 1\n\t\t\t\tif ctr >= node.size then\n\t\t\t\t\treturn\n\t\t\t\tend\n\t\t\t\tlocal t = c:sub(ctr + 1, ctr + n)\n\t\t\t\tctr = ctr + n\n\t\t\t\treturn t\n\t\t\tend,\n\t\t\treadLine = function()\n\t\t\t\tif not lines then\n\t\t\t\t\tlines = Util.split(c)\n\t\t\t\tend\n\t\t\t\tctr = ctr + 1\n\t\t\t\treturn lines[ctr]\n\t\t\tend,\n\t\t\treadAll = function()\n\t\t\t\treturn c\n\t\t\tend,\n\t\t\tclose = function()\n\t\t\t\tlines = nil\n\t\t\tend,\n\t\t}\n\telseif fl == 'w' then\n\t\tnode = fs.mount(fn, 'ramfs', 'file')\n\n\t\tlocal c = ''\n\t\treturn {\n\t\t\twrite = function(str)\n\t\t\t\tc = c .. str\n\t\t\tend,\n\t\t\twriteLine = function(str)\n\t\t\t\tc = c .. str .. '\\n'\n\t\t\tend,\n\t\t\tflush = function()\n\t\t\t\tnode.contents = c\n\t\t\t\tnode.size = #c\n\t\t\tend,\n\t\t\tclose = function()\n\t\t\t\tnode.contents = c\n\t\t\t\tnode.size = #c\n\t\t\t\tc = nil\n\t\t\tend,\n\t\t}\n\telseif fl == 'rb' then\n\t\tif node.mountPoint ~= fn or not node.contents then\n\t\t\treturn\n\t\tend\n\n\t\tlocal c = node.contents\n\t\tif type(node.contents) == 'string' then\n\t\t\tc = { }\n\t\t\tfor i = 1, node.size do\n\t\t\t\tc[i] = node.contents:sub(i, i):byte()\n\t\t\tend\n\t\tend\n\n\t\tlocal ctr = 0\n\t\treturn {\n\t\t\treadAll = function()\n\t\t\t\treturn string.char(table.unpack(c))\n\t\t\tend,\n\t\t\tread = function(n)\n\t\t\t\tif n and n > 1 and ctr < node.size then\n\t\t\t\t\t-- some programs open in rb, when it should have\n\t\t\t\t\t-- been opened in r - attempt to support multiple read\n\t\t\t\t\t-- if nils are present in data, this will fail\n\t\t\t\t\tlocal t = string.char(table.unpack(c, ctr + 1, ctr + n))\n\t\t\t\t\tctr = ctr + n\n\t\t\t\t\treturn t\n\t\t\t\tend\n\t\t\t\tctr = ctr + 1\n\t\t\t\treturn c[ctr]\n\t\t\tend,\n\t\t\tclose = function()\n\t\t\tend,\n\t\t}\n\n\telseif fl == 'wb' then\n\t\tnode = fs.mount(fn, 'ramfs', 'file')\n\n\t\tlocal c = { }\n\t\treturn {\n\t\t\twrite = function(b)\n\t\t\t\tif type(b) == 'number' then\n\t\t\t\t\ttable.insert(c, b)\n\t\t\t\telse\n\t\t\t\t\tfor i = 1, #b do\n\t\t\t\t\t\ttable.insert(c, b:sub(i, i):byte())\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\tend,\n\t\t\tflush = function()\n\t\t\t\tnode.contents = c\n\t\t\t\tnode.size = #c\n\t\t\tend,\n\t\t\tclose = function()\n\t\t\t\tnode.contents = c\n\t\t\t\tnode.size = #c\n\t\t\t\tc = nil\n\t\t\tend,\n\t\t}\n\tend\nend\n\nreturn ramfs\n", "sys/modules/opus/fs/gitfs.lua": "local git = require('opus.git')\n\nlocal fs = _G.fs\n\nlocal gitfs = { }\n\nfunction gitfs.mount(dir, repo)\n\tif not repo then\n\t\terror('gitfs syntax: repo')\n\tend\n\n\tlocal list = git.list(repo)\n\tfor path, entry in pairs(list) do\n\t\tif not fs.exists(fs.combine(dir, path)) then\n\t\t\tlocal node = fs.mount(fs.combine(dir, path), 'urlfs', entry.url)\n\t\t\tnode.size = entry.size\n\t\tend\n\tend\nend\n\nreturn gitfs\n", "sys/modules/opus/fs/netfs.lua": "local Socket       = require('opus.socket')\nlocal synchronized = require('opus.sync').sync\n\nlocal fs = _G.fs\n\nlocal netfs = { }\n\nlocal function remoteCommand(node, msg)\n\tfor _ = 1, 2 do\n\t\tif not node.socket then\n\t\t\tnode.socket = Socket.connect(node.id, 139)\n\t\tend\n\n\t\tif not node.socket then\n\t\t\terror('netfs: Unable to establish connection to ' .. node.id)\n\t\t\tfs.unmount(node.mountPoint)\n\t\t\treturn\n\t\tend\n\n\t\tlocal ret\n\t\tsynchronized(node.socket, function()\n\t\t\tnode.socket:write(msg)\n\t\t\tret = node.socket:read(1)\n\t\tend)\n\n\t\tif ret then\n\t\t\treturn ret.response\n\t\tend\n\t\tnode.socket:close()\n\t\tnode.socket = nil\n\tend\n\terror('netfs: Connection failed', 2)\nend\n\nlocal methods = { 'delete', 'exists', 'getFreeSpace', 'makeDir', 'list', 'listEx', 'attributes' }\n\nlocal function resolve(node, dir)\n\t-- TODO: Wrong ! (does not support names with dashes)\n\tdir = dir:gsub(node.mountPoint, '', 1)\n\treturn fs.combine(node.source, dir)\nend\n\nfor _,m in pairs(methods) do\n\tnetfs[m] = function(node, dir)\n\t\tdir = resolve(node, dir)\n\n\t\treturn remoteCommand(node, {\n\t\t\tfn = m,\n\t\t\targs = { dir },\n\t\t})\n\tend\nend\n\nfunction netfs.mount(_, id, source)\n\tif not id or not tonumber(id) then\n\t\terror('ramfs syntax: computerId [directory]')\n\tend\n\treturn {\n\t\tid = tonumber(id),\n\t\tnodes = { },\n\t\tsource = source or '',\n\t}\nend\n\nfunction netfs.getDrive()\n\treturn 'net'\nend\n\nfunction netfs.complete(node, partial, dir, includeFiles, includeSlash)\n\tdir = resolve(node, dir)\n\n\treturn remoteCommand(node, {\n\t\tfn = 'complete',\n\t\targs = { partial, dir, includeFiles, includeSlash },\n\t})\nend\n\nfunction netfs.copy(node, s, t)\n\ts = resolve(node, s)\n\tt = resolve(node, t)\n\n\treturn remoteCommand(node, {\n\t\tfn = 'copy',\n\t\targs = { s, t },\n\t})\nend\n\nfunction netfs.isDir(node, dir)\n\tif dir == node.mountPoint and node.source == '' then\n\t\treturn true\n\tend\n\treturn remoteCommand(node, {\n\t\tfn = 'isDir',\n\t\targs = { resolve(node, dir) },\n\t})\nend\n\nfunction netfs.isReadOnly(node, dir)\n\tif dir == node.mountPoint and node.source == '' then\n\t\treturn false\n\tend\n\treturn remoteCommand(node, {\n\t\tfn = 'isReadOnly',\n\t\targs = { resolve(node, dir) },\n\t})\nend\n\nfunction netfs.getSize(node, dir)\n\tif dir == node.mountPoint and node.source == '' then\n\t\treturn 0\n\tend\n\treturn remoteCommand(node, {\n\t\tfn = 'getSize',\n\t\targs = { resolve(node, dir) },\n\t})\nend\n\nfunction netfs.find(node, spec)\n\tspec = resolve(node, spec)\n\tlocal list = remoteCommand(node, {\n\t\tfn = 'find',\n\t\targs = { spec },\n\t})\n\n\tfor k,f in ipairs(list) do\n\t\tlist[k] = fs.combine(node.mountPoint, f)\n\tend\n\n\treturn list\nend\n\nfunction netfs.move(node, s, t)\n\ts = resolve(node, s)\n\tt = resolve(node, t)\n\n\treturn remoteCommand(node, {\n\t\tfn = 'move',\n\t\targs = { s, t },\n\t})\nend\n\nfunction netfs.open(node, fn, fl)\n\tfn = resolve(node, fn)\n\n\tlocal vfh = remoteCommand(node, {\n\t\tfn = 'open',\n\t\targs = { fn, fl },\n\t})\n\n\tif vfh then\n\t\tvfh.node = node\n\t\tfor _,m in ipairs(vfh.methods) do\n\t\t\tvfh[m] = function(...)\n\t\t\t\treturn remoteCommand(node, {\n\t\t\t\t\tfn = 'fileOp',\n\t\t\t\t\targs = { vfh.fileUid, m, ... },\n\t\t\t\t})\n\t\t\tend\n\t\tend\n\tend\n\n\treturn vfh\nend\n\nreturn netfs\n", "sys/apps/cshell.lua": "local Config     = require('opus.config')\n\nlocal read  = _G.read\nlocal shell = _ENV.shell\n\nif not _G.http.websocket then\n\terror('Requires CC: Tweaked')\nend\n\nif not _G.cloud_catcher then\n\tlocal key = Config.load('cloud').key\n\n\tif not key then\n\t\tprint('Visit https://cloud-catcher.squiddev.cc')\n\t\tprint('Paste key: ')\n\t\tkey = read()\n\t\tif #key == 0 then\n\t\t\treturn\n\t\tend\n\tend\n\tprint('Connecting...')\n\tshell.run('cloud ' .. key)\nend\n", "sys/apps/Lua.lua": "local History    = require('opus.history')\nlocal UI         = require('opus.ui')\nlocal Util       = require('opus.util')\n\nlocal colors     = _G.colors\nlocal os         = _G.os\nlocal textutils  = _G.textutils\nlocal term       = _G.term\n\nlocal sandboxEnv = setmetatable(Util.shallowCopy(_ENV), { __index = _G })\nsandboxEnv.exit = function() UI:quit() end\nsandboxEnv._echo = function( ... ) return { ... } end\n_G.requireInjector(sandboxEnv)\n\nUI:configure('Lua', ...)\n\nlocal command = ''\nlocal counter = 1\nlocal history = History.load('usr/.lua_history', 25)\n\nlocal page = UI.Page {\n\tmenuBar = UI.MenuBar {\n\t\tbuttons = {\n\t\t\t{ text = 'Local',  event = 'local'  },\n\t\t\t{ text = 'Global', event = 'global' },\n\t\t\t{ text = 'Device', event = 'device', name = 'Device' },\n\t\t},\n\t},\n\tprompt = UI.TextEntry {\n\t\ty = 2,\n\t\tshadowText = 'enter command',\n\t\taccelerators = {\n\t\t\tenter               = 'command_enter',\n\t\t\tup                  = 'history_back',\n\t\t\tdown                = 'history_forward',\n\t\t\tmouse_rightclick    = 'clear_prompt',\n\t\t\t[ 'control-space' ] = 'autocomplete',\n\t\t},\n\t},\n\ttabs = UI.Tabs {\n\t\ty = 3,\n\t\tformatted = UI.Tab {\n\t\t\ttitle = 'Formatted',\n\t\t\tindex = 1,\n\t\t\tgrid = UI.ScrollingGrid {\n\t\t\t\tcolumns = {\n\t\t\t\t\t{ heading = 'Key',   key = 'name'  },\n\t\t\t\t\t{ heading = 'Value', key = 'value' },\n\t\t\t\t},\n\t\t\t\tsortColumn = 'name',\n\t\t\t\tautospace = true,\n\t\t\t},\n\t\t},\n\t\toutput = UI.Tab {\n\t\t\ttitle = 'Output',\n\t\t\tindex = 2,\n\t\t\tbackgroundColor = 'black',\n\t\t\toutput = UI.Embedded {\n\t\t\t\ty = 2,\n\t\t\t\tmaxScroll = 1000,\n\t\t\t\tbackgroundColor = 'black',\n\t\t\t},\n\t\t\tdraw = function(self)\n\t\t\t\tself:write(1, 1, string.rep('\\131', self.width), 'black', 'primary')\n\t\t\t\tself:drawChildren()\n\t\t\tend,\n\t\t},\n\t},\n}\n\npage.grid = page.tabs.formatted.grid\npage.output = page.tabs.output.output\n\nfunction page:setPrompt(value, focus)\n\tself.prompt:setValue(value)\n\n\tif value:sub(-1) == ')' then\n\t\tself.prompt:setPosition(#value - 1)\n\telse\n\t\tself.prompt:setPosition(#value)\n\tend\n\n\tself.prompt:draw()\n\tif focus then\n\t\tpage:setFocus(self.prompt)\n\tend\nend\n\nfunction page:enable()\n\tUI.Page.enable(self)\n\tself:setFocus(self.prompt)\nend\n\nlocal function autocomplete(env, oLine, x)\n\tlocal sLine = oLine:sub(1, x)\n\tlocal nStartPos = sLine:find(\"[a-zA-Z0-9_%.]+$\")\n\tif nStartPos then\n\t\tsLine = sLine:sub(nStartPos)\n\tend\n\n\tif #sLine > 0 then\n\t\tlocal results = textutils.complete(sLine, env)\n\n\t\tif #results == 1 then\n\t\t\treturn Util.insertString(oLine, results[1], x + 1)\n\n\t\telseif #results > 1 then\n\t\t\tlocal prefix = results[1]\n\t\t\tfor n = 1, #results do\n\t\t\t\tlocal result = results[n]\n\t\t\t\twhile #prefix > 0 do\n\t\t\t\t\tif result:find(prefix, 1, true) == 1 then\n\t\t\t\t\t\tbreak\n\t\t\t\t\tend\n\t\t\t\t\tprefix = prefix:sub(1, #prefix - 1)\n\t\t\t\tend\n\t\t\tend\n\t\t\tif #prefix > 0 then\n\t\t\t\treturn Util.insertString(oLine, prefix, x + 1)\n\t\t\tend\n\t\tend\n\tend\n\treturn oLine\nend\n\nfunction page:eventHandler(event)\n\tif event.type == 'global' then\n\t\tself:setPrompt('_G', true)\n\t\tself:executeStatement('_G')\n\t\tcommand = nil\n\n\telseif event.type == 'local' then\n\t\tself:setPrompt('_ENV', true)\n\t\tself:executeStatement('_ENV')\n\t\tcommand = nil\n\n\telseif event.type == 'tab_select' then\n\t\tself:setFocus(self.prompt)\n\n\telseif event.type == 'show_output' then\n\t\tself.tabs:selectTab(self.tabs.output)\n\n\telseif event.type == 'autocomplete' then\n\t\tlocal value = self.prompt.value or ''\n\t\tlocal sz = #value\n\t\tlocal pos = self.prompt.entry.pos\n\t\tself:setPrompt(autocomplete(sandboxEnv, value, self.prompt.entry.pos))\n\t\tself.prompt:setPosition(pos + #(self.prompt.value or '') - sz)\n\t\tself.prompt:updateCursor()\n\n\telseif event.type == 'device' then\n\t\tself:setPrompt('device', true)\n\t\tself:executeStatement('device')\n\n\telseif event.type == 'history_back' then\n\t\tlocal value = history:back()\n\t\tif value then\n\t\t\tself:setPrompt(value)\n\t\tend\n\n\telseif event.type == 'history_forward' then\n\t\tself:setPrompt(history:forward() or '')\n\n\telseif event.type == 'clear_prompt' then\n\t\tself:setPrompt('')\n\t\thistory:reset()\n\n\telseif event.type == 'command_enter' then\n\t\tlocal s = tostring(self.prompt.value or '')\n\n\t\tif #s > 0 then\n\t\t\tself:executeStatement(s)\n\t\telse\n\t\t\tlocal t = { }\n\t\t\tfor k = #history.entries, 1, -1 do\n\t\t\t\ttable.insert(t, {\n\t\t\t\t\tname = #t + 1,\n\t\t\t\t\tvalue = history.entries[k],\n\t\t\t\t\tisHistory = true,\n\t\t\t\t\tpos = k,\n\t\t\t\t})\n\t\t\tend\n\t\t\thistory:reset()\n\t\t\tcommand = nil\n\t\t\tself.grid:setValues(t)\n\t\t\tself.grid:setIndex(1)\n\t\t\tself.grid:draw()\n\t\tend\n\t\treturn true\n\n\telse\n\t\treturn UI.Page.eventHandler(self, event)\n\tend\n\treturn true\nend\n\nfunction page:setResult(result)\n\tlocal t = { }\n\n\tlocal function safeValue(v)\n\t\tif type(v) == 'string' or type(v) == 'number' then\n\t\t\treturn v\n\t\tend\n\t\treturn tostring(v)\n\tend\n\n\tif type(result) == 'table' then\n\t\tfor k,v in pairs(result) do\n\t\t\tlocal entry = {\n\t\t\t\tname = safeValue(k),\n\t\t\t\trawName = k,\n\t\t\t\tvalue = safeValue(v),\n\t\t\t\trawValue = v,\n\t\t\t}\n\t\t\tif type(v) == 'table' then\n\t\t\t\tif Util.size(v) == 0 then\n\t\t\t\t\tentry.value = 'table: (empty)'\n\t\t\t\telse\n\t\t\t\t\tentry.value = tostring(v)\n\t\t\t\tend\n\t\t\tend\n\t\t\ttable.insert(t, entry)\n\t\tend\n\telse\n\t\ttable.insert(t, {\n\t\t\tname = type(result),\n\t\t\tvalue = tostring(result),\n\t\t\trawValue = result,\n\t\t})\n\tend\n\tself.grid:setValues(t)\n\tself.grid:setIndex(1)\n\tself.grid:draw()\nend\n\nfunction page.grid:eventHandler(event)\n\tlocal entry = self:getSelected()\n\n\tlocal function commandAppend()\n\t\tif entry.isHistory then\n\t\t\t--history.setPosition(entry.pos)\n\t\t\treturn entry.value\n\t\tend\n\t\tif type(entry.rawValue) == 'function' then\n\t\t\tif command then\n\t\t\t\t return command .. '.' .. entry.name .. '()'\n\t\t\tend\n\t\t\treturn entry.name .. '()'\n\t\tend\n\t\tif command then\n\t\t\tif type(entry.rawName) == 'number' then\n\t\t\t\treturn command .. '[' .. entry.name .. ']'\n\t\t\tend\n\t\t\tif entry.name:match(\"%W\") or\n\t\t\t\t entry.name:sub(1, 1):match(\"%d\") then\n\t\t\t\treturn command .. \"['\" .. tostring(entry.name) .. \"']\"\n\t\t\tend\n\t\t\treturn command .. '.' .. entry.name\n\t\tend\n\t\treturn entry.name\n\tend\n\n\tif event.type == 'grid_focus_row' then\n\t\tif self.focused then\n\t\t\tpage:setPrompt(commandAppend())\n\t\tend\n\telseif event.type == 'grid_select' then\n\t\tpage:setPrompt(commandAppend(), true)\n\t\tpage:executeStatement(commandAppend())\n\n\telseif event.type == 'copy' then\n\t\tif entry then\n\t\t\tos.queueEvent('clipboard_copy', entry.rawValue)\n\t\tend\n\telse\n\t\treturn UI.ScrollingGrid.eventHandler(self, event)\n\tend\n\treturn true\nend\n\nfunction page:rawExecute(s)\n\tlocal fn, m\n\tlocal wrapped\n\n\tfn = load('return (' ..s.. ')', 'lua', nil, sandboxEnv)\n\n\tif fn then\n\t\tfn = load('return {' ..s.. '}', 'lua', nil, sandboxEnv)\n\t\twrapped = true\n\tend\n\n\tlocal t = os.clock()\n\tif fn then\n\t\tfn, m = pcall(fn)\n\t\tif #m <= 1 and wrapped then\n\t\t\tm = m[1]\n\t\tend\n\telse\n\t\tfn, m = load(s, 'lua', nil, sandboxEnv)\n\t\tif fn then\n\t\t\tt = os.clock()\n\t\t\tfn, m = pcall(fn)\n\t\tend\n\tend\n\n\tif fn then\n\t\tt = os.clock() - t\n\n\t\tlocal bg, fg = term.getBackgroundColor(), term.getTextColor()\n\t\tterm.setTextColor(colors.cyan)\n\t\tterm.setBackgroundColor(colors.black)\n\t\tterm.write(string.format('out [%.2f]: ', t))\n\t\tterm.setBackgroundColor(bg)\n\t\tterm.setTextColor(fg)\n\t\tif m or wrapped then\n\t\t\tUtil.print(m or 'nil')\n\t\telse\n\t\t\tprint()\n\t\tend\n\telse\n\t\t_G.printError(m)\n\tend\n\n\treturn fn, m\nend\n\nfunction page:executeStatement(statement)\n\tcommand = statement\n\n\thistory:add(statement)\n\thistory:back()\n\n\tlocal s, m\n\tlocal oterm = term.redirect(self.output.win)\n\tself.output.win.scrollBottom()\n\tlocal bg, fg = term.getBackgroundColor(), term.getTextColor()\n\tterm.setBackgroundColor(colors.black)\n\tterm.setTextColor(colors.green)\n\tterm.write(string.format('in [%d]: ', counter))\n\tterm.setBackgroundColor(bg)\n\tterm.setTextColor(fg)\n\tprint(tostring(statement))\n\n\tpcall(function()\n\t\ts, m = self:rawExecute(command)\n\tend)\n\n\tterm.redirect(oterm)\n\tcounter = counter + 1\n\n\tif s and m then\n\t\tself:setResult(m)\n\telse\n\t\tself.grid:setValues({ })\n\t\tself.grid:draw()\n\t\tif m and not self.output.enabled then\n\t\t\tself:emit({ type = 'show_output' })\n\t\tend\n\tend\nend\n\nlocal args = Util.parse(...)\nif args[1] then\n\tcommand = 'args[1]'\n\tsandboxEnv.args = args\n\tpage:setResult(args[1])\n\tpage:setPrompt(command)\nend\n\nUI:setPage(page)\nUI:start()\n", "sys/apps/Sniff.lua": "local UI    = require('opus.ui')\nlocal Event = require('opus.event')\nlocal Util  = require('opus.util')\n\nlocal colors     = _G.colors\nlocal device     = _G.device\nlocal textutils  = _G.textutils\nlocal multishell = _ENV.multishell\n\nlocal gridColumns = {}\ntable.insert(gridColumns, { heading = '#',  key = 'id', width = 5, align = 'right' })\ntable.insert(gridColumns, { heading = 'Port', key = 'portid', width = 5, align = 'right' })\ntable.insert(gridColumns, { heading = 'Reply', key = 'replyid', width = 5, align = 'right' })\nif UI.term.width > 50 then\n\ttable.insert(gridColumns, { heading = 'Dist', key = 'distance', width = 6, align = 'right' })\nend\ntable.insert(gridColumns, { heading = 'Msg', key = 'packetStr' })\n\nlocal page = UI.Page {\n\tpaused = false,\n\tindex = 1,\n\tnotification = UI.Notification { },\n\taccelerators = { ['control-q'] = 'quit' },\n\n\tmenuBar = UI.MenuBar {\n\t\tbuttons = {\n\t\t\t{ text = 'Pause', event = 'pause_click', name = 'pauseButton' },\n\t\t\t{ text = 'Clear', event = 'clear_click' },\n\t\t\t{ text = 'Config', event = 'config_click' },\n\t\t},\n\t},\n\n\tpacketGrid = UI.ScrollingGrid {\n\t\ty = 2,\n\t\tmaxPacket = 300,\n\t\tinverseSort = true,\n\t\tsortColumn = 'id',\n\t\tcolumns = gridColumns,\n\t\taccelerators = { ['space'] = 'pause_click' },\n\t},\n\n\tconfigSlide = UI.SlideOut {\n\t\ty = -11,\n\t\ttitleBar = UI.TitleBar { title = 'Sniffer Config', event = 'config_close', backgroundColor = colors.black },\n\t\taccelerators = { ['backspace'] = 'config_close' },\n\t\tconfigTabs = UI.Tabs {\n\t\t\ty = 2,\n\t\t\tfilterTab = UI.Tab {\n\t\t\t\ttitle = 'Filter',\n\t\t\t\tnoFill = true,\n\t\t\t\tfilterGridText = UI.Text {\n\t\t\t\t\tx = 2, y = 2,\n\t\t\t\t\tvalue = 'ID filter',\n\t\t\t\t},\n\t\t\t\tfilterGrid = UI.ScrollingGrid {\n\t\t\t\t\tx = 2, y = 3,\n\t\t\t\t\twidth = 10, height = 4,\n\t\t\t\t\tdisableHeader = true,\n\t\t\t\t\tcolumns = {\n\t\t\t\t\t\t{ key = 'id', width = 5 },\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tfilterEntry = UI.TextEntry {\n\t\t\t\t\tx = 2, y = 8,\n\t\t\t\t\twidth = 7,\n\t\t\t\t\tshadowText = 'ID',\n\t\t\t\t\tlimit = 5,\n\t\t\t\t\taccelerators = { enter = 'filter_add' },\n\t\t\t\t},\n\t\t\t\tfilterAdd = UI.Button {\n\t\t\t\t\tx = 10, y = 8,\n\t\t\t\t\ttext = '+',\n\t\t\t\t\tevent = 'filter_add',\n\t\t\t\t},\n\t\t\t\tfilterAllCheck = UI.Checkbox {\n\t\t\t\t\tx = 14, y = 8,\n\t\t\t\t\tvalue = false,\n\t\t\t\t},\n\t\t\t\tfilterAddText = UI.Text {\n\t\t\t\t\tx = 18, y = 8,\n\t\t\t\t\tvalue = \"Use ID filter\",\n\t\t\t\t},\n\t\t\t\trangeText = UI.Text {\n\t\t\t\t\tx = 15, y = 2,\n\t\t\t\t\tvalue = \"Distance filter\",\n\t\t\t\t},\n\t\t\t\trangeEntry = UI.TextEntry {\n\t\t\t\t\tx = 15, y = 3,\n\t\t\t\t\twidth = 10,\n\t\t\t\t\tlimit = 8,\n\t\t\t\t\tshadowText = 'Range',\n\t\t\t\t\ttransform = 'number',\n\t\t\t\t},\n\t\t\t},\n\t\t\tmodemTab = UI.Tab {\n\t\t\t\ttitle = 'Modem',\n\t\t\t\tchannelGrid = UI.ScrollingGrid {\n\t\t\t\t\tx = 2, y = 2,\n\t\t\t\t\twidth = 12, height = 5,\n\t\t\t\t\tautospace = true,\n\t\t\t\t\tcolumns = {{ heading = 'Open Ports', key = 'port' }},\n\t\t\t\t},\n\t\t\t\tmodemGrid = UI.ScrollingGrid {\n\t\t\t\t\tx = 15, y = 2,\n\t\t\t\t\tex = -2, height = 5,\n\t\t\t\t\tautospace = true,\n\t\t\t\t\tcolumns = {\n\t\t\t\t\t\t{ heading = 'Side', key = 'side' },\n\t\t\t\t\t\t{ heading = 'Type', key = 'type' },\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tchannelEntry = UI.TextEntry {\n\t\t\t\t\tx = 2, y = 8,\n\t\t\t\t\twidth = 7,\n\t\t\t\t\tshadowText = 'ID',\n\t\t\t\t\tlimit = 5,\n\t\t\t\t\taccelerators = { enter = 'channel_add' },\n\t\t\t\t},\n\t\t\t\tchannelAdd = UI.Button {\n\t\t\t\t\tx = 10, y = 8,\n\t\t\t\t\ttext = '+',\n\t\t\t\t\tevent = 'channel_add',\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t},\n\n\tpacketSlide = UI.SlideOut {\n\t\ttitleBar = UI.TitleBar {\n\t\t\ttitle = 'Packet Information',\n\t\t\tevent = 'packet_close',\n\t\t},\n\t\taccelerators = {\n\t\t\t['backspace'] = 'packet_close',\n\t\t\t['left'] = 'prev_packet',\n\t\t\t['right'] = 'next_packet',\n\t\t},\n\t\tpacketMeta = UI.Grid {\n\t\t\tx = 2, y = 2,\n\t\t\tex = 23, height = 4,\n\t\t\tinactive = true,\n\t\t\tcolumns = {\n\t\t\t\t{ key = 'text' },\n\t\t\t\t{ key = 'value', align = 'right', textColor = colors.yellow },\n\t\t\t},\n\t\t\tvalues = {\n\t\t\t\tport = { text = 'Port' },\n\t\t\t\treply = { text = 'Reply' },\n\t\t\t\tdist = { text = 'Distance' },\n\t\t\t}\n\t\t},\n\t\tpacketButton = UI.Button {\n\t\t\tx = 25, y = 5,\n\t\t\ttext = 'Open in Lua',\n\t\t\tevent = 'packet_lua',\n\t\t},\n\t\tpacketData = UI.TextArea {\n\t\t\ty = 7, ey = -1,\n\t\t\tbackgroundColor = colors.black,\n\t\t},\n\t},\n}\n\nlocal filterConfig = page.configSlide.configTabs.filterTab\nlocal modemConfig = page.configSlide.configTabs.modemTab\n\nfunction filterConfig:eventHandler(event)\n\tif event.type == 'filter_add' then\n\t\tlocal id = tonumber(self.filterEntry.value)\n\t\tif id then self.filterGrid.values[id] = { id = id }\n\t\t\tself.filterGrid:update()\n\t\t\tself.filterEntry:reset()\n\t\t\tself:draw()\n\t\tend\n\n\telseif event.type == 'grid_select' then\n\t\tself.filterGrid.values[event.selected.id] = nil\n\t\tself.filterGrid:update()\n\t\tself.filterGrid:draw()\n\n\telse return UI.Tab.eventHandler(self, event)\n\tend\n\treturn true\nend\n\nfunction modemConfig:loadChannel()\n\tfor chan = 0, 65535 do\n\t\tself.currentModem.openChannels[chan] = self.currentModem.device.isOpen(chan) and { port = chan } or nil\n\tend\n\tself.channelGrid:setValues(self.currentModem.openChannels)\n\tself.currentModem.loaded = true\nend\n\nfunction modemConfig:enable()\n\tif not self.currentModem.loaded then\n\t\tself:loadChannel()\n\tend\n\n\tUI.Tab.enable(self)\nend\n\nfunction modemConfig:eventHandler(event)\n\tif event.type == 'channel_add' then\n\t\tlocal id = tonumber(modemConfig.channelEntry.value)\n\t\tif id then\n\t\t\tself.currentModem.openChannels[id] = { port = id }\n\t\t\tself.currentModem.device.open(id)\n\t\t\tself.channelGrid:setValues(self.currentModem.openChannels)\n\t\t\tself.channelGrid:update()\n\t\t\tself.channelEntry:reset()\n\t\t\tself:draw()\n\t\tend\n\n\telseif event.type == 'grid_select' then\n\t\tif event.element == self.channelGrid then\n\t\t\tself.currentModem.openChannels[event.selected.port] = nil\n\t\t\tself.currentModem.device.close(event.selected.port)\n\t\t\tself.channelGrid:setValues(self.currentModem.openChannels)\n\t\t\tpage.configSlide.configTabs.modemTab.channelGrid:update()\n\t\t\tpage.configSlide.configTabs.modemTab.channelGrid:draw()\n\n\t\telseif event.element == self.modemGrid then\n\t\t\tself.currentModem = event.selected\n\t\t\tpage.notification:info(\"Loading channel list\")\n\t\t\tpage:sync()\n\t\t\tmodemConfig:loadChannel()\n\t\t\tpage.notification:success(\"Now using modem on \" .. self.currentModem.side)\n\t\t\tself.channelGrid:draw()\n\t\tend\n\n\telse return UI.Tab.eventHandler(self, event)\n\tend\n\treturn true\nend\n\nfunction page.packetSlide:setPacket(packet)\n\tself.currentPacket = packet\n\tlocal p, res = pcall(textutils.serialize, page.packetSlide.currentPacket.message)\n\tself.packetData.textColor = p and colors.white or colors.red\n\tself.packetData:setText(res)\n\tself.packetMeta.values.port.value = page.packetSlide.currentPacket.portid\n\tself.packetMeta.values.reply.value = page.packetSlide.currentPacket.replyid\n\tself.packetMeta.values.dist.value = Util.round(page.packetSlide.currentPacket.distance, 2)\nend\n\nfunction page.packetSlide:show(packet)\n\tself:setPacket(packet)\n\n\tUI.SlideOut.show(self)\nend\n\nfunction page.packetSlide:eventHandler(event)\n\tif event.type == 'packet_close' then\n\t\tself:hide()\n\t\tpage:setFocus(page.packetGrid)\n\n\telseif event.type == 'packet_lua' then\n\t\tmultishell.openTab(_ENV, { path = 'sys/apps/Lua.lua', args = { self.currentPacket.message }, focused = true })\n\n\telseif event.type == 'prev_packet' then\n\t\tlocal c = self.currentPacket\n\t\tlocal n = page.packetGrid.values[c.id - 1]\n\t\tif n then\n\t\t\tself:setPacket(n)\n\t\t\tself:draw()\n\t\tend\n\n\telseif event.type == 'next_packet' then\n\t\tlocal c = self.currentPacket\n\t\tlocal n = page.packetGrid.values[c.id + 1]\n\t\tif n then\n\t\t\tself:setPacket(n)\n\t\t\tself:draw()\n\t\tend\n\n\telse return UI.SlideOut.eventHandler(self, event)\n\tend\n\treturn true\nend\n\nfunction page.packetGrid:getDisplayValues(row)\n\trow = Util.shallowCopy(row)\n\trow.distance = Util.toBytes(Util.round(row.distance), 2)\n\treturn row\nend\n\nfunction page.packetGrid:addPacket(packet)\n\tif not page.paused and (packet.distance <= (filterConfig.rangeEntry.value or math.huge)) and (not filterConfig.filterAllCheck.value or filterConfig.filterGrid.values[packet.portid]) then\n\t\tpage.index = page.index + 1\n\t\tlocal _, res = pcall(textutils.serialize, packet.message)\n\t\tpacket.packetStr = res:gsub(\"\\n%s*\", \"\")\n\t\ttable.insert(self.values, packet)\n\tend\n\tif #self.values > self.maxPacket then\n\t\tlocal t = { }\n\t\tfor i = 10, #self.values do\n\t\t\tt[i - 9] = self.values[i]\n\t\tend\n\t\tself:setValues(t)\n\tend\n\n\tself:update()\n\tself:draw()\n\tpage:sync()\nend\n\nfunction page:enable()\n\tmodemConfig.modems = {}\n\tUtil.each(_G.device, function(dev)\n\t\tif dev.type == \"modem\" then\n\t\t\tmodemConfig.modems[dev.side] = {\n\t\t\t\ttype = dev.isWireless() and 'Wireless' or 'Wired',\n\t\t\t\tside = dev.side,\n\t\t\t\topenChannels = { },\n\t\t\t\tdevice = dev,\n\t\t\t\tloaded = false\n\t\t\t}\n\t\tend\n\tend)\n\tmodemConfig.currentModem = device.wireless_modem and\n\t\tmodemConfig.modems[device.wireless_modem.side] or\n\t\tdevice.wired_modem and\n\t\tmodemConfig.modems[device.wired_modem.side] or\n\t\tnil\n\n\tmodemConfig.modemGrid.values = modemConfig.modems\n\tmodemConfig.modemGrid:update()\n\tmodemConfig.modemGrid:setSelected(modemConfig.currentModem)\n\n\tUI.Page.enable(self)\nend\n\n\nfunction page:eventHandler(event)\n\tif event.type == 'pause_click' then\n\t\tself.paused = not self.paused\n\t\tself.menuBar.pauseButton.text = self.paused and 'Resume' or 'Pause'\n\t\tself.notification:success(self.paused and 'Paused' or 'Resumed', 2)\n\t\tself.menuBar:draw()\n\n\telseif event.type == 'clear_click' then\n\t\tself.packetGrid:setValues({ })\n\t\tself.notification:success('Cleared', 2)\n\t\tself.packetGrid:draw()\n\n\telseif event.type == 'config_click' then\n\t\tself.configSlide:show()\n\t\tself:setFocus(filterConfig.filterEntry)\n\n\telseif event.type == 'config_close' then\n\t\tself.configSlide:hide()\n\t\tself:setFocus(self.packetGrid)\n\n\telseif event.type == 'grid_select' then\n\t\tself.packetSlide:show(event.selected)\n\n\telseif event.type == 'quit' then\n\t\tUI:quit()\n\n\telse return UI.Page.eventHandler(self, event)\n\tend\n\treturn true\nend\n\nEvent.on('modem_message', function(_, side, chan, reply, msg, dist)\n\tif modemConfig.currentModem.side == side then\n\t\tpage.packetGrid:addPacket({\n\t\t\tid = page.index,\n\t\t\tportid = chan,\n\t\t\treplyid = reply,\n\t\t\tmessage = msg,\n\t\t\tdistance = dist or -1,\n\t\t})\n\tend\nend)\n\nlocal args = Util.parse(...)\nif args[1] then\n\tlocal id = tonumber(args[1])\n\tif id then\n\t\tfilterConfig.filterGrid.values[id] = { id = id }\n\t\tfilterConfig.filterAllCheck:setValue(true)\n\t\tfilterConfig.filterGrid:update()\n\tend\nend\n\nUI:setPage(page)\nUI:start()\n", "sys/apps/mount.lua": "local args = { ... }\n\nlocal target = table.remove(args, 1)\ntarget = shell.resolve(target)\n\nfs.mount(target, table.unpack(args))\n", "sys/apps/fileui.lua": "local UI   = require('opus.ui')\nlocal Util = require('opus.util')\n\nlocal shell  = _ENV.shell\nlocal multishell = _ENV.multishell\n\n-- fileui [--path=path] [--exec=filename] [--title=title]\n\nlocal page = UI.Page {\n\tfileselect = UI.FileSelect { },\n\teventHandler = function(self, event)\n\t\tif event.type == 'select_file' then\n\t\t\tself.selected = event.file\n\t\t\tUI:quit()\n\n\t\telseif event.type == 'select_cancel' then\n\t\t\tUI:quit()\n\t\tend\n\n\t\treturn UI.Page.eventHandler(self, event)\n\tend,\n}\n\nlocal _, args = Util.parse(...)\n\nif args.title and multishell then\n\tmultishell.setTitle(multishell.getCurrent(), args.title)\nend\n\nUI:setPage(page, args.path)\nUI:start()\nUI.term:setCursorBlink(false)\n\nif args.exec and page.selected then\n\tshell.openForegroundTab(string.format('%s %s', args.exec, page.selected))\n\treturn\nend\n\nreturn page.selected\n", "sys/apps/package.lua": "local BulkGet  = require('opus.bulkget')\nlocal Config   = require('opus.config')\nlocal Git      = require('opus.git')\nlocal LZW      = require('opus.compress.lzw')\nlocal Packages = require('opus.packages')\nlocal Tar      = require('opus.compress.tar')\nlocal Util     = require('opus.util')\n\nlocal fs       = _G.fs\nlocal term     = _G.term\n\nlocal args     = { ... }\nlocal action   = table.remove(args, 1)\n\nlocal function makeSandbox()\n\tlocal sandbox = setmetatable(Util.shallowCopy(_ENV), { __index = _G })\n\t_G.requireInjector(sandbox)\n\treturn sandbox\nend\n\nlocal function Syntax(msg)\n\tprint('Syntax: package list | install [name] ... |  update [name] | updateall | uninstall [name]\\n')\n\terror(msg)\nend\n\nlocal function progress(max)\n\t-- modified from: https://pastebin.com/W5ZkVYSi (apemanzilla)\n\tlocal _, y = term.getCursorPos()\n\tlocal wide, _ = term.getSize()\n\tterm.setCursorPos(1, y)\n\tterm.write(\"[\")\n\tterm.setCursorPos(wide - 6, y)\n\tterm.write(\"]\")\n\tlocal done = 0\n\treturn function()\n\t\tdone = done + 1\n\t\tlocal value = done / max\n\t\tterm.setCursorPos(2,y)\n\t\tterm.write((\"=\"):rep(math.floor(value * (wide - 8))))\n\t\tlocal percent = math.floor(value * 100) .. \"%\"\n\t\tterm.setCursorPos(wide - percent:len(),y)\n\t\tterm.write(percent)\n\tend\nend\n\nlocal function runScript(script)\n\tif script then\n\t\tlocal s, m = pcall(function()\n\t\t\tlocal fn, m = load(script, 'script', nil, makeSandbox())\n\t\t\tif not fn then\n\t\t\t\terror(m)\n\t\t\tend\n\t\t\tfn()\n\t\tend)\n\t\tif not s and m then\n\t\t\t_G.printError(m)\n\t\tend\n\tend\nend\n\nlocal function install(name, isUpdate, ignoreDeps)\n\tlocal manifest = Packages:downloadManifest(name) or error('Invalid package')\n\n\tif not ignoreDeps then\n\t\tif manifest.required then\n\t\t\tfor _, v in pairs(manifest.required) do\n\t\t\t\tif isUpdate or not Packages:isInstalled(v) then\n\t\t\t\t\tinstall(v, isUpdate)\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\n\tprint(string.format('%s: %s',\n\t\tisUpdate and 'Updating' or 'Installing',\n\t\tname))\n\n\tlocal packageDir = fs.combine('packages', name)\n\n\tlocal list = Git.list(manifest.repository)\n\t-- clear out contents before install/update\n\t-- TODO: figure out whether to run\n\t-- install/uninstall for the package\n\tfs.delete(packageDir)\n\n\tlocal showProgress = progress(Util.size(list))\n\n\tlocal getList = { }\n\tfor path, entry in pairs(list) do\n\t\ttable.insert(getList, {\n\t\t\tpath = fs.combine(packageDir, path),\n\t\t\turl = entry.url\n\t\t})\n\tend\n\n\tBulkGet.download(getList, function(_, s, m)\n\t\tif not s then\n\t\t\terror(m)\n\t\tend\n\t\tshowProgress()\n\tend)\n\n\tif not isUpdate then\n\t\trunScript(manifest.install)\n\tend\n\n\tif Config.load('package').compression then\n\t\tlocal c = Tar.tar_string(packageDir)\n\t\tUtil.writeFile(packageDir  .. '.tar.lzw', LZW.compress(c), 'wb')\n\t\tfs.delete(packageDir)\n\tend\nend\n\nif action == 'list' then\n\tfor k in pairs(Packages:list()) do\n\t\tUtil.print('[%s] %s', Packages:isInstalled(k) and 'x' or ' ', k)\n\tend\n\treturn\nend\n\nif action == 'install' then\n\tlocal name = args[1] or Syntax('Invalid package')\n\tif Packages:isInstalled(name) then\n\t\terror('Package is already installed')\n\tend\n\tinstall(name)\n\tprint('installation complete\\n')\n\t_G.printError('Reboot is required')\n\treturn\nend\n\nif action == 'refresh' then\n\tprint('Downloading...')\n\tPackages:downloadList()\n\tprint('refresh complete')\n\treturn\nend\n\nif action == 'updateall' then\n\tfor name in pairs(Packages:installed()) do\n\t\tinstall(name, true, true)\n\tend\n\tprint('updateall complete')\n\treturn\nend\n\nif action == 'update' then\n\tlocal name = args[1] or Syntax('Invalid package')\n\tif not Packages:isInstalled(name) then\n\t\terror('Package is not installed')\n\tend\n\tinstall(name, true)\n\tprint('update complete')\n\treturn\nend\n\nif action == 'uninstall' then\n\tlocal name = args[1] or Syntax('Invalid package')\n\tif not Packages:isInstalled(name) then\n\t\terror('Package is not installed')\n\tend\n\n\tlocal manifest = Packages:getManifest(name)\n\trunScript(manifest.uninstall)\n\n\tlocal packageDir = fs.combine('packages', name)\n\tfs.delete(packageDir)\n\tfs.delete(packageDir  .. '.tar.lzw')\n\tprint('removed: ' .. packageDir)\n\treturn\nend\n\nSyntax('Invalid command')\n", "sys/apps/shell.lua": "local parentShell = _ENV.shell\n_ENV.shell = { }\n\nlocal trace = require('opus.trace')\nlocal Util  = require('opus.util')\n\nlocal fs       = _G.fs\nlocal settings = _G.settings\nlocal shell    = _ENV.shell\n\nlocal DIR = (parentShell and parentShell.dir()) or \"\"\nlocal PATH = (parentShell and parentShell.path()) or \".:/rom/programs\"\nlocal tAliases = (parentShell and parentShell.aliases()) or {}\nlocal tCompletionInfo = (parentShell and parentShell.getCompletionInfo()) or {}\n\nlocal bExit = false\nlocal tProgramStack = {}\n\nlocal function tokenise(...)\n\tlocal sLine = table.concat({ ... }, ' ')\n\tlocal tWords = { }\n\tlocal bQuoted = false\n\tfor match in string.gmatch(sLine .. \"\\\"\", \"(.-)\\\"\") do\n\t\tif bQuoted then\n\t\t\ttable.insert(tWords, match)\n\t\telse\n\t\t\tfor m in string.gmatch(match, \"[^ \\t]+\") do\n\t\t\t\ttable.insert(tWords, m)\n\t\t\tend\n\t\tend\n\t\tbQuoted = not bQuoted\n\tend\n\n\treturn tWords\nend\n\nlocal defaultHandlers = {\n\tfunction(env, command, args)\n\t\treturn command:match(\"^(https?:)\") and {\n\t\t\ttitle = fs.getName(command),\n\t\t\tpath  = command,\n\t\t\targs  = args,\n\t\t\tload  = Util.loadUrl,\n\t\t\tenv   = env,\n\t\t}\n\tend,\n\n\tfunction(env, command, args)\n\t\tcommand = env.shell.resolveProgram(command)\n\t\t\tor error('No such program')\n\n\t\t_G.requireInjector(env, fs.getDir(command))\n\t\treturn {\n\t\t\ttitle = fs.getName(command):match('([^%.]+)'),\n\t\t\tpath  = command,\n\t\t\targs  = args,\n\t\t\tload  = loadfile,\n\t\t\tenv   = env,\n\t\t}\n\tend,\n}\n\nfunction shell.getHandlers()\n\tif parentShell and parentShell.getHandlers then\n\t\treturn parentShell.getHandlers()\n\tend\n\treturn defaultHandlers\nend\n\nlocal handlers = shell.getHandlers()\n\nfunction shell.registerHandler(fn)\n\ttable.insert(handlers, 1, fn)\nend\n\nlocal function handleCommand(env, command, args)\n\tfor _,v in pairs(handlers) do\n\t\tlocal pi = v(env, command, args)\n\t\tif pi then\n\t\t\treturn pi\n\t\tend\n\tend\nend\n\nlocal function run(...)\n\tlocal args = tokenise(...)\n\tif #args == 0 then\n\t\terror('No such program')\n\tend\n\n\tlocal pi = handleCommand(shell.makeEnv(_ENV), table.remove(args, 1), args)\n\n\tlocal O_v_O, err = pi.load(pi.path, pi.env)\n\tif not O_v_O then\n\t\terror(err, -1)\n\tend\n\n\tif _ENV.multishell then\n\t\t_ENV.multishell.setTitle(_ENV.multishell.getCurrent(), pi.title)\n\tend\n\n\ttProgramStack[#tProgramStack + 1] = pi\n\n\tpi.env[ \"arg\" ] = { [0] = pi.path, table.unpack(pi.args) }\n\tlocal r = { O_v_O(table.unpack(pi.args)) }\n\n\ttProgramStack[#tProgramStack] = nil\n\n\treturn table.unpack(r)\nend\n\n-- Install shell API\nfunction shell.run(...)\n\tlocal oldTitle\n\n\tif _ENV.multishell then\n\t\toldTitle = _ENV.multishell.getTitle(_ENV.multishell.getCurrent())\n\tend\n\n\tlocal r = { trace(run, ...) }\n\n\tif _ENV.multishell then\n\t\t_ENV.multishell.setTitle(_ENV.multishell.getCurrent(), oldTitle or 'shell')\n\tend\n\n\treturn table.unpack(r)\nend\n\nfunction shell.exit()\n\tbExit = true\nend\n\nfunction shell.dir() return DIR end\nfunction shell.setDir(d)\n\td = fs.combine(d, '')\n\tif not fs.isDir(d) then\n\t\terror(\"Not a directory\", 2)\n\tend\n\tDIR = d\nend\n\nfunction shell.path() return PATH end\nfunction shell.setPath(p) PATH = p end\n\nfunction shell.resolve( _sPath )\n\tlocal sStartChar = string.sub( _sPath, 1, 1 )\n\tif sStartChar == \"/\" or sStartChar == \"\\\\\" then\n\t\treturn fs.combine( \"\", _sPath )\n\telse\n\t\treturn fs.combine(DIR, _sPath )\n\tend\nend\n\nfunction shell.resolveProgram(_sCommand)\n\tif tAliases[_sCommand] ~= nil then\n\t\t_sCommand = tAliases[_sCommand]\n\tend\n\n\tlocal function check(f)\n\t\treturn fs.exists(f) and not fs.isDir(f) and f\n\tend\n\n\tlocal function inPath()\n\t\t-- Otherwise, look on the path variable\n\t\tfor sPath in string.gmatch(PATH or '', \"[^:]+\") do\n\t\t\tsPath = fs.combine(sPath, _sCommand )\n\t\t\tif check(sPath) then\n\t\t\t\treturn sPath\n\t\t\tend\n\t\t\tif check(sPath .. '.lua') then\n\t\t\t\treturn sPath .. '.lua'\n\t\t\tend\n\t\tend\n\tend\n\n\tif not _sCommand:find('/') then\n\t\treturn inPath()\n\tend\n\n\t-- so... even if you are in the rom directory and you run:\n\t-- 'packages/common/edit.lua', allow this even though it\n\t-- does not use a leading slash. Ideally, fs.combine would\n\t-- provide the leading slash... but it does not.\n\treturn check(shell.resolve(_sCommand))\n\t\tor check(shell.resolve(_sCommand) .. '.lua')\n\t\tor check(_sCommand)\n\t\tor check(_sCommand .. '.lua')\nend\n\nfunction shell.programs(_bIncludeHidden)\n\tlocal tItems = { }\n\n\t-- Add programs from the path\n\tfor sPath in string.gmatch(PATH, \"[^:]+\") do\n\t\tsPath = shell.resolve(sPath)\n\t\tif fs.isDir( sPath ) then\n\t\t\tlocal tList = fs.list( sPath )\n\t\t\tfor _,sFile in pairs( tList ) do\n\t\t\t\tif not fs.isDir( fs.combine( sPath, sFile ) ) and\n\t\t\t\t\t(_bIncludeHidden or string.sub( sFile, 1, 1 ) ~= \".\") then\n\t\t\t\t\ttItems[ sFile ] = true\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\n\t-- Sort and return\n\tlocal tItemList = { }\n\tfor sItem in pairs(tItems) do\n\t\ttable.insert(tItemList, sItem)\n\tend\n\ttable.sort(tItemList)\n\treturn tItemList\nend\n\nfunction shell.completeProgram(sLine)\n\tif #sLine > 0 and string.sub(sLine, 1, 1) == '/' then\n\t\t-- Add programs from the root\n\t\treturn fs.complete(sLine, '', true, false)\n\tend\n\n\tlocal tResults = { }\n\tlocal tSeen = { }\n\n\t-- Add aliases\n\tfor sAlias in pairs( tAliases ) do\n\t\tif #sAlias > #sLine and string.sub(sAlias, 1, #sLine) == sLine then\n\t\t\tlocal sResult = string.sub(sAlias, #sLine + 1)\n\t\t\tif not tSeen[sResult] then\n\t\t\t\ttable.insert(tResults, sResult .. ' ')\n\t\t\t\ttSeen[sResult] = true\n\t\t\tend\n\t\tend\n\tend\n\n\t-- Add programs from the path\n\tlocal tPrograms = shell.programs()\n\tfor n=1,#tPrograms do\n\t\tlocal sProgram = tPrograms[n]\n\t\tif #sProgram >= #sLine and string.sub(sProgram, 1, #sLine) == sLine then\n\t\t\tlocal sResult = string.sub(sProgram, #sLine + 1)\n\t\t\tif not tSeen[sResult] then\n\t\t\t\ttable.insert(tResults, sResult .. ' ')\n\t\t\t\ttSeen[sResult] = true\n\t\t\tend\n\t\tend\n\tend\n\n\t-- Sort and return\n\ttable.sort(tResults)\n\treturn tResults\nend\n\nfunction shell.complete(sLine)\n\tlocal tWords = tokenise(sLine)\n\tlocal nIndex = #tWords\n\tif string.sub(sLine, #sLine, #sLine) == ' ' and #Util.trim(sLine) > 0 then\n\t\tnIndex = nIndex + 1\n\tend\n\n\tif nIndex == 0 then\n\t\treturn fs.complete('', shell.dir(), true, false)\n\n\telseif nIndex == 1 then\n\t\tlocal results = shell.completeProgram(tWords[1] or '')\n\t\tfor _, v in pairs(fs.complete(table.concat(tWords, ' '), shell.dir(), true, false)) do\n\t\t\ttable.insert(results, v)\n\t\tend\n\t\treturn results\n\n\telse\n\t\tlocal sPath = shell.resolveProgram(tWords[1])\n\t\tlocal sPart = tWords[nIndex] or ''\n\t\tlocal tPreviousParts = tWords\n\t\ttPreviousParts[nIndex] = nil\n\t\tlocal results\n\t\tlocal tInfo = tCompletionInfo[sPath]\n\t\tif tInfo then\n\t\t\tresults = tInfo.fnComplete(shell, nIndex - 1, sPart, tPreviousParts)\n\t\tend\n\t\treturn results and #results > 0 and results\n\t\t\tor fs.complete(sPart, shell.dir(), true, false)\n\tend\nend\n\nfunction shell.setCompletionFunction(sProgram, fnComplete)\n\ttCompletionInfo[sProgram] = { fnComplete = fnComplete }\nend\n\nfunction shell.getCompletionInfo()\n\treturn tCompletionInfo\nend\n\nfunction shell.getRunningProgram()\n\treturn tProgramStack[#tProgramStack] and tProgramStack[#tProgramStack].path\nend\n\nfunction shell.getRunningInfo()\n\treturn tProgramStack[#tProgramStack]\nend\n\n-- convenience function for making a runnable env\nfunction shell.makeEnv(env, dir)\n\tenv = setmetatable(Util.shallowCopy(env), { __index = _G })\n\t_G.requireInjector(env, dir)\n\treturn env\nend\n\nfunction shell.setAlias(_sCommand, _sProgram)\n\ttAliases[_sCommand] = _sProgram\nend\n\nfunction shell.clearAlias(_sCommand)\n\ttAliases[_sCommand] = nil\nend\n\nfunction shell.aliases()\n\tlocal tCopy = {}\n\tfor sAlias, sCommand in pairs(tAliases) do\n\t\ttCopy[sAlias] = sCommand\n\tend\n\treturn tCopy\nend\n\nfunction shell.newTab(tabInfo, ...)\n\tlocal args = tokenise(...)\n\tlocal path = table.remove(args, 1)\n\tpath = shell.resolveProgram(path)\n\n\tif path then\n\t\ttabInfo.path = path\n\t\ttabInfo.args = args\n\t\ttabInfo.title = fs.getName(path):match('([^%.]+)')\n\n\t\tif path ~= 'sys/apps/shell.lua' then\n\t\t\ttable.insert(tabInfo.args, 1, tabInfo.path)\n\t\t\ttabInfo.path = 'sys/apps/shell.lua'\n\t\tend\n\t\treturn _ENV.multishell.openTab(_ENV, tabInfo)\n\tend\n\treturn nil, 'No such program'\nend\n\nif not _ENV.multishell then\n\tfunction shell.newTab()\n\t\terror('Multishell is not available')\n\tend\nend\n\nfunction shell.openTab(...)\n\treturn shell.newTab({ }, ...)\nend\n\nfunction shell.openForegroundTab( ... )\n\treturn shell.newTab({ focused = true }, ...)\nend\n\nfunction shell.openHiddenTab( ... )\n\treturn shell.newTab({ hidden = true }, ...)\nend\n\nfunction shell.switchTab(tabId)\n\t_ENV.multishell.setFocus(tabId)\nend\n\nlocal tArgs = { ... }\nif #tArgs > 0 then\n\treturn run(...)\nend\n\nlocal Config   = require('opus.config')\nlocal Entry    = require('opus.entry')\nlocal History  = require('opus.history')\nlocal Input    = require('opus.input')\nlocal Sound    = require('opus.sound')\nlocal Terminal = require('opus.terminal')\n\nlocal colors    = _G.colors\nlocal os        = _G.os\nlocal term      = _G.term\nlocal textutils = _G.textutils\n\nlocal oldTerm\nlocal terminal  = term.current()\nlocal _len      = string.len\nlocal _rep      = string.rep\nlocal _sub      = string.sub\n\nlocal config = {\n\tcolor = {\n\t\ttextColor = colors.white,\n\t\tcommandTextColor = colors.yellow,\n\t\tdirectoryTextColor  = colors.orange,\n\t\tpromptTextColor = colors.blue,\n\t\tdirectoryColor = colors.green,\n\t\tfileColor = colors.white,\n\t\tbackgroundColor = colors.black,\n\t},\n\tdisplayDirectory = true,\n}\n\nConfig.load('shellprompt', config)\n\nlocal _colors = config.color\n-- temp\nif not _colors.backgroundColor then\n  _colors.backgroundColor = colors.black\n  _colors.fileColor = colors.white\nend\n\nif not terminal.scrollUp then\n\tterminal = Terminal.window(term.current())\n\tterminal.setMaxScroll(200)\n\toldTerm = term.redirect(terminal)\n\tterm.setBackgroundColor(_colors.backgroundColor)\n\tterm.clear()\nend\n\nlocal palette = terminal.canvas.palette\n\nlocal function autocomplete(line)\n\tlocal words = { }\n\tfor word in line:gmatch(\"%S+\") do\n\t\ttable.insert(words, word)\n\tend\n\tif line:match(' $') then\n\t\ttable.insert(words, '')\n\tend\n\tif #words == 0 then\n\t\twords = { '' }\n\tend\n\n\tlocal results = shell.complete(line) or { }\n\n\tUtil.filterInplace(results, function(f)\n\t\treturn not Util.key(results, f .. '/')\n\tend)\n\tlocal w = words[#words] or ''\n\tfor k,arg in pairs(results) do\n\t\tresults[k] = w .. arg\n\tend\n\n\tif #results == 1 then\n\t\twords[#words] = results[1]\n\t\treturn table.concat(words, ' ')\n\n\telseif #results > 1 then\n\t\tlocal function someComplete()\n\t\t\t-- ugly (complete as much as possible)\n\t\t\tlocal word = words[#words] or ''\n\t\t\tlocal i = #word + 1\n\t\t\twhile true do\n\t\t\t\tlocal ch\n\t\t\t\tfor _,f in ipairs(results) do\n\t\t\t\t\tif #f < i then\n\t\t\t\t\t\twords[#words] = _sub(f, 1, i - 1)\n\t\t\t\t\t\treturn table.concat(words, ' ')\n\t\t\t\t\tend\n\t\t\t\t\tif not ch then\n\t\t\t\t\t\tch = _sub(f, i, i)\n\t\t\t\t\telseif _sub(f, i, i) ~= ch then\n\t\t\t\t\t\tif i == #word + 1 then\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\tend\n\t\t\t\t\t\twords[#words] = _sub(f, 1, i - 1)\n\t\t\t\t\t\treturn table.concat(words, ' ')\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\ti = i + 1\n\t\t\tend\n\t\tend\n\n\t\tlocal t = someComplete()\n\t\tif t then\n\t\t\treturn t\n\t\tend\n\n\t\tprint()\n\n\t\tlocal word = words[#words] or ''\n\t\tlocal prefix = word:match(\"(.*/)\") or ''\n\t\tif #prefix > 0 then\n\t\t\tfor _,f in ipairs(results) do\n\t\t\t\tif f:match(\"^\" .. prefix) ~= prefix then\n\t\t\t\t\tprefix = ''\n\t\t\t\t\tbreak\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\n\t\tlocal tDirs, tFiles = { }, { }\n\t\tfor _,f in ipairs(results) do\n\t\t\tif fs.isDir(shell.resolve(f)) then\n\t\t\t\tf = f:gsub(prefix, '', 1)\n\t\t\t\ttable.insert(tDirs, f)\n\t\t\telse\n\t\t\t\tf = f:gsub(prefix, '', 1)\n\t\t\t\ttable.insert(tFiles, f)\n\t\t\tend\n\t\tend\n\t\ttable.sort(tDirs)\n\t\ttable.sort(tFiles)\n\n\t\tif #tDirs > 0 and #tDirs < #tFiles then\n\t\t\tlocal tw = term.getSize()\n\t\t\tlocal nMaxLen = tw / 8\n\t\t\tfor _,sItem in pairs(results) do\n\t\t\t\tnMaxLen = math.max(_len(sItem) + 1, nMaxLen)\n\t\t\tend\n\t\t\tlocal nCols = math.floor(tw / nMaxLen)\n\t\t\tif #tDirs < nCols then\n\t\t\t\tfor _ = #tDirs + 1, nCols do\n\t\t\t\t\ttable.insert(tDirs, '')\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\n\t\tif #tDirs > 0 then\n\t\t\ttextutils.tabulate(_colors.directoryColor, tDirs, _colors.fileColor, tFiles)\n\t\telse\n\t\t\ttextutils.tabulate(_colors.fileColor, tFiles)\n\t\tend\n\n\t\tterm.setTextColour(_colors.promptTextColor)\n\t\tterm.write(\"$ \" )\n\n\t\tterm.setTextColour(_colors.commandTextColor)\n\t\treturn line\n\tend\nend\n\nlocal function shellRead(history)\n\tlocal lastLen = 0\n\tlocal entry = Entry({\n\t\twidth = term.getSize() - 3,\n\t\toffset = 3,\n\t})\n\n\thistory:reset()\n\tterm.setCursorBlink(true)\n\n\tlocal function updateCursor()\n\t\tterm.setCursorPos(3 + entry.pos - entry.scroll, select(2, term.getCursorPos()))\n\tend\n\n\tlocal function redraw()\n\t\tif terminal.scrollBottom then\n\t\t\tterminal.scrollBottom()\n\t\tend\n\t\tlocal _,cy = term.getCursorPos()\n\t\tterm.setCursorPos(3, cy)\n\t\tentry.value = entry.value or ''\n\t\tlocal filler = #entry.value < lastLen\n\t\t\tand _rep(' ', lastLen - #entry.value)\n\t\t\tor ''\n\t\tlocal str = _sub(entry.value, entry.scroll + 1, entry.width + entry.scroll) .. filler\n\t\tlocal fg = _rep(palette[_colors.commandTextColor], #str)\n\t\tlocal bg = _rep(palette[_colors.backgroundColor], #str)\n\t\tif entry.mark.active then\n\t\t\tbg = _rep('f', entry.mark.x) ..\n\t\t\t\t_rep('7', entry.mark.ex - entry.mark.x) ..\n\t\t\t\t_rep('f', #entry.value - entry.mark.ex + #filler + 1)\n\t\t\tbg = _sub(bg, entry.scroll + 1, entry.scroll + #str)\n\t\tend\n\t\tterm.blit(str, fg, bg)\n\t\tupdateCursor()\n\t\tlastLen = #entry.value\n\tend\n\n\twhile true do\n\t\tlocal event, p1, p2, p3 = os.pullEventRaw()\n\n\t\tlocal ie = Input:translate(event, p1, p2, p3)\n\t\tif ie then\n\t\t\tif ie.code == 'scroll_up' and terminal.scrollUp then\n\t\t\t\tterminal.scrollUp()\n\n\t\t\telseif ie.code == 'scroll_down' and terminal.scrollDown then\n\t\t\t\tterminal.scrollDown()\n\n\t\t\telseif ie.code == 'terminate' then\n\t\t\t\tbExit = true\n\t\t\t\tbreak\n\n\t\t\telseif ie.code == 'enter' then\n\t\t\t\tbreak\n\n\t\t\telseif ie.code == 'up'   or ie.code == 'control-p' or\n\t\t\t\t\t\t ie.code == 'down' or ie.code == 'control-n' then\n\t\t\t\tentry:reset()\n\t\t\t\tif ie.code == 'up' or ie.code == 'control-p' then\n\t\t\t\t\tentry.value = history:back() or ''\n\t\t\t\telse\n\t\t\t\t\tentry.value = history:forward() or ''\n\t\t\t\tend\n\t\t\t\tentry.pos = #entry.value\n\t\t\t\tentry:updateScroll()\n\t\t\t\tredraw()\n\n\t\t\telseif ie.code == 'tab' then\n\t\t\t\tentry.value = entry.value or ''\n\t\t\t\tif entry.pos == #entry.value then\n\t\t\t\t\tlocal cline = autocomplete(entry.value)\n\t\t\t\t\tif cline then\n\t\t\t\t\t\tentry.value = cline\n\t\t\t\t\t\tentry.pos = #entry.value\n\t\t\t\t\t\tentry:unmark()\n\t\t\t\t\t\tentry:updateScroll()\n\t\t\t\t\t\tredraw()\n\t\t\t\t\telse\n\t\t\t\t\t\tSound.play('entity.villager.no')\n\t\t\t\t\tend\n\t\t\t\tend\n\n\t\t\telse\n\t\t\t\tentry:process(ie)\n\t\t\t\tentry.value = entry.value or ''\n\t\t\t\tif entry.textChanged then\n\t\t\t\t\tredraw()\n\t\t\t\telseif entry.posChanged then\n\t\t\t\t\tupdateCursor()\n\t\t\t\tend\n\t\t\tend\n\n\t\telseif event == \"term_resize\" then\n\t\t\tterminal.reposition(1, 1, oldTerm.getSize())\n\t\t\tentry.width = term.getSize() - 3\n\t\t\tentry:updateScroll()\n\t\t\tredraw()\n\t\tend\n\tend\n\n\tprint()\n\tterm.setCursorBlink(false)\n\treturn entry.value or ''\nend\n\nlocal history = History.load('usr/.shell_history', 100)\n\nterm.setBackgroundColor(_colors.backgroundColor)\n\nif settings.get(\"motd.enable\") then\n\tshell.run(\"motd\")\nend\n\nwhile not bExit do\n\tif config.displayDirectory then\n\t\tterm.setTextColour(_colors.directoryTextColor)\n\t\tprint('==' .. os.getComputerLabel() .. ':/' .. DIR)\n\tend\n\tterm.setTextColour(_colors.promptTextColor)\n\tterm.write(\"$ \" )\n\tterm.setTextColour(_colors.commandTextColor)\n\tlocal sLine = shellRead(history)\n\tif bExit then -- terminated\n\t\tbreak\n\tend\n\tsLine = Util.trim(sLine)\n\tif #sLine > 0 and sLine ~= 'exit' then\n\t\thistory:add(sLine)\n\tend\n\tterm.setTextColour(_colors.textColor)\n\tif #sLine > 0 then\n\t\tlocal result, err = shell.run(sLine)\n\t\tlocal cx = term.getCursorPos()\n\t\tif cx ~= 1 then\n\t\t\tprint()\n\t\tend\n\t\tterm.setBackgroundColor(_colors.backgroundColor)\n\t\tif not result and err then\n\t\t\t_G.printError(err)\n\t\tend\n\tend\nend\n\nif oldTerm then\n\tterm.redirect(oldTerm)\nend\n", "sys/apps/Files.lua": "local Config = require('opus.config')\nlocal Event  = require('opus.event')\nlocal pastebin = require('opus.http.pastebin')\nlocal UI     = require('opus.ui')\nlocal Util   = require('opus.util')\n\nlocal colors     = _G.colors\nlocal fs         = _G.fs\nlocal multishell = _ENV.multishell\nlocal os         = _G.os\nlocal shell      = _ENV.shell\n\nlocal FILE    = 1\n\nUI:configure('Files', ...)\n\nlocal config = Config.load('Files', {\n\tshowHidden = false,\n\tshowDirSizes = false,\n})\nconfig.associations = config.associations or {\n\tnft = 'pain',\n\ttxt = 'edit',\n}\n\nlocal copied = { }\nlocal marked = { }\nlocal directories = { }\nlocal cutMode = false\n\nlocal function formatSize(size)\n\tif size >= 1000000 then\n\t\treturn string.format('%dM', math.floor(size/1000000, 2))\n\telseif size >= 1000 then\n\t\treturn string.format('%dK', math.floor(size/1000, 2))\n\tend\n\treturn size\nend\n\nlocal Browser = UI.Page {\n\tmenuBar = UI.MenuBar {\n\t\tbuttons = {\n\t\t\t{ text = '^-',   event = 'updir' },\n\t\t\t{ text = 'File', dropdown = {\n\t\t\t\t\t{ text = 'Run',               event = 'run',      flags = FILE },\n\t\t\t\t\t{ text = 'Edit         e',    event = 'edit',     flags = FILE },\n\t\t\t\t\t{ text = 'Cloud edit   c',    event = 'cedit',    flags = FILE },\n\t\t\t\t\t{ text = 'Pastebin put p',    event = 'pastebin', flags = FILE },\n\t\t\t\t\t{ text = 'Shell        s',    event = 'shell'  },\n\t\t\t\t\t{ spacer = true },\n\t\t\t\t\t{ text = 'Quit        ^q',    event = 'quit'   },\n\t\t\t} },\n\t\t\t{ text = 'Edit', dropdown = {\n\t\t\t\t\t{ text = 'Cut          ^x', event = 'cut'    },\n\t\t\t\t\t{ text = 'Copy         ^c', event = 'copy'   },\n\t\t\t\t\t{ text = 'Copy path      ', event = 'copy_path' },\n\t\t\t\t\t{ text = 'Paste        ^v', event = 'paste'  },\n\t\t\t\t\t{ spacer = true },\n\t\t\t\t\t{ text = 'Mark          m', event = 'mark'   },\n\t\t\t\t\t{ text = 'Unmark all    u', event = 'unmark' },\n\t\t\t\t\t{ spacer = true },\n\t\t\t\t\t{ text = 'Delete      del', event = 'delete' },\n\t\t\t} },\n\t\t\t{ text = 'View', dropdown = {\n\t\t\t\t\t{ text = 'Refresh     r',   event = 'refresh'       },\n\t\t\t\t\t{ text = 'Hidden     ^h',   event = 'toggle_hidden' },\n\t\t\t\t\t{ text = 'Dir Size   ^s',   event = 'toggle_dirSize' },\n\t\t\t} },\n\t\t\t{ text = '\\187',\n\t\t\t\tx = -3,\n\t\t\t\tdropdown = {\n\t\t\t\t\t{ text = 'Associations', event = 'associate' },\n\t\t\t} },\n\t\t},\n\t},\n\tgrid = UI.ScrollingGrid {\n\t\tcolumns = {\n\t\t\t{ heading = 'Name', key = 'name'             },\n\t\t\t{                   key = 'flags', width = 3, textColor = 'lightGray' },\n\t\t\t{ heading = 'Size', key = 'fsize', width = 5, textColor = 'yellow' },\n\t\t},\n\t\tsortColumn = 'name',\n\t\ty = 2, ey = -2,\n\t\tsortCompare = function(self, a, b)\n\t\t\tif self.sortColumn == 'fsize' then\n\t\t\t\treturn a.size < b.size\n\t\t\telseif self.sortColumn == 'flags' then\n\t\t\t\treturn a.flags < b.flags\n\t\t\tend\n\t\t\tif a.isDir == b.isDir then\n\t\t\t\treturn a.name:lower() < b.name:lower()\n\t\t\tend\n\t\t\treturn a.isDir\n\t\tend,\n\t\tgetRowTextColor = function(_, file)\n\t\t\tif file.marked then\n\t\t\t\treturn colors.green\n\t\t\tend\n\t\t\tif file.isDir then\n\t\t\t\treturn colors.cyan\n\t\t\tend\n\t\t\tif file.isReadOnly then\n\t\t\t\treturn colors.pink\n\t\t\tend\n\t\t\treturn colors.white\n\t\tend,\n\t\teventHandler = function(self, event)\n\t\t\tif event.type == 'copy' then -- let copy be handled by parent\n\t\t\t\treturn false\n\t\t\tend\n\t\t\treturn UI.ScrollingGrid.eventHandler(self, event)\n\t\tend\n\t},\n\tstatusBar = UI.StatusBar {\n\t\tcolumns = {\n\t\t\t{ key = 'status'               },\n\t\t\t{ key = 'totalSize', width = 6 },\n\t\t},\n\t\tdraw = function(self)\n\t\t\tif self.parent.dir then\n\t\t\t\tlocal info = '#:' .. Util.size(self.parent.dir.files)\n\t\t\t\tlocal numMarked = Util.size(marked)\n\t\t\t\tif numMarked > 0 then\n\t\t\t\t\tinfo = info .. ' M:' .. numMarked\n\t\t\t\tend\n\t\t\t\tself:setValue('info', info)\n\t\t\t\tself:setValue('totalSize', formatSize(self.parent.dir.totalSize))\n\t\t\t\tUI.StatusBar.draw(self)\n\t\t\tend\n\t\tend,\n\t},\n\tquestion = UI.Question {\n\t\ty = -2, x = -19,\n\t\tlabel = 'Delete',\n\t},\n\tnotification = UI.Notification { },\n\tassociations = UI.SlideOut {\n\t\tmenuBar = UI.MenuBar {\n\t\t\tbuttons = {\n\t\t\t\t{ text = 'Save',    event = 'save'    },\n\t\t\t\t{ text = 'Cancel',  event = 'cancel'  },\n\t\t\t},\n\t\t},\n\t\tgrid = UI.ScrollingGrid {\n\t\t\tx = 2, ex = -6, y = 3, ey = -8,\n\t\t\tcolumns = {\n\t\t\t\t{ heading = 'Extension', key = 'name'  },\n\t\t\t\t{ heading = 'Program',   key = 'value' },\n\t\t\t},\n\t\t\tautospace = true,\n\t\t\tsortColumn = 'name',\n\t\t\taccelerators = {\n\t\t\t\tdelete = 'remove_entry',\n\t\t\t},\n\t\t},\n\t\tremove = UI.Button {\n\t\t\tx = -4, y = 6,\n\t\t\ttext = '-', event = 'remove_entry', help = 'Remove',\n\t\t},\n\t\t[1] = UI.Window {\n\t\t\tx = 2, y = -6, ex = -6, ey = -3,\n\t\t},\n\t\tform = UI.Form {\n\t\t\tx = 3, y = -5, ex = -7, ey = -3,\n\t\t\tmargin = 1,\n\t\t\tmanualControls = true,\n\t\t\t[1] = UI.TextEntry {\n\t\t\t\twidth = 20,\n\t\t\t\tformLabel = 'Extension', formKey = 'name',\n\t\t\t\tshadowText = 'extension',\n\t\t\t\trequired = true,\n\t\t\t\tlimit = 64,\n\t\t\t},\n\t\t\t[2] = UI.TextEntry {\n\t\t\t\twidth = 20,\n\t\t\t\tformLabel = 'Program', formKey = 'value',\n\t\t\t\tshadowText = 'program',\n\t\t\t\trequired = true,\n\t\t\t},\n\t\t\tadd = UI.Button {\n\t\t\t\tx = -11, y = 1,\n\t\t\t\ttext = 'Add', event = 'add_association',\n\t\t\t},\n\t\t},\n\t\tstatusBar = UI.StatusBar { },\n\t},\n\taccelerators = {\n\t\t[ 'control-q' ] = 'quit',\n\t\tc               = 'cedit',\n\t\te               = 'edit',\n\t\ts               = 'shell',\n\t\tp               = 'pastebin',\n\t\tr               = 'refresh',\n\t\t[ ' ' ]         = 'mark',\n\t\tm               = 'mark',\n\t\tbackspace       = 'updir',\n\t\tu               = 'unmark',\n\t\td               = 'delete',\n\t\tdelete          = 'delete',\n\t\t[ 'control-h' ] = 'toggle_hidden',\n\t\t[ 'control-s' ] = 'toggle_dirSize',\n\t\t[ 'control-x' ] = 'cut',\n\t\t[ 'control-c' ] = 'copy',\n\t\tpaste           = 'paste',\n\t},\n}\n\nfunction Browser:enable()\n\tUI.Page.enable(self)\n\tself:setFocus(self.grid)\nend\n\nfunction Browser.menuBar.getActive(_, menuItem)\n\tlocal file = Browser.grid:getSelected()\n\tif menuItem.flags == FILE then\n\t\treturn file and not file.isDir\n\tend\n\treturn true\nend\n\nfunction Browser:setStatus(status, ...)\n\tself.notification:info(string.format(status, ...))\nend\n\nfunction Browser.unmarkAll()\n\tfor _,m in pairs(marked) do\n\t\tm.marked = false\n\tend\n\tUtil.clear(marked)\nend\n\nfunction Browser:getDirectory(directory)\n\tlocal s, dir = pcall(function()\n\n\t\tlocal dir = directories[directory]\n\t\tif not dir then\n\t\t\tdir = {\n\t\t\t\tname = directory,\n\t\t\t\tsize = 0,\n\t\t\t\tfiles = { },\n\t\t\t\ttotalSize = 0,\n\t\t\t\tindex = 1\n\t\t\t}\n\t\t\tdirectories[directory] = dir\n\t\tend\n\n\t\tself:updateDirectory(dir)\n\n\t\treturn dir\n\tend)\n\n\treturn s, dir\nend\n\nfunction Browser:updateDirectory(dir)\n\tdir.size = 0\n\tdir.totalSize = 0\n\tUtil.clear(dir.files)\n\n\tlocal files = fs.listEx(dir.name)\n\tif files then\n\t\tdir.size = #files\n\t\tfor _, file in pairs(files) do\n\t\t\tfile.fullName = fs.combine(dir.name, file.name)\n\t\t\tfile.flags = file.fstype or ' '\n\t\t\tif not file.isDir then\n\t\t\t\tdir.totalSize = dir.totalSize + file.size\n\t\t\t\tfile.fsize = formatSize(file.size)\n\t\t\t\tfile.flags = file.flags .. ' '\n\t\t\telse\n\t\t\t\tif config.showDirSizes then\n\t\t\t\t\tfile.size = fs.getSize(file.fullName, true)\n\n\t\t\t\t\tdir.totalSize = dir.totalSize + file.size\n\t\t\t\t\tfile.fsize = formatSize(file.size)\n\t\t\t\tend\n\t\t\t\tfile.flags = file.flags .. 'D'\n\t\t\tend\n\t\t\tfile.flags = file.flags .. (file.isReadOnly and 'R' or ' ')\n\t\t\tif config.showHidden or file.name:sub(1, 1) ~= '.' then\n\t\t\t\tdir.files[file.fullName] = file\n\t\t\tend\n\t\tend\n\tend\n--  self.grid:update()\n--  self.grid:setIndex(dir.index)\n\tself.grid:setValues(dir.files)\nend\n\nfunction Browser:setDir(dirName, noStatus)\n\tself:unmarkAll()\n\n\tif self.dir then\n\t\tself.dir.index = self.grid:getIndex()\n\tend\n\tlocal DIR = fs.combine('', dirName)\n\tshell.setDir(DIR)\n\tlocal s, dir = self:getDirectory(DIR)\n\tif s then\n\t\tself.dir = dir\n\telseif noStatus then\n\t\terror(dir)\n\telse\n\t\tself:setStatus(dir)\n\t\tself:setDir('', true)\n\t\treturn\n\tend\n\n\tif not noStatus then\n\t\tself.statusBar:setValue('status', '/' .. self.dir.name)\n\t\tself.statusBar:draw()\n\tend\n\tself.grid:setIndex(self.dir.index)\nend\n\nfunction Browser:run(...)\n\tif multishell then\n\t\tlocal tabId = shell.openTab(...)\n\t\tmultishell.setFocus(tabId)\n\telse\n\t\tshell.run(...)\n\t\tEvent.terminate = false\n\t\tself:draw()\n\tend\nend\n\nfunction Browser:hasMarked()\n\tif Util.size(marked) == 0 then\n\t\tlocal file = self.grid:getSelected()\n\t\tif file then\n\t\t\tfile.marked = true\n\t\t\tmarked[file.fullName] = file\n\t\t\tself.grid:draw()\n\t\tend\n\tend\n\treturn Util.size(marked) > 0\nend\n\nfunction Browser:eventHandler(event)\n\tlocal file = self.grid:getSelected()\n\n\tif event.type == 'quit' then\n\t\tUI:quit()\n\n\telseif event.type == 'edit' and file then\n\t\tself:run('edit', file.name)\n\n\telseif event.type == 'cedit' and file then\n\t\tself:run('cedit', file.name)\n\t\tself:setStatus('Started cloud edit')\n\n\telseif event.type == 'shell' then\n\t\tself:run('shell')\n\n\telseif event.type == 'refresh' then\n\t\tself:updateDirectory(self.dir)\n\t\tself.grid:draw()\n\t\tself:setStatus('Refreshed')\n\n\telseif event.type == 'associate' then\n\t\tself.associations:show()\n\n\telseif event.type == 'pastebin' then\n\t\tif file and not file.isDir then\n\t\t\tlocal s, m = pastebin.put(file.fullName)\n\t\t\tif s then\n\t\t\t\tos.queueEvent('clipboard_copy', s)\n\t\t\t\tself.notification:success(string.format('Uploaded as %s', s), 0)\n\t\t\telse\n\t\t\t\tself.notification:error(m)\n\t\t\tend\n\t\tend\n\n\telseif event.type == 'toggle_hidden' then\n\t\tconfig.showHidden = not config.showHidden\n\t\tConfig.update('Files', config)\n\n\t\tself:updateDirectory(self.dir)\n\t\tself.grid:draw()\n\t\tif not config.showHidden then\n\t\t\tself:setStatus('Hiding hidden')\n\t\telse\n\t\t\tself:setStatus('Displaying hidden')\n\t\tend\n\n\telseif event.type == 'toggle_dirSize' then\n\t\tconfig.showDirSizes = not config.showDirSizes\n\t\tConfig.update('Files', config)\n\n\t\tself:updateDirectory(self.dir)\n\t\tself.grid:draw()\n\t\tif config.showDirSizes then\n\t\t\tself:setStatus('Displaying dir sizes')\n\t\tend\n\n\telseif event.type == 'mark' and file then\n\t\tfile.marked = not file.marked\n\t\tif file.marked then\n\t\t\tmarked[file.fullName] = file\n\t\telse\n\t\t\tmarked[file.fullName] = nil\n\t\tend\n\t\tself.grid:draw()\n\t\tself.statusBar:draw()\n\n\telseif event.type == 'unmark' then\n\t\tself:unmarkAll()\n\t\tself.grid:draw()\n\t\tself:setStatus('Marked files cleared')\n\n\telseif event.type == 'grid_select' or event.type == 'run' then\n\t\tif file then\n\t\t\tif file.isDir then\n\t\t\t\tself:setDir(file.fullName)\n\t\t\telse\n\t\t\t\tlocal ext = file.name:match('%.(%w+)$')\n\t\t\t\tif ext and config.associations[ext] then\n\t\t\t\t\tself:run(config.associations[ext], '/' .. file.fullName)\n\t\t\t\telse\n\t\t\t\t\tself:run(file.name)\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\n\telseif event.type == 'updir' then\n\t\tlocal dir = (self.dir.name:match(\"(.*/)\"))\n\t\tself:setDir(dir or '/')\n\n\telseif event.type == 'delete' then\n\t\tif self:hasMarked() then\n\t\t\tself.question:show()\n\t\tend\n\t\treturn true\n\n\telseif event.type == 'question_yes' then\n\t\tfor _,m in pairs(marked) do\n\t\t\tpcall(fs.delete, m.fullName)\n\t\tend\n\t\tmarked = { }\n\t\tself:updateDirectory(self.dir)\n\n\t\tself.question:hide()\n\t\tself.statusBar:draw()\n\t\tself.grid:draw()\n\t\tself:setFocus(self.grid)\n\n\telseif event.type == 'question_no' then\n\t\tself.question:hide()\n\t\tself:setFocus(self.grid)\n\n\telseif event.type == 'copy' or event.type == 'cut' then\n\t\tif self:hasMarked() then\n\t\t\tcutMode = event.type == 'cut'\n\t\t\tUtil.clear(copied)\n\t\t\tUtil.merge(copied, marked)\n\t\t\t--self:unmarkAll()\n\t\t\tself.grid:draw()\n\t\t\tself:setStatus('Copied %d file(s)', Util.size(copied))\n\t\tend\n\n\telseif event.type == 'copy_path' then\n\t\tif file then\n\t\t\tos.queueEvent('clipboard_copy', file.fullName)\n\t\tend\n\n\telseif event.type == 'paste' then\n\t\tfor _,m in pairs(copied) do\n\t\t\tpcall(function()\n\t\t\t\tif cutMode then\n\t\t\t\t\tfs.move(m.fullName, fs.combine(self.dir.name, m.name))\n\t\t\t\telse\n\t\t\t\t\tfs.copy(m.fullName, fs.combine(self.dir.name, m.name))\n\t\t\t\tend\n\t\t\tend)\n\t\tend\n\t\tself:updateDirectory(self.dir)\n\t\tself.grid:draw()\n\t\tself:setStatus('Pasted ' .. Util.size(copied) .. ' file(s)')\n\n\telse\n\t\treturn UI.Page.eventHandler(self, event)\n\tend\n\tself:setFocus(self.grid)\n\treturn true\nend\n\n--[[ Associations slide out ]] --\nfunction Browser.associations:show()\n\tself.grid.values = { }\n\tfor k, v in pairs(config.associations) do\n\t\ttable.insert(self.grid.values, {\n\t\t\tname = k,\n\t\t\tvalue = v,\n\t\t})\n\tend\n\tself.grid:update()\n\tUI.SlideOut.show(self)\n\tself:setFocus(self.form[1])\nend\n\nfunction Browser.associations:eventHandler(event)\n\tif event.type == 'remove_entry' then\n\t\tlocal row = self.grid:getSelected()\n\t\tif row then\n\t\t\tUtil.removeByValue(self.grid.values, row)\n\t\t\tself.grid:update()\n\t\t\tself.grid:draw()\n\t\tend\n\n\telseif event.type == 'add_association' then\n\t\tif self.form:save() then\n\t\t\tlocal entry = Util.find(self.grid.values, 'name', self.form[1].value) or { }\n\t\t\tentry.name = self.form[1].value\n\t\t\tentry.value = self.form[2].value\n\t\t\ttable.insert(self.grid.values, entry)\n\t\t\tself.form[1]:reset()\n\t\t\tself.form[2]:reset()\n\t\t\tself.grid:update()\n\t\t\tself.grid:draw()\n\t\tend\n\n\telseif event.type == 'cancel' then\n\t\tself:hide()\n\n\telseif event.type == 'save' then\n\t\tconfig.associations = { }\n\t\tfor _, v in pairs(self.grid.values) do\n\t\t\tconfig.associations[v.name] = v.value\n\t\tend\n\t\tConfig.update('Files', config)\n\t\tself:hide()\n\n\telse\n\t\treturn UI.SlideOut.eventHandler(self, event)\n\tend\n\treturn true\nend\n\n--[[-- Startup logic --]]--\nlocal args = Util.parse(...)\n\nBrowser:setDir(args[1] or shell.dir())\n\nUI:setPage(Browser)\nUI:start()\n", "sys/apps/Partition.lua": "local Ansi   = require('opus.ansi')\nlocal Event  = require('opus.event')\nlocal UI     = require('opus.ui')\nlocal Util   = require('opus.util')\n\nlocal fs         = _G.fs\nlocal peripheral = _G.peripheral\n\nlocal source, target\n\nlocal function getDriveInfo(tgt)\n\tlocal total = 0\n\tlocal throttle = Util.throttle()\n\n\ttgt = fs.combine(tgt, '')\n\tlocal src = fs.getNode(tgt).source or tgt\n\n\tlocal function recurse(path)\n\t\tthrottle()\n\t\tif fs.isDir(path) then\n\t\t\tif path ~= src then\n\t\t\t\ttotal = total + 500\n\t\t\tend\n\t\t\tfor _, v in pairs(fs.native.list(path)) do\n\t\t\t\trecurse(fs.combine(path, v))\n\t\t\tend\n\t\telse\n\t\t\tlocal sz = fs.getSize(path)\n\t\t\ttotal = total + math.max(500, sz)\n\t\tend\n\tend\n\n\trecurse(src)\n\n\tlocal drive = fs.getDrive(src)\n\treturn {\n\t\tpath  = tgt,\n\t\tdrive  = drive,\n\t\ttype  = peripheral.getType(drive) or drive,\n\t\tused  = total,\n\t\tfree  = fs.getFreeSpace(src),\n\t\tmountPoint = src,\n\t}\nend\n\nlocal function getDrives(exclude)\n\tlocal drives = { }\n\n\tfor _, path in pairs(fs.native.list('/')) do\n\t\tlocal side = fs.getDrive(path)\n\t\tif side and not drives[side] and not fs.isReadOnly(path) and side ~= exclude then\n\t\t\tif side == 'hdd' then\n\t\t\t\tpath = ''\n\t\t\tend\n\t\t\tdrives[side] = getDriveInfo(path)\n\t\tend\n\tend\n\treturn drives\nend\n\nlocal page = UI.Page {\n\twizard = UI.Wizard {\n\t\tey = -2,\n\t\tpartitions = UI.WizardPage {\n\t\t\tindex = 1,\n\t\t\tinfo = UI.TextArea {\n\t\t\t\tx = 3, y = 2, ex = -3, ey = 5,\n\t\t\t\tvalue = [[Move the contents of a directory to another disk. A link will be created to point to that location.]]\n\t\t\t},\n\t\t\tgrid = UI.Grid {\n\t\t\t\tx = 2, y = 7, ex = -2, ey = -2,\n\t\t\t\tcolumns = {\n\t\t\t\t\t{ heading = 'Path', key = 'path', textColor = 'yellow', width = 10 },\n\t\t\t\t\t{ heading = 'Mount Point',  key = 'mountPoint' },\n\t\t\t\t\t{ heading = 'Used',  key = 'used', width = 6 },\n\t\t\t\t},\n\t\t\t\tsortColumn = 'path',\n\t\t\t\tgetDisplayValues = function (_, row)\n\t\t\t\t\trow = Util.shallowCopy(row)\n\t\t\t\t\trow.used = Util.toBytes(row.used)\n\t\t\t\t\treturn row\n\t\t\t\tend,\n\t\t\t\tenable = function(self)\n\t\t\t\t\tEvent.onTimeout(0, function()\n\t\t\t\t\t\tlocal mounts = {\n\t\t\t\t\t\t\tusr = getDriveInfo('usr/config'),\n\t\t\t\t\t\t\tpackages = getDriveInfo('packages'),\n\t\t\t\t\t\t}\n\t\t\t\t\t\tself:setValues(mounts)\n\t\t\t\t\t\tself:draw()\n\t\t\t\t\t\tself:sync()\n\t\t\t\t\tend)\n\t\t\t\t\tself:setValues({ })\n\t\t\t\t\tUI.Grid.enable(self)\n\t\t\t\tend,\n\t\t\t},\n\t\t\tvalidate = function(self)\n\t\t\t\ttarget = self.grid:getSelected()\n\t\t\t\treturn not not target\n\t\t\tend,\n\t\t},\n\t\tmounts = UI.WizardPage {\n\t\t\tindex = 2,\n\t\t\tinfo = UI.TextArea {\n\t\t\t\tx = 3, y = 2, ex = -3, ey = 5,\n\t\t\t\tvalue = [[Select the target disk. Labeled computers can be inserted into disk drives for larger volumes.]]\n\t\t\t},\n\t\t\tgrid = UI.Grid {\n\t\t\t\tx = 2, y = 7, ex = -2, ey = -2,\n\t\t\t\tcolumns = {\n\t\t\t\t\t{ heading = 'Path', key = 'path', textColor = 'yellow', width = 10 },\n\t\t\t\t\t{ heading = 'Type', key = 'type' },\n\t\t\t\t\t{ heading = 'Side',  key = 'drive' },\n\t\t\t\t\t{ heading = 'Free',  key = 'free', width = 6 },\n\t\t\t\t},\n\t\t\t\tsortColumn = 'path',\n\t\t\t\tgetDisplayValues = function (_, row)\n\t\t\t\t\trow = Util.shallowCopy(row)\n\t\t\t\t\trow.free = Util.toBytes(row.free)\n\t\t\t\t\treturn row\n\t\t\t\tend,\n\t\t\t\tgetRowTextColor = function(self, row)\n\t\t\t\t\tif row.free < target.used then\n\t\t\t\t\t\treturn 'lightGray'\n\t\t\t\t\tend\n\t\t\t\t\treturn UI.Grid.getRowTextColor(self, row)\n\t\t\t\tend,\n\t\t\t\tenable = function(self)\n\t\t\t\t\tEvent.on({ 'disk', 'disk_eject', 'partition_update' }, function()\n\t\t\t\t\t\tself:setValues(getDrives(target.drive))\n\t\t\t\t\t\tself:draw()\n\t\t\t\t\t\tself:sync()\n\t\t\t\t\tend)\n\t\t\t\t\tos.queueEvent('partition_update')\n\t\t\t\t\tself:setValues({ })\n\t\t\t\t\tUI.Grid.enable(self)\n\t\t\t\tend,\n\t\t\t},\n\t\t\tvalidate = function(self)\n\t\t\t\tsource = self.grid:getSelected()\n\t\t\t\tif not source then\n\t\t\t\t\tself:emit({ type = 'notify', message = 'No drive selected' })\n\t\t\t\telseif source.free < target.used then\n\t\t\t\t\tself:emit({ type = 'notify', message = 'Insufficient disk space' })\n\t\t\t\telse\n\t\t\t\t\treturn true\n\t\t\t\tend\n\t\t\tend,\n\t\t},\n\t\tconfirm = UI.WizardPage {\n\t\t\tindex = 3,\n\t\t\tinfo = UI.TextArea {\n\t\t\t\tx = 2, y = 2, ex = -2, ey = -2,\n\t\t\t\tmarginTop = 1, marginLeft = 1,\n\t\t\t\tbackgroundColor = 'black',\n\t\t\t},\n\t\t\tenable = function(self)\n\t\t\t\tlocal fstab = Util.readFile('usr/etc/fstab')\n\t\t\t\tlocal lines = { }\n\t\t\t\ttable.insert(lines, string.format('%sReview changes%s\\n', Ansi.yellow, Ansi.reset))\n\t\t\t\tif fstab then\n\t\t\t\t\tfor _,l in ipairs(Util.split(fstab)) do\n\t\t\t\t\t\tl = Util.trim(l)\n\t\t\t\t\t\tif #l > 0 and l:sub(1, 1) ~= '#' then\n\t\t\t\t\t\t\tlocal m = Util.matches(l)\n\t\t\t\t\t\t\tif m and m[1] and m[1] == target.path then\n\t\t\t\t\t\t\t\ttable.insert(lines, string.format('Removed from usr/etc/fstab:\\n%s%s%s\\n', Ansi.red, l, Ansi.reset))\n\t\t\t\t\t\t\tend\n\t\t\t\t\t\tend\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\tlocal t = target.path\n\t\t\t\tlocal s = fs.combine(source.path .. '/' .. target.path, '')\n\t\t\t\tif t ~= s then\n\t\t\t\t\ttable.insert(lines, string.format('Added to usr/etc/fstab:\\n%s%s linkfs %s%s\\n', Ansi.green, t, s, Ansi.reset))\n\t\t\t\tend\n\n\t\t\t\ttable.insert(lines, string.format('Move directory:\\n%s/%s -> /%s', Ansi.green, target.mountPoint, s))\n\n\t\t\t\tself.info:setText(table.concat(lines, '\\n'))\n\t\t\t\tUI.WizardPage.enable(self)\n\t\t\tend,\n\t\t\tvalidate = function(self)\n\t\t\t\tif self.changesApplied then\n\t\t\t\t\treturn true\n\t\t\t\tend\n\t\t\t\tlocal fstab = Util.readFile('usr/etc/fstab')\n\t\t\t\tlocal lines = { }\n\t\t\t\tif fstab then\n\t\t\t\t\tfor _,l in ipairs(Util.split(fstab)) do\n\t\t\t\t\t\ttable.insert(lines, l)\n\t\t\t\t\t\tl = Util.trim(l)\n\t\t\t\t\t\tif #l > 0 and l:sub(1, 1) ~= '#' then\n\t\t\t\t\t\t\tlocal m = Util.matches(l)\n\t\t\t\t\t\t\tif m and m[1] and m[1] == target.path then\n\t\t\t\t\t\t\t\tfs.unmount(m[1])\n\t\t\t\t\t\t\t\ttable.remove(lines)\n\t\t\t\t\t\t\tend\n\t\t\t\t\t\tend\n\t\t\t\t\tend\n\t\t\t\tend\n\n\t\t\t\tlocal t = target.path\n\t\t\t\tlocal s = fs.combine(source.path .. '/' .. target.path, '')\n\n\t\t\t\tfs.move('/' .. target.mountPoint, '/' .. s)\n\n\t\t\t\tif t ~= s then\n\t\t\t\t\ttable.insert(lines, string.format('%s linkfs %s', t, s))\n\t\t\t\t\tfs.mount(t, 'linkfs', s)\n\t\t\t\tend\n\n\t\t\t\tUtil.writeFile('usr/etc/fstab', table.concat(lines, '\\n'))\n\n\t\t\t\tself.parent.nextButton.text = 'Exit'\n\t\t\t\tself.parent.cancelButton:disable()\n\t\t\t\tself.parent.previousButton:disable()\n\n\t\t\t\tself.changesApplied = true\n\t\t\t\tself.info:setValue('Changes have been applied')\n\t\t\t\tself.parent:draw()\n\t\t\tend,\n\t\t},\n\t},\n\tnotification = UI.Notification { },\n\teventHandler = function(self, event)\n\t\tif event.type == 'notify' then\n\t\t\tself.notification:error(event.message)\n\t\telseif event.type == 'accept' or event.type == 'cancel' then\n\t\t\tUI:quit()\n\t\tend\n\t\treturn UI.Page.eventHandler(self, event)\n\tend,\n}\n\nUI:disableEffects()\nUI:setPage(page)\nUI:start()\n", "sys/apps/cedit.lua": "local Config     = require('opus.config')\n\nlocal multishell = _ENV.multishell\nlocal os         = _G.os\nlocal read       = _G.read\nlocal shell      = _ENV.shell\n\nlocal args = { ... }\nif not args[1] then\n\terror('Syntax: cedit <filename>')\nend\n\nif not _G.http.websocket then\n\terror('Requires CC: Tweaked')\nend\n\nif not _G.cloud_catcher then\n\tlocal key = Config.load('cloud').key\n\n\tif not key then\n\t\tprint('Visit https://cloud-catcher.squiddev.cc')\n\t\tprint('Paste key: ')\n\t\tkey = read()\n\t\tif #key == 0 then\n\t\t\treturn\n\t\tend\n\tend\n\n\t-- open an unfocused tab\n\tlocal id = shell.openTab('cloud ' .. key)\n\tprint('Connecting...')\n\twhile not _G.cloud_catcher do\n\t\tos.sleep(.2)\n\tend\n\tmultishell.setTitle(id, 'Cloud')\nend\n\nshell.run('cloud edit ' .. table.unpack({ ... }))\n", "sys/apps/Overview.lua": "local Array    = require('opus.array')\nlocal class    = require('opus.class')\nlocal Config   = require('opus.config')\nlocal Event    = require('opus.event')\nlocal NFT      = require('opus.nft')\nlocal Packages = require('opus.packages')\nlocal SHA      = require('opus.crypto.sha2')\nlocal Tween    = require('opus.ui.tween')\nlocal UI       = require('opus.ui')\nlocal Util     = require('opus.util')\n\nlocal device     = _G.device\nlocal fs         = _G.fs\nlocal os         = _G.os\nlocal pocket     = _G.pocket\nlocal shell      = _ENV.shell\nlocal term       = _G.term\nlocal turtle     = _G.turtle\n\n--[[\n\tturtle: 39x13\n\tcomputer: 51x19\n\tpocket: 26x20\n]]\n\nif not _ENV.multishell then\n\terror('multishell is required')\nend\n\nlocal REGISTRY_DIR = 'usr/.registry'\n\n-- iconExt:gsub('.', function(b) return '\\\\' .. b:byte() end)\nlocal DEFAULT_ICON = NFT.parse('\\30\\55\\31\\48\\136\\140\\140\\140\\132\\\n\\30\\48\\31\\55\\149\\31\\48\\128\\128\\128\\30\\55\\149\\\n\\30\\55\\31\\48\\138\\143\\143\\143\\133')\nlocal TRANS_ICON = NFT.parse('\\0302\\0312\\32\\32\\32\\32\\32\\\n\\0302\\0312\\32\\32\\32\\32\\32\\\n\\0302\\0312\\32\\32\\32\\32\\32')\n\n-- overview\nlocal uid = _ENV.multishell.getCurrent()\ndevice.keyboard.addHotkey('control-o', function()\n\t_ENV.multishell.setFocus(uid)\nend)\n\nUI:configure('Overview', ...)\n\nlocal config = {\n\tRecent = { },\n\tcurrentCategory = 'Apps',\n}\nConfig.load('Overview', config)\n\nlocal extSupport = Util.getVersion() >= 1.76\n\nlocal applications = { }\nlocal buttons = { }\n\nlocal sx, sy = term.current().getSize()\nlocal maxRecent = math.ceil(sx * sy / 62)\n\nlocal function ellipsis(s, len)\n\tif #s > len then\n\t\ts = s:sub(1, len - 2) .. '..'\n\tend\n\treturn s\nend\n\nlocal function parseIcon(iconText)\n\tlocal icon\n\n\tlocal s, m = pcall(function()\n\t\ticon = NFT.parse(iconText)\n\t\tif icon then\n\t\t\tif icon.height > 3 or icon.width > 8 then\n\t\t\t\terror('Must be an NFT image - 3 rows, 8 cols max')\n\t\t\tend\n\t\t\tNFT.transparency(icon)\n\t\tend\n\t\treturn icon\n\tend)\n\n\tif s then\n\t\treturn icon\n\tend\n\n\treturn s, m\nend\n\nlocal page = UI.Page {\n\tcontainer = UI.Viewport {\n\t\tx = 9, y = 1,\n\t},\n\ttabBar = UI.TabBar {\n\t\tey = -2,\n\t\twidth = 8,\n\t\tselectedBackgroundColor = 'primary',\n\t\tbackgroundColor = 'tertiary',\n\t\tunselectedTextColor = 'lightGray',\n\t\tlayout = function(self)\n\t\t\tself.height = nil\n\t\t\tUI.TabBar.layout(self)\n\t\tend,\n\t},\n\ttray = UI.Window {\n\t\ty = -1, width = 8,\n\t\tbackgroundColor = 'tertiary',\n\t\tnewApp = UI.FlatButton {\n\t\t\tx = 2,\n\t\t\ttext = '+', event = 'new',\n\t\t},\n\t\tmode = UI.FlatButton {\n\t\t\tx = 4,\n\t\t\ttext = '=', event = 'display_mode',\n\t\t},\n\t\thelp = UI.FlatButton {\n\t\t\tx = 6,\n\t\t\ttext = '?', event = 'help',\n\t\t},\n\t},\n\teditor = UI.SlideOut {\n\t\ty = -12, height = 12,\n\t\ttitleBar = UI.TitleBar {\n\t\t\ttitle = 'Edit Application',\n\t\t\tevent = 'slide_hide',\n\t\t},\n\t\tform = UI.Form {\n\t\t\ty = 2, ey = -2,\n\t\t\t[1] = UI.TextEntry {\n\t\t\t\tformLabel = 'Title', formKey = 'title', limit = 11, width = 13, help = 'Application title',\n\t\t\t\trequired = true,\n\t\t\t},\n\t\t\t[2] = UI.TextEntry {\n\t\t\t\tformLabel = 'Run', formKey = 'run', limit = 100, help = 'Full path to application',\n\t\t\t\trequired = true,\n\t\t\t},\n\t\t\t[3] = UI.TextEntry {\n\t\t\t\tformLabel = 'Category', formKey = 'category', limit = 6, width = 8, help = 'Category of application',\n\t\t\t\trequired = true,\n\t\t\t},\n\t\t\teditIcon = UI.Button {\n\t\t\t\tx = 11, y = 6,\n\t\t\t\ttext = 'Edit', event = 'editIcon', help = 'Edit icon file',\n\t\t\t},\n\t\t\tloadIcon = UI.Button {\n\t\t\t\tx = 11, y = 8,\n\t\t\t\ttext = 'Load', event = 'loadIcon', help = 'Load icon file',\n\t\t\t},\n\t\t\thelpIcon = UI.Button {\n\t\t\t\tx = 11, y = 8,\n\t\t\t\ttext = 'Load', event = 'loadIcon', help = 'Load icon file',\n\t\t\t},\n\t\t\timage = UI.NftImage {\n\t\t\t\tbackgroundColor = 'black',\n\t\t\t\ty = 6, x = 2, height = 3, width = 8,\n\t\t\t},\n\t\t},\n\t\tfile_open = UI.FileSelect {\n\t\t\tmodal = true,\n\t\t\tenable = function() end,\n\t\t\ttransitionHint = 'expandUp',\n\t\t\tshow = function(self)\n\t\t\t\tUI.FileSelect.enable(self)\n\t\t\t\tself:focusFirst()\n\t\t\t\tself:draw()\n\t\t\tend,\n\t\t\tdisable = function(self)\n\t\t\t\tUI.FileSelect.disable(self)\n\t\t\t\tself.parent:focusFirst()\n\t\t\t\t-- need to recapture as we are opening a modal within another modal\n\t\t\t\tself.parent:capture(self.parent)\n\t\t\tend,\n\t\t\teventHandler = function(self, event)\n\t\t\t\tif event.type == 'select_cancel' then\n\t\t\t\t\tself:disable()\n\t\t\t\telseif event.type == 'select_file' then\n\t\t\t\t\tself:disable()\n\t\t\t\tend\n\t\t\t\treturn UI.FileSelect.eventHandler(self, event)\n\t\t\tend,\n\t\t},\n\t\tnotification = UI.Notification(),\n\t\tstatusBar = UI.StatusBar(),\n\t},\n\tnotification = UI.Notification(),\n\taccelerators = {\n\t\tr = 'refresh',\n\t\te = 'edit',\n\t\tf = 'files',\n\t\ts = 'shell',\n\t\tl = 'lua',\n\t\tn = 'network',\n\t\t[ 'control-n' ] = 'new',\n\t\tdelete = 'delete',\n\t},\n}\n\nlocal function loadApplications()\n\tlocal requirements = {\n\t\tturtle = not not turtle,\n\t\tadvancedTurtle = turtle and term.isColor(),\n\t\tadvanced = term.isColor(),\n\t\tpocket = not not pocket,\n\t\tadvancedPocket = pocket and term.isColor(),\n\t\tadvancedComputer = not turtle and not pocket and term.isColor(),\n\t\tneuralInterface = not not device.neuralInterface,\n\t}\n\n\tapplications = Util.readTable('sys/etc/apps.db')\n\n\tfor dir in pairs(Packages:installed()) do\n\t\tlocal path = fs.combine('packages/' .. dir, 'etc/apps.db')\n\t\tif fs.exists(path) then\n\t\t\tlocal apps = Util.readTable(path) or { }\n\t\t\tUtil.merge(applications, apps)\n\t\tend\n\tend\n\n\tif fs.exists(REGISTRY_DIR) then\n\t\tlocal files = fs.list(REGISTRY_DIR)\n\t\tfor _,file in pairs(files) do\n\t\t\tlocal app = Util.readTable(fs.combine(REGISTRY_DIR, file))\n\t\t\tif app and app.key then\n\t\t\t\tapp.filename = fs.combine(REGISTRY_DIR, file)\n\t\t\t\tapplications[app.key] = app\n\t\t\tend\n\t\tend\n\tend\n\n\tUtil.each(applications, function(v, k) v.key = k end)\n\tapplications = Util.filter(applications, function(a)\n\t\tif a.disabled then\n\t\t\treturn false\n\t\tend\n\n\t\tif a.requires then\n\t\t\treturn requirements[a.requires]\n\t\tend\n\n\t\treturn true\n\tend)\n\n\tlocal categories = { }\n\tbuttons = { }\n\tfor _,f in pairs(applications) do\n\t\tif not categories[f.category] then\n\t\t\tcategories[f.category] = true\n\t\t\ttable.insert(buttons, {\n\t\t\t\ttext = f.category,\n\t\t\t\twidth = 8,\n\t\t\t\tselected = config.currentCategory == f.category\n\t\t\t})\n\t\tend\n\tend\n\ttable.sort(buttons, function(a, b) return a.text < b.text end)\n\ttable.insert(buttons, 1, { text = 'Recent' })\n\n\tfor k,v in pairs(buttons) do\n\t\tv.x = 1\n\t\tv.y = k + 1\n\tend\n\n\tpage.tabBar.children = { }\n\tpage.tabBar:addButtons(buttons)\n\n\t--page.tabBar:selectTab(config.currentCategory or 'Apps')\n\tpage.container:setCategory(config.currentCategory or 'Apps')\nend\n\nUI.Icon = class(UI.Window)\nUI.Icon.defaults = {\n\tUIElement = 'Icon',\n\twidth = 14,\n\theight = 4,\n}\nfunction UI.Icon:eventHandler(event)\n\tif event.type == 'mouse_click' then\n\t\tself:setFocus(self.button)\n\t\treturn true\n\telseif event.type == 'mouse_doubleclick' then\n\t\tself:emit({ type = self.button.event, button = self.button })\n\telseif event.type == 'mouse_rightclick' then\n\t\tself:setFocus(self.button)\n\t\tself:emit({ type = 'edit', button = self.button })\n\tend\n\treturn UI.Window.eventHandler(self, event)\nend\n\nfunction page.container:setCategory(categoryName, animate)\n\t-- reset the viewport window\n\tself.children = { }\n\tself:reset()\n\n\tlocal filtered = { }\n\n\tif categoryName == 'Recent' then\n\t\tfor _,v in ipairs(config.Recent) do\n\t\t\tlocal app = Util.find(applications, 'key', v)\n\t\t\tif app then\n\t\t\t\ttable.insert(filtered, app)\n\t\t\tend\n\t\tend\n\telse\n\t\tfiltered = Array.filter(applications, function(a)\n\t\t\treturn a.category == categoryName\n\t\tend)\n\t\ttable.sort(filtered, function(a, b) return a.title < b.title end)\n\tend\n\n\tfor _,program in ipairs(filtered) do\n\t\tlocal icon\n\t\tif extSupport and program.iconExt then\n\t\t\ticon = parseIcon(program.iconExt)\n\t\tend\n\t\tif not icon and program.icon then\n\t\t\ticon = parseIcon(program.icon)\n\t\tend\n\t\tif not icon then\n\t\t\ticon = DEFAULT_ICON\n\t\tend\n\n\t\tlocal title = ellipsis(program.title, 8)\n\n\t\tlocal width = math.max(icon.width + 2, #title + 2)\n\t\tif config.listMode then\n\t\t\ttable.insert(self.children, UI.Icon {\n\t\t\t\twidth = self.width - 2,\n\t\t\t\theight = 1,\n\t\t\t\tUI.Button {\n\t\t\t\t\tx = 1, ex = -1,\n\t\t\t\t\ttext = program.title,\n\t\t\t\t\tcentered = false,\n\t\t\t\t\tbackgroundColor = self:getProperty('backgroundColor'),\n\t\t\t\t\tbackgroundFocusColor = 'gray',\n\t\t\t\t\ttextColor = 'white',\n\t\t\t\t\ttextFocusColor = 'white',\n\t\t\t\t\tevent = 'button',\n\t\t\t\t\tapp = program,\n\t\t\t\t}\n\t\t\t})\n\t\telse\n\t\t\ttable.insert(self.children, UI.Icon({\n\t\t\t\twidth = width,\n\t\t\t\timage = UI.NftImage({\n\t\t\t\t\tx = math.floor((width - icon.width) / 2) + 1,\n\t\t\t\t\timage = icon,\n\t\t\t\t}),\n\t\t\t\tbutton = UI.Button({\n\t\t\t\t\tx = math.floor((width - #title - 2) / 2) + 1,\n\t\t\t\t\ty = 4,\n\t\t\t\t\ttext = title,\n\t\t\t\t\tbackgroundColor = self:getProperty('backgroundColor'),\n\t\t\t\t\tbackgroundFocusColor = 'gray',\n\t\t\t\t\ttextColor = 'white',\n\t\t\t\t\ttextFocusColor = 'white',\n\t\t\t\t\twidth = #title + 2,\n\t\t\t\t\tevent = 'button',\n\t\t\t\t\tapp = program,\n\t\t\t\t}),\n\t\t\t}))\n\t\tend\n\tend\n\n\tlocal gutter = 2\n\tif UI.term.width <= 26 then\n\t\tgutter = 1\n\tend\n\tlocal col, row = gutter, 2\n\tlocal count = #self.children\n\n\tlocal r = math.random(1, 7)\n\tlocal frames = 5\n\t-- reposition all children\n\tfor k,child in ipairs(self.children) do\n\t\tif r == 1 then\n\t\t\tchild.x = math.random(1, self.width)\n\t\t\tchild.y = math.random(1, self.height - 3)\n\t\telseif r == 2 then\n\t\t\tchild.x = self.width\n\t\t\tchild.y = self.height - 3\n\t\telseif r == 3 then\n\t\t\tchild.x = math.floor(self.width / 2)\n\t\t\tchild.y = math.floor(self.height / 2)\n\t\telseif r == 4 then\n\t\t\tchild.x = self.width - col\n\t\t\tchild.y = row\n\t\telseif r == 5 then\n\t\t\tchild.x = col\n\t\t\tchild.y = row\n\t\t\tif k == #self.children then\n\t\t\t\tchild.x = self.width\n\t\t\t\tchild.y = self.height - 3\n\t\t\tend\n\t\telseif r == 6 then\n\t\t\tchild.x = col\n\t\t\tchild.y = 1\n\t\telseif r == 7 then\n\t\t\tchild.x = 1\n\t\t\tchild.y = self.height - 3\n\t\tend\n\t\tchild.tween = Tween.new(frames, child, { x = col, y = row }, 'inQuad')\n\n\t\tif not animate then\n\t\t\tchild.x = col\n\t\t\tchild.y = row\n\t\tend\n\n\t\tself:setViewHeight(row + (config.listMode and 1 or 4))\n\n\t\tif k < count then\n\t\t\tcol = col + child.width\n\t\t\tif col + self.children[k + 1].width + gutter - 2 > self.width then\n\t\t\t\tcol = gutter\n\t\t\t\trow = row + (config.listMode and 1 or 5)\n\t\t\tend\n\t\tend\n\tend\n\n\tself:initChildren()\n\tif animate then\n\t\tlocal function transition()\n\t\t\tlocal i = 1\n\t\t\treturn function()\n\t\t\t\tfor _,child in pairs(self.children) do\n\t\t\t\t\tchild.tween:update(1)\n\t\t\t\t\tchild:move(math.floor(child.x), math.floor(child.y))\n\t\t\t\tend\n\t\t\t\ti = i + 1\n\t\t\t\treturn i <= frames\n\t\t\tend\n\t\tend\n\t\tself:addTransition(transition)\n\tend\nend\n\nfunction page:refresh()\n\tlocal pos = self.container.offy\n\tself:focusFirst(self)\n\tself.container:setCategory(config.currentCategory)\n\tself.container:setScrollPosition(pos)\nend\n\nfunction page:resize()\n\tUI.Page.resize(self)\n\tself:refresh()\nend\n\nfunction page:eventHandler(event)\n\tif event.type == 'tab_select' then\n\t\tself.container:setCategory(event.button.text, true)\n\t\tself.container:draw()\n\n\t\tconfig.currentCategory = event.button.text\n\t\tConfig.update('Overview', config)\n\n\telseif event.type == 'button' then\n\t\tfor k,v in ipairs(config.Recent) do\n\t\t\tif v == event.button.app.key then\n\t\t\t\ttable.remove(config.Recent, k)\n\t\t\t\tbreak\n\t\t\tend\n\t\tend\n\t\ttable.insert(config.Recent, 1, event.button.app.key)\n\t\tif #config.Recent > maxRecent then\n\t\t\ttable.remove(config.Recent, maxRecent + 1)\n\t\tend\n\t\tConfig.update('Overview', config)\n\t\tshell.switchTab(shell.openTab(event.button.app.run))\n\n\telseif event.type == 'shell' then\n\t\tshell.switchTab(shell.openTab('shell'))\n\n\telseif event.type == 'lua' then\n\t\tshell.switchTab(shell.openTab('Lua'))\n\n\telseif event.type == 'files' then\n\t\tshell.switchTab(shell.openTab('Files'))\n\n\telseif event.type == 'network' then\n\t\tshell.switchTab(shell.openTab('Network'))\n\n\telseif event.type == 'help' then\n\t\tshell.switchTab(shell.openTab('Help Overview'))\n\n\telseif event.type == 'focus_change' then\n\t\tif event.focused.parent.UIElement == 'Icon' then\n\t\t\tevent.focused.parent:scrollIntoView()\n\t\tend\n\n\telseif event.type == 'refresh' then -- remove this after fixing notification\n\t\tloadApplications()\n\t\tself:refresh()\n\t\tself:draw()\n\t\tself.notification:success('Refreshed')\n\n\telseif event.type == 'delete' then\n\t\tlocal focused = page:getFocused()\n\t\tif focused.app then\n\t\t\tif focused.app.filename then\n\t\t\t\tfs.delete(focused.app.filename)\n\t\t\telse\n\t\t\t\tfocused.app.disabled = true\n\t\t\t\tlocal filename = focused.app.filename or fs.combine(REGISTRY_DIR, focused.app.key)\n\t\t\t\tUtil.writeTable(filename, focused.app)\n\t\t\tend\n\t\t\tloadApplications()\n\t\t\tpage:refresh()\n\t\t\tpage:draw()\n\t\t\tself.notification:success('Removed')\n\t\tend\n\n\telseif event.type == 'new' then\n\t\tlocal category = 'Apps'\n\t\tif config.currentCategory ~= 'Recent' then\n\t\t\tcategory = config.currentCategory or 'Apps'\n\t\tend\n\t\tself.editor:show({ category = category })\n\n\telseif event.type == 'display_mode' then\n\t\tconfig.listMode = not config.listMode\n\t\tConfig.update('Overview', config)\n\t\tloadApplications()\n\t\tself:refresh()\n\t\tself:draw()\n\n\telseif event.type == 'edit' then\n\t\tlocal focused = page:getFocused()\n\t\tif focused.app then\n\t\t\tself.editor:show(focused.app)\n\t\tend\n\n\telse\n\t\treturn UI.Page.eventHandler(self, event)\n\tend\n\treturn true\nend\n\nfunction page.editor:show(app)\n\tif app then\n\t\tself.form:setValues(app)\n\n\t\tlocal icon\n\t\tif extSupport and app.iconExt then\n\t\t\ticon = parseIcon(app.iconExt)\n\t\tend\n\t\tif not icon and app.icon then\n\t\t\ticon = parseIcon(app.icon)\n\t\tend\n\t\tself.form.image:setImage(icon)\n\tend\n\tUI.SlideOut.show(self)\n\tself:focusFirst()\nend\n\nfunction page.editor:updateApplications(app)\n\tif not app.key then\n\t\tapp.key = SHA.compute(app.title)\n\tend\n\tlocal filename = app.filename or fs.combine(REGISTRY_DIR, app.key)\n\tUtil.writeTable(filename, app)\n\tloadApplications()\nend\n\nfunction page.editor:loadImage(filename)\n\tlocal s, m = pcall(function()\n\t\tlocal iconLines = Util.readFile(filename)\n\t\tif not iconLines then\n\t\t\terror('Must be an NFT image - 3 rows, 8 cols max')\n\t\tend\n\t\tlocal icon, m = parseIcon(iconLines)\n\t\tif not icon then\n\t\t\terror(m)\n\t\tend\n\t\tif extSupport then\n\t\t\tself.form.values.iconExt = iconLines\n\t\telse\n\t\t\tself.form.values.icon = iconLines\n\t\tend\n\t\tself.form.image:setImage(icon)\n\t\tself.form.image:draw()\n\tend)\n\tif not s and m then\n\t\tlocal msg = m:gsub('.*: (.*)', '%1')\n\t\tself.notification:error(msg)\n\tend\nend\n\nfunction page.editor:eventHandler(event)\n\tif event.type == 'form_cancel' or event.type == 'cancel' then\n\t\tself:hide()\n\n\telseif event.type == 'focus_change' then\n\t\tself.statusBar:setStatus(event.focused.help or '')\n\n\telseif event.type == 'editIcon' then\n\t\tlocal filename = '/tmp/editing.nft'\n\t\tNFT.save(self.form.image.image or TRANS_ICON, filename)\n\t\tlocal success = shell.run('pain.lua ' .. filename)\n\t\tself.parent:dirty(true)\n\t\tif success then\n\t\t\tself:loadImage(filename)\n\t\tend\n\n\telseif event.type == 'select_file' then\n\t\tself:loadImage(event.file)\n\n\telseif event.type == 'loadIcon' then\n\t\tself.file_open:show()\n\n\telseif event.type == 'form_invalid' then\n\t\tself.notification:error(event.message)\n\n\telseif event.type == 'form_complete' then\n\t\tlocal values = self.form.values\n\t\tself:hide()\n\t\tself:updateApplications(values)\n\t\tconfig.currentCategory = values.category\n\t\tConfig.update('Overview', config)\n\t\tos.queueEvent('overview_refresh')\n\telse\n\t\treturn UI.SlideOut.eventHandler(self, event)\n\tend\n\treturn true\nend\n\nlocal function reload()\n\tloadApplications()\n\tpage:refresh()\n\tpage:draw()\n\tpage:sync()\nend\n\nEvent.on('overview_shortcut', function(_, app)\n\tif not app.key then\n\t\tapp.key = SHA.compute(app.title)\n\tend\n\tlocal filename = app.filename or fs.combine(REGISTRY_DIR, app.key)\n\tif not fs.exists(filename) then\n\t\tUtil.writeTable(filename, app)\n\t\treload()\n\tend\nend)\n\nEvent.on('overview_refresh', function()\n\treload()\nend)\n\nloadApplications()\n\nUI:setPage(page)\nUI:start()\n", "sys/apps/netdaemon.lua": "local Event = require('opus.event')\nlocal Util  = require('opus.util')\n\nlocal device     = _G.device\nlocal fs         = _G.fs\nlocal network    = _G.network\nlocal os         = _G.os\nlocal printError = _G.printError\n\nif not device.wireless_modem then\n\treturn\nend\n\nprint('Net daemon starting')\n-- don't close as multiple computers may be sharing the\n-- wireless modem\n--device.wireless_modem.closeAll()\n\nfor _,file in pairs(fs.list('sys/apps/network')) do\n\tlocal fn, msg = Util.run(_ENV, 'sys/apps/network/' .. file)\n\tif not fn then\n\t\tprintError(msg)\n\tend\nend\n\nEvent.on('device_detach', function()\n\tif not device.wireless_modem then\n\t\tEvent.exitPullEvents()\n\tend\nend)\n\nprint('Net daemon started')\nos.queueEvent('network_up')\nEvent.pullEvents()\n\nfor _,c in pairs(network) do\n\tc.active = false\n\tos.queueEvent('network_detach', c)\nend\nos.queueEvent('network_down')\nEvent.pullEvent('network_down')\n\nUtil.clear(network)\n\nprint('Net daemon stopped')\n", "sys/apps/Tasks.lua": "local Event = require('opus.event')\nlocal UI    = require('opus.ui')\n\nlocal kernel     = _G.kernel\nlocal multishell = _ENV.multishell\nlocal tasks      = multishell and multishell.getTabs and multishell.getTabs() or kernel.routines\n\nUI:configure('Tasks', ...)\n\nlocal page = UI.Page {\n\tmenuBar = UI.MenuBar {\n\t\tbuttons = {\n\t\t\t{ text = 'Activate',  event = 'activate'  },\n\t\t\t{ text = 'Terminate', event = 'terminate' },\n\t\t\t{ text = 'Inspect',   event = 'inspect'   },\n\t\t},\n\t},\n\tgrid = UI.ScrollingGrid {\n\t\ty = 2,\n\t\tcolumns = {\n\t\t\t{ heading = 'ID',     key = 'uid',      width = 3 },\n\t\t\t{ heading = 'Title',  key = 'title'     },\n\t\t\t{ heading = 'Status', key = 'status'    },\n\t\t\t{ heading = 'Time',   key = 'timestamp' },\n\t\t},\n\t\tvalues = tasks,\n\t\tsortColumn = 'uid',\n\t\tautospace = true,\n\t\tgetDisplayValues = function (_, row)\n\t\t\tlocal elapsed = os.clock()-row.timestamp\n\t\t\treturn {\n\t\t\t\tuid = row.uid,\n\t\t\t\ttitle = row.title,\n\t\t\t\tstatus = row.isDead and 'error' or coroutine.status(row.co),\n\t\t\t\ttimestamp = elapsed < 60 and\n\t\t\t\t\tstring.format(\"%ds\", math.floor(elapsed)) or\n\t\t\t\t\tstring.format(\"%sm\", math.floor(elapsed/6)/10),\n\t\t\t}\n\t\tend\n\t},\n\taccelerators = {\n\t\t[ 'control-q' ] = 'quit',\n\t\t[ ' ' ] = 'activate',\n\t\tt = 'terminate',\n\t},\n\teventHandler = function (self, event)\n\t\tlocal t = self.grid:getSelected()\n\t\tif t then\n\t\t\tif event.type == 'activate' or event.type == 'grid_select' then\n\t\t\t\tmultishell.setFocus(t.uid)\n\t\t\telseif event.type == 'terminate' then\n\t\t\t\tmultishell.terminate(t.uid)\n\t\t\telseif event.type == 'inspect' then\n\t\t\t\tmultishell.openTab(_ENV, {\n\t\t\t\t\tpath = 'sys/apps/Lua.lua',\n\t\t\t\t\targs = { t },\n\t\t\t\t\tfocused = true,\n\t\t\t\t})\n\t\t\tend\n\t\tend\n\t\tif event.type == 'quit' then\n\t\t\tUI:quit()\n\t\tend\n\t\tUI.Page.eventHandler(self, event)\n\tend\n}\n\nEvent.onInterval(1, function()\n\tpage.grid:update()\n\tpage.grid:draw()\n\tpage:sync()\nend)\n\nUI:setPage(page)\nUI:start()\n", "sys/apps/ShellLauncher.lua": "local kernel = _G.kernel\nlocal os     = _G.os\nlocal shell  = _ENV.shell\n\nlocal launcherTab = kernel.getCurrent()\nlauncherTab.noFocus = true\n\nkernel.hook('kernel_focus', function(_, eventData)\n\tlocal focusTab = eventData and eventData[1]\n\tif focusTab == launcherTab.uid then\n\t\tlocal previousTab = eventData[2]\n\t\tlocal nextTab = launcherTab\n\t\tif not previousTab then\n\t\t\tfor _, v in pairs(kernel.routines) do\n\t\t\t\tif not v.hidden and v.uid > nextTab.uid then\n\t\t\t\t\tnextTab = v\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\t\tif nextTab == launcherTab then\n\t\t\tshell.switchTab(shell.openTab('shell'))\n\t\telse\n\t\t\tshell.switchTab(nextTab.uid)\n\t\tend\n\tend\nend)\n\nos.pullEventRaw('kernel_halt')\n", "sys/apps/inspect.lua": "local UI   = require('opus.ui')\nlocal Util = require('opus.util')\n\nlocal colors     = _G.colors\nlocal multishell = _ENV.multishell\n\nlocal name = ({ ... })[1] or error('Syntax: inspect COMPONENT')\nlocal events = { }\nlocal page, lastEvent, focused\n\nlocal function isRelevant(el)\n\treturn page.testContainer == el or el.parent and isRelevant(el.parent)\nend\n\nlocal emitter = UI.Window.emit\nfunction UI.Window:emit(event)\n\tif event ~= lastEvent and isRelevant(self) then\n\t\tlastEvent = event\n\t\tlocal t = { }\n\t\tfor k,v in pairs(event) do\n\t\t\tif k ~= 'type' and k ~= 'recorded' then\n\t\t\t\ttable.insert(t, k .. ':' .. (type(v) == 'table' and (v.UIElement and v.uid or 'tbl') or tostring(v)))\n\t\t\tend\n\t\tend\n\t\ttable.insert(events, 1, { type = event.type, value = table.concat(t, ' '), raw = event })\n\t\twhile #events > 20 do\n\t\t\ttable.remove(events)\n\t\tend\n\t\tpage.tabs.events.grid:update()\n\t\tif page.tabs.events.enabled then\n\t\t\tpage.tabs.events.grid:draw()\n\t\tend\n\tend\n\treturn emitter(self, event)\nend\n\n-- do not load component until emit hook is in place\nlocal component = UI[name] and UI[name]() or error('Invalid component')\nif not component.example then\n\terror('No example present')\nend\n\npage = UI.Page {\n\ttestContainer = UI.Window {\n\t\tey = '50%',\n\t\ttesting = component.example(),\n\t},\n\ttabs = UI.Tabs {\n\t\tbackgroundColor = colors.red,\n\t\ty = '50%',\n\t\tproperties = UI.Tab {\n\t\t\ttitle = 'Properties',\n\t\t\tgrid = UI.ScrollingGrid {\n\t\t\t\theaderBackgroundColor = colors.red,\n\t\t\t\tsortColumn = 'key',\n\t\t\t\tcolumns = {\n\t\t\t\t\t{ heading = 'key', key = 'key' },\n\t\t\t\t\t{ heading = 'value', key = 'value',  }\n\t\t\t\t},\n\t\t\t\taccelerators = {\n\t\t\t\t\tgrid_select = 'edit_property',\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\tmethodsTab = UI.Tab {\n\t\t\tindex = 2,\n\t\t\ttitle = 'Methods',\n\t\t\tgrid = UI.ScrollingGrid {\n\t\t\t\tex = '50%',\n\t\t\t\theaderBackgroundColor = colors.red,\n\t\t\t\tsortColumn = 'key',\n\t\t\t\tcolumns = {\n\t\t\t\t\t{ heading = 'key', key = 'key' },\n\t\t\t\t},\n\t\t\t},\n\t\t\tdocs = UI.TextArea {\n\t\t\t\tx = '50%',\n\t\t\t\tbackgroundColor = colors.black,\n\t\t\t},\n\t\t\teventHandler = function (self, event)\n\t\t\t\tif event.type == 'grid_focus_row' and focused then\n\t\t\t\t\tself.docs:setText(focused:getDoc(event.selected.key) or '')\n\t\t\t\tend\n\t\t\tend,\n\t\t},\n\t\tevents = UI.Tab {\n\t\t\tindex = 1,\n\t\t\ttitle = 'Events',\n\t\t\tUI.MenuBar {\n\t\t\t\ty = -1,\n\t\t\t\tbackgroundColor = colors.red,\n\t\t\t\tbuttons = {\n\t\t\t\t\t{ text = 'Clear' },\n\t\t\t\t}\n\t\t\t},\n\t\t\tgrid = UI.ScrollingGrid {\n\t\t\t\tey = -2,\n\t\t\t\theaderBackgroundColor = colors.red,\n\t\t\t\tvalues = events,\n\t\t\t\tautospace = true,\n\t\t\t\tcolumns = {\n\t\t\t\t\t{ heading = 'type', key = 'type' },\n\t\t\t\t\t{ heading = 'value', key = 'value',  }\n\t\t\t\t},\n\t\t\t},\n\t\t\teventHandler = function (self, event)\n\t\t\t\tif event.type == 'button_press' then\n\t\t\t\t\tUtil.clear(self.grid.values)\n\t\t\t\t\tself.grid:update()\n\t\t\t\t\tself.grid:draw()\n\n\t\t\t\telseif event.type == 'grid_select' then\n\t\t\t\t\tmultishell.openTab(_ENV, {\n\t\t\t\t\t\tpath = 'sys/apps/Lua.lua',\n\t\t\t\t\t\targs = { event.selected.raw },\n\t\t\t\t\t\tfocused = true,\n\t\t\t\t\t})\n\t\t\t\tend\n\t\t\tend\n\t\t}\n\t},\n\teditor = UI.SlideOut {\n\t\ty = -4, height = 4,\n\t\tbackgroundColor = colors.green,\n\t\ttitleBar = UI.TitleBar {\n\t\t\tevent = 'editor_cancel',\n\t\t\ttitle = 'Enter value',\n\t\t},\n\t\tentry = UI.TextEntry {\n\t\t\ty = 3, x = 2, ex = 10,\n\t\t\taccelerators = {\n\t\t\t\tenter = 'editor_apply',\n\t\t\t},\n\t\t},\n\t},\n\taccelerators = {\n\t\t['shift-right'] = 'size',\n\t\t['shift-left' ] = 'size',\n\t\t['shift-up'   ] = 'size',\n\t\t['shift-down' ] = 'size',\n\t},\n\teventHandler = function (self, event)\n\t\tif event.type == 'focus_change' and isRelevant(event.focused) then\n\t\t\tfocused = event.focused\n\t\t\tlocal t = { }\n\t\t\tfor k,v in pairs(event.focused) do\n\t\t\t\ttable.insert(t, {\n\t\t\t\t\tkey = k,\n\t\t\t\t\tvalue = tostring(v),\n\t\t\t\t})\n\t\t\tend\n\t\t\tself.tabs.properties.grid:setValues(t)\n\t\t\tself.tabs.properties.grid:draw()\n\n\t\t\tt = { }\n\t\t\tfor k,v in pairs(getmetatable(event.focused)) do\n\t\t\t\tif type(v) == 'function' then\n\t\t\t\t\ttable.insert(t, {\n\t\t\t\t\t\tkey = k,\n\t\t\t\t\t})\n\t\t\t\tend\n\t\t\tend\n\t\t\tself.tabs.methodsTab.grid:setValues(t)\n\t\t\tself.tabs.methodsTab.grid:draw()\n\n\t\telseif event.type == 'edit_property' then\n\t\t\tself.editor.entry.value = event.selected.value\n\t\t\tself.editor:show()\n\n\t\telseif event.type == 'editor_cancel' then\n\t\t\tself.editor:hide()\n\n\t\telseif event.type == 'editor_apply' then\n\t\t\tself.editor:hide()\n\n\t\telseif event.type == 'size' then\n\t\t\tlocal sizing = {\n\t\t\t\t['shift-right'] = {  1,  0 },\n\t\t\t\t['shift-left' ] = { -1,  0 },\n\t\t\t\t['shift-up'   ] = {  0, -1 },\n\t\t\t\t['shift-down' ] = {  0,  1 },\n\t\t\t}\n\t\t\tself.ox = math.max(self.ox + sizing[event.ie.code][1], 1)\n\t\t\tself.oy = math.max(self.oy + sizing[event.ie.code][2], 1)\n\t\t\tUI.term:clear()\n\t\t\tself:resize()\n\t\t\tself:draw()\n\t\tend\n\n\t\treturn UI.Page.eventHandler(self, event)\n\tend\n}\n\nUI:setPage(page)\nUI:start()\n", "sys/apps/PackageManager.lua": "local Ansi     = require('opus.ansi')\nlocal Config   = require('opus.config')\nlocal Packages = require('opus.packages')\nlocal UI       = require('opus.ui')\nlocal Util     = require('opus.util')\n\nlocal colors   = _G.colors\nlocal term     = _G.term\n\nUI:configure('PackageManager', ...)\n\nlocal config = Config.load('package')\n\nlocal page = UI.Page {\n\tgrid = UI.ScrollingGrid {\n\t\tx = 2, ex = 14, y = 2, ey = -6,\n\t\tvalues = { },\n\t\tcolumns = {\n\t\t\t{ heading = 'Package', key = 'name' },\n\t\t},\n\t\tsortColumn = 'name',\n\t\tautospace = true,\n\t\thelp = 'Select a package',\n\t},\n\tadd = UI.Button {\n\t\tx = 2, y = -3,\n\t\ttext = ' + ',\n\t\tevent = 'action',\n\t\thelp = 'Install or update',\n\t},\n\tremove = UI.Button {\n\t\tx = 8, y = -3,\n\t\ttext = ' - ',\n\t\tevent = 'action',\n\t\toperation = 'uninstall',\n\t\toperationText = 'Remove',\n\t\thelp = 'Remove',\n\t},\n\tupdateall = UI.Button {\n\t\tex = -2, y = -3, width = 12,\n\t\ttext = 'Update All',\n\t\tevent = 'updateall',\n\t\thelp = 'Update all installed packages',\n\t},\n\tdescription = UI.TextArea {\n\t\tx = 16, y = 3, ey = -5,\n\t\tmarginRight = 2, marginLeft = 0,\n\t},\n\tUI.Checkbox {\n\t\tx = 3, y = -5,\n\t\tlabel = 'Compress',\n\t\ttextColor = 'yellow',\n\t\tbackgroundColor = 'primary',\n\t\tvalue = config.compression,\n\t\thelp = 'Compress packages (experimental)',\n\t},\n\taction = UI.SlideOut {\n\t\ttitleBar = UI.TitleBar {\n\t\t\tevent = 'hide-action',\n\t\t},\n\t\tbutton = UI.Button {\n\t\t\tx = -10, y = 3,\n\t\t\ttext = ' Begin ', event = 'begin',\n\t\t},\n\t\toutput = UI.Embedded {\n\t\t\ty = 5, ey = -2, x = 2, ex = -2,\n\t\t\tvisible = true,\n\t\t},\n\t},\n\tstatusBar = UI.StatusBar { },\n\taccelerators = {\n\t\t[ 'control-q' ] = 'quit',\n\t},\n}\n\nfunction page:loadPackages()\n\tself.grid.values = { }\n\tself.statusBar:setStatus('Downloading...')\n\tself:sync()\n\n\tfor k in pairs(Packages:list()) do\n\t\tlocal manifest = Packages:getManifest(k)\n\t\tif not manifest then\n\t\t\tmanifest = {\n\t\t\t\tinvalid = true,\n\t\t\t\tdescription = 'Unable to download manifest',\n\t\t\t\ttitle = '',\n\t\t\t}\n\t\tend\n\t\ttable.insert(self.grid.values, {\n\t\t\tinstalled = not not Packages:isInstalled(k),\n\t\t\tname = k,\n\t\t\tmanifest = manifest,\n\t\t})\n\tend\n\tself.grid:update()\n\tself.grid:setIndex(1)\n\tself.grid:emit({\n\t\ttype = 'grid_focus_row',\n\t\tselected = self.grid:getSelected(),\n\t\telement = self.grid,\n\t})\n\tself.statusBar:setStatus('Updated packages')\nend\n\nfunction page.grid:getRowTextColor(row, selected)\n\tif row.installed then\n\t\treturn colors.yellow\n\tend\n\treturn UI.Grid.getRowTextColor(self, row, selected)\nend\n\nfunction page.action:show()\n\tself.output.win:clear()\n\tUI.SlideOut.show(self)\nend\n\nfunction page:run(operation, name)\n\tlocal oterm = term.redirect(self.action.output.win)\n\tself.action.output:clear()\n\tlocal cmd = string.format('package %s %s', operation, name)\n\tterm.setCursorPos(1, 1)\n\tterm.clear()\n\tterm.setTextColor(colors.yellow)\n\tprint(cmd .. '\\n')\n\tterm.setTextColor(colors.white)\n\tlocal s, m = Util.run(_ENV, '/sys/apps/package.lua', operation, name)\n\n\tif not s and m then\n\t\t_G.printError(m)\n\tend\n\tterm.redirect(oterm)\n\tself.action.output:draw()\nend\n\nfunction page:updateSelection(selected)\n\tself.add.operation = selected.installed and 'update' or 'install'\n\tself.add.operationText = selected.installed and 'Update' or 'Install'\n\tself.remove.inactive = not selected.installed\n\tself.add:draw()\n\tself.remove:draw()\nend\n\nfunction page:eventHandler(event)\n\tif event.type == 'focus_change' then\n\t\tself.statusBar:setStatus(event.focused.help)\n\n\telseif event.type == 'grid_focus_row' then\n\t\tlocal manifest = event.selected.manifest\n\n\t\tself.description:setValue(string.format('%s%s\\n\\n%s%s',\n\t\t\tAnsi.yellow, manifest.title,\n\t\t\tAnsi.white, manifest.description))\n\t\tself.description:draw()\n\t\tself:updateSelection(event.selected)\n\n\telseif event.type == 'checkbox_change' then\n\t\tconfig.compression = not config.compression\n\t\tConfig.update('package', config)\n\n\telseif event.type == 'updateall' then\n\t\tself.operation = 'updateall'\n\t\tself.action.button.text = ' Begin '\n\t\tself.action.button.event = 'begin'\n\t\tself.action.titleBar.title = 'Update All'\n\t\tself.action:show()\n\n\telseif event.type == 'action' then\n\t\tlocal selected = self.grid:getSelected()\n\t\tif selected then\n\t\t\tself.operation = event.button.operation\n\t\t\tself.action.button.text = event.button.operationText\n\t\t\tself.action.titleBar.title = selected.manifest.title\n\t\t\tself.action.button.text = ' Begin '\n\t\t\tself.action.button.event = 'begin'\n\t\t\tself.action:show()\n\t\tend\n\n\telseif event.type == 'hide-action' then\n\t\tself.action:hide()\n\n\telseif event.type == 'begin' then\n\t\tif self.operation == 'updateall' then\n\t\t\tself:run(self.operation, '')\n\t\telse\n\t\t\tlocal selected = self.grid:getSelected()\n\t\t\tself:run(self.operation, selected.name)\n\t\t\tselected.installed = Packages:isInstalled(selected.name)\n\n\t\t\tself:updateSelection(selected)\n\t\tend\n\n\t\tself.action.button.text = ' Done  '\n\t\tself.action.button.event = 'hide-action'\n\t\tself.action.button:draw()\n\n\telseif event.type == 'quit' then\n\t\tUI:quit()\n\tend\n\tUI.Page.eventHandler(self, event)\nend\n\nUI:setPage(page)\npage.statusBar:setStatus('Downloading...')\npage:sync()\nPackages:downloadList()\npage:loadPackages()\npage:sync()\n\nUI:start()\n", "sys/apps/System.lua": "local UI     = require('opus.ui')\nlocal Util   = require('opus.util')\n\nlocal fs     = _G.fs\nlocal shell  = _ENV.shell\n\nUI:configure('System', ...)\n\nlocal function loadDirectory(dir)\n\tlocal plugins = { }\n\tfor _, file in pairs(fs.list(dir)) do\n\t\tlocal s, m = Util.run(_ENV, fs.combine(dir, file))\n\t\tif not s and m then\n\t\t\t_G.printError('Error loading: ' .. file)\n\t\t\terror(m or 'Unknown error')\n\t\telseif s and m then\n\t\t\ttable.insert(plugins, { tab = m, name = m.title, description = m.description })\n\t\tend\n\tend\n\treturn plugins\nend\n\nlocal programDir = fs.getDir(_ENV.arg[0])\nlocal plugins = loadDirectory(fs.combine(programDir, 'system'), { })\n\nlocal page = UI.Page {\n\ttabs = UI.Tabs {\n\t\tsettings = UI.Tab {\n\t\t\ttitle = 'Category',\n\t\t\tgrid = UI.ScrollingGrid {\n\t\t\t\tx = 2, y = 2, ex = -2, ey = -2,\n\t\t\t\tcolumns = {\n\t\t\t\t\t{ heading = 'Name',        key = 'name'        },\n\t\t\t\t\t{ heading = 'Description', key = 'description' },\n\t\t\t\t},\n\t\t\t\tsortColumn = 'name',\n\t\t\t\tautospace = true,\n\t\t\t\tvalues = plugins,\n\t\t\t},\n\t\t\taccelerators = {\n\t\t\t\tgrid_select = 'category_select',\n\t\t\t}\n\t\t},\n\t},\n\tnotification = UI.Notification(),\n\taccelerators = {\n\t\t[ 'control-q' ] = 'quit',\n\t},\n\teventHandler = function(self, event)\n\t\tif event.type == 'quit' then\n\t\t\tUI:quit()\n\n\t\telseif event.type == 'category_select' then\n\t\t\tlocal tab = event.selected.tab\n\n\t\t\tif not self.tabs[tab.title] then\n\t\t\t\tself.tabs:add({ [ tab.title ] = tab })\n\t\t\tend\n\t\t\tself.tabs:selectTab(tab)\n\t\t\treturn true\n\n\t\telseif event.type == 'success_message' then\n\t\t\tself.notification:success(event.message)\n\n\t\telseif event.type == 'info_message' then\n\t\t\tself.notification:info(event.message)\n\n\t\telseif event.type == 'error_message' then\n\t\t\tself.notification:error(event.message)\n\n\t\telseif event.type == 'tab_activate' then\n\t\t\tevent.activated:focusFirst()\n\n\t\telse\n\t\t\treturn UI.Page.eventHandler(self, event)\n\t\tend\n\t\treturn true\n\tend,\n}\n\nUI:setPage(page)\nUI:start()\n", "sys/apps/telnet.lua": "local Event    = require('opus.event')\nlocal Socket   = require('opus.socket')\nlocal Terminal = require('opus.terminal')\nlocal Util     = require('opus.util')\n\nlocal multishell = _ENV.multishell\nlocal os         = _G.os\nlocal read       = _G.read\nlocal shell      = _ENV.shell\nlocal term       = _G.term\n\nlocal args, options = Util.parse(...)\n\nlocal remoteId = tonumber(table.remove(args, 1) or '')\nif not remoteId then\n\tprint('Enter host ID')\n\tremoteId = tonumber(read())\nend\n\nif not remoteId then\n\terror('Syntax: telnet ID [PROGRAM] [ARGS]')\nend\n\nif multishell then\n\tmultishell.setTitle(multishell.getCurrent(),\n\t\t(options.s and 'Secure ' or 'Telnet ') .. remoteId)\nend\n\nlocal socket, msg, reason\n\nwhile true do\n\tsocket, msg, reason = Socket.connect(remoteId, options.s and 22 or 23)\n\n\tif socket then\n\t\tbreak\n\telseif reason ~= 'NOTRUST' then\n\t\terror(msg)\n\tend\n\n\tlocal s, m = shell.run('trust ' .. remoteId)\n\tif not s then\n\t\terror(m)\n\tend\nend\n\nlocal ct = Util.shallowCopy(term.current())\nif not ct.isColor() then\n\tTerminal.toGrayscale(ct)\nend\n\nlocal w, h = ct.getSize()\nsocket:write({\n\twidth = w,\n\theight = h,\n\tisColor = ct.isColor(),\n\tprogram = args,\n\tpos = { ct.getCursorPos() },\n})\n\nEvent.addRoutine(function()\n\twhile true do\n\t\tlocal data = socket:read()\n\t\tif not data then\n\t\t\tbreak\n\t\tend\n\t\tfor _,v in ipairs(data) do\n\t\t\tct[v.f](table.unpack(v.args))\n\t\tend\n\tend\nend)\n\n--ct.clear()\n--ct.setCursorPos(1, 1)\n\nlocal filter = Util.transpose {\n\t'char', 'paste', 'key', 'key_up', 'terminate',\n\t'mouse_scroll', 'mouse_click', 'mouse_drag', 'mouse_up',\n}\n\nwhile true do\n\tlocal e = { os.pullEventRaw() }\n\tlocal event = e[1]\n\n\tif filter[event] then\n\t\tsocket:write(e)\n\telse\n\t\tEvent.processEvent(e)\n\tend\n\n\tif not socket.connected then\n--    print()\n--    print('Connection lost')\n--    print('Press enter to exit')\n--    pcall(read)\n\t\tbreak\n\tend\nend\n", "sys/apps/vnc.lua": "local Event      = require('opus.event')\nlocal Socket     = require('opus.socket')\nlocal Terminal   = require('opus.terminal')\nlocal Util       = require('opus.util')\n\nlocal colors     = _G.colors\nlocal multishell = _ENV.multishell\nlocal os         = _G.os\nlocal shell      = _ENV.shell\nlocal term       = _G.term\n\nlocal remoteId\nlocal args, options = Util.parse(...)\nif #args == 1 then\n\tremoteId = tonumber(args[1])\nelse\n\tprint('Enter host ID')\n\tremoteId = tonumber(_G.read())\nend\n\nif not remoteId then\n\terror('Syntax: vnc <host ID>')\nend\n\nif multishell then\n\tmultishell.setTitle(multishell.getCurrent(),\n (options.s and 'SVNC-' or 'VNC-') .. remoteId)\nend\n\nlocal function connect()\n\tlocal socket, msg, reason = Socket.connect(remoteId, options.s and 5901 or 5900)\n\n\tif reason == 'NOTRUST' then\n\t\tlocal s, m = shell.run('trust ' .. remoteId)\n\t\tif not s then\n\t\t\treturn s, m\n\t\tend\n\t\tsocket, msg = Socket.connect(remoteId, 5900)\n\tend\n\n\tif not socket then\n\t\treturn false, msg\n\tend\n\n\tlocal function writeTermInfo()\n\t\tlocal w, h = term.getSize()\n\t\tsocket:write({\n\t\t\ttype = 'termInfo',\n\t\t\twidth = w,\n\t\t\theight = h,\n\t\t\tisColor = term.isColor(),\n\t\t})\n\tend\n\n\twriteTermInfo()\n\n\tlocal ct = Util.shallowCopy(term.current())\n\n\tif not ct.isColor() then\n\t\tTerminal.toGrayscale(ct)\n\tend\n\n\tct.clear()\n\tct.setCursorPos(1, 1)\n\n\tEvent.addRoutine(function()\n\t\twhile true do\n\t\t\tlocal data = socket:read()\n\t\t\tif not data then\n\t\t\t\tbreak\n\t\t\tend\n\t\t\tfor _,v in ipairs(data) do\n\t\t\t\tct[v.f](table.unpack(v.args))\n\t\t\tend\n\t\tend\n\tend)\n\n\tlocal filter = Util.transpose({\n\t\t'char', 'paste', 'key', 'key_up',\n\t\t'mouse_scroll', 'mouse_click', 'mouse_drag', 'mouse_up',\n\t})\n\n\twhile true do\n\t\tlocal e = Event.pullEvent()\n\t\tlocal event = e[1]\n\n\t\tif not socket.connected then\n\t\t\tbreak\n\t\tend\n\n\t\tif filter[event] then\n\t\t\tsocket:write({\n\t\t\t\ttype = 'shellRemote',\n\t\t\t\tevent = e,\n\t\t\t})\n\t\telseif event == 'term_resize' then\n\t\t\twriteTermInfo()\n\t\telseif event == 'terminate' then\n\t\t\tsocket:close()\n\t\t\tct.setBackgroundColor(colors.black)\n\t\t\tct.clear()\n\t\t\tct.setCursorPos(1, 1)\n\t\t\treturn true\n\t\tend\n\tend\n\treturn false, \"Connection Lost\"\nend\n\nwhile true do\n\tterm.clear()\n\tterm.setCursorPos(1, 1)\n\n\tprint('connecting...')\n\tlocal s, m = connect()\n\tif s then\n\t\tbreak\n\tend\n\n\tterm.setBackgroundColor(colors.black)\n\tterm.setTextColor(colors.white)\n\tterm.clear()\n\tterm.setCursorPos(1, 1)\n\tprint(m)\n\tprint('\\nPress any key to exit')\n\tprint('\\nRetrying in ... ')\n\tlocal x, y = term.getCursorPos()\n\tfor i = 5, 1, -1 do\n\t\tlocal timerId = os.startTimer(1)\n\t\tterm.setCursorPos(x, y)\n\t\tterm.write(i)\n\t\trepeat\n\t\t\tlocal e, id = os.pullEvent()\n\t\t\tif e == 'char' or e == 'key' then\n\t\t\t\treturn\n\t\t\tend\n\t\tuntil e == 'timer' and id == timerId\n\tend\nend\n", "sys/apps/password.lua": "local Security = require('opus.security')\nlocal SHA      = require('opus.crypto.sha2')\nlocal Terminal = require('opus.terminal')\n\nlocal password = Terminal.readPassword('Enter new password: ')\n\nif password then\n\tSecurity.updatePassword(SHA.compute(password))\n\tprint('Password updated')\nend\n", "sys/apps/Version.lua": "local Config = require('opus.config')\nlocal UI = require('opus.ui')\n\nlocal shell = _ENV.shell\n\nlocal config = Config.load('version')\nif not config.current then\n    return\nend\n\nUI:setPage(UI.Page {\n    UI.Text {\n        x = 2, y = 2, ex = -2,\n        align = 'center',\n        value = 'Opus has been updated.',\n        textColor = 'yellow',\n    },\n    UI.TextArea {\n        x = 2, y = 4, ey = -8,\n        value = config.details,\n    },\n    UI.Button {\n        x = 2, y = -6, width = 21,\n        event = 'skip',\n        text = 'Skip this version',\n    },\n    UI.Button {\n        x = 2, y = -4, width = 21,\n        event = 'remind',\n        text = 'Remind me tomorrow',\n    },\n    UI.Button {\n        x = 2, y = -2, width = 21,\n        event = 'update',\n        text = 'Update'\n    },\n    eventHandler = function(self, event)\n        if event.type == 'skip' then\n            config.skip = config.current\n            Config.update('version', config)\n            UI:quit()\n\n        elseif event.type == 'remind' then\n            UI:quit()\n\n        elseif event.type == 'update' then\n            shell.openForegroundTab('update update')\n            UI:quit()\n        end\n        return UI.Page.eventHandler(self, event)\n    end,\n})\n\nUI:start()\n", "sys/apps/Help.lua": "local fuzzy = require('opus.fuzzy')\nlocal UI    = require('opus.ui')\nlocal Util  = require('opus.util')\n\nlocal help   = _G.help\n\nUI:configure('Help', ...)\n\nlocal topics = { }\nfor _,topic in pairs(help.topics()) do\n\ttable.insert(topics, { name = topic, lname = topic:lower() })\nend\n\nUI:addPage('main', UI.Page {\n\tUI.Text {\n\t\tx = 3, y = 2,\n\t\tvalue = 'Search',\n\t},\n\tUI.TextEntry {\n\t\tx = 10, y = 2, ex = -3,\n\t\tlimit = 32,\n\t},\n\tgrid = UI.ScrollingGrid {\n\t\ty = 4,\n\t\tvalues = topics,\n\t\tcolumns = {\n\t\t\t{ heading = 'Topic', key = 'name' },\n\t\t},\n\t\tsortColumn = 'lname',\n\t},\n\taccelerators = {\n\t\t[ 'control-q' ] = 'quit',\n\t\tenter = 'grid_select',\n\t},\n\teventHandler = function(self, event)\n\t\tif event.type == 'quit' then\n\t\t\tUI:quit()\n\n\t\telseif event.type == 'grid_select' then\n\t\t\tif self.grid:getSelected() then\n\t\t\t\tUI:setPage('topic', self.grid:getSelected().name)\n\t\t\tend\n\n\t\telseif event.type == 'text_change' then\n\t\t\tif not event.text then\n\t\t\t\tself.grid.sortColumn = 'lname'\n\t\t\telse\n\t\t\t\tself.grid.sortColumn = 'score'\n\t\t\t\tself.grid.inverseSort = false\n\t\t\t\tlocal pattern = event.text:lower()\n\t\t\t\tfor _,v in pairs(self.grid.values) do\n\t\t\t\t\tv.score = -fuzzy(v.lname, pattern)\n\t\t\t\tend\n\t\t\tend\n\t\t\tself.grid:update()\n\t\t\tself.grid:setIndex(1)\n\t\t\tself.grid:draw()\n\n\t\telse\n\t\t\treturn UI.Page.eventHandler(self, event)\n\t\tend\n\tend,\n})\n\nUI:addPage('topic', UI.Page {\n\tbackgroundColor = 'black',\n\ttitleBar = UI.TitleBar {\n\t\ttitle = 'text',\n\t\tevent = 'back',\n\t},\n\thelpText = UI.TextArea {\n\t\tx = 2, ex = -1, y = 3, ey = -2,\n\t},\n\taccelerators = {\n\t\t[ 'control-q' ] = 'back',\n\t\tbackspace = 'back',\n\t},\n\tenable = function(self, name)\n\t\tlocal f = help.lookup(name)\n\n\t\tself.titleBar.title = name\n\t\tself.helpText:setText(f and Util.readFile(f) or 'No help available for ' .. name)\n\n\t\treturn UI.Page.enable(self)\n\tend,\n\teventHandler = function(self, event)\n\t\tif event.type == 'back' then\n\t\t\tUI:setPage('main')\n\t\tend\n\t\treturn UI.Page.eventHandler(self, event)\n\tend,\n})\n\nlocal args = Util.parse(...)\nUI:setPage(args[1] and 'topic' or 'main', args[1])\nUI:start()\n", "sys/apps/trust.lua": "local Crypto   = require('opus.crypto.chacha20')\nlocal Security = require('opus.security')\nlocal SHA      = require('opus.crypto.sha2')\nlocal Socket   = require('opus.socket')\nlocal Terminal = require('opus.terminal')\n\nlocal os = _G.os\n\nlocal remoteId\nlocal args = { ... }\n\nif #args == 1 then\n\tremoteId = tonumber(args[1])\nelse\n\tprint('Enter host ID')\n\tremoteId = tonumber(_G.read())\nend\n\nif not remoteId then\n\terror('Syntax: trust <host ID>')\nend\n\nlocal password = Terminal.readPassword('Enter password: ')\n\nif not password then\n\terror('Invalid password')\nend\n\nprint('connecting...')\nlocal trustId = '01c3ba27fe01383a03a1785276d99df27c3edcef68fbf231ca'\nlocal socket, msg = Socket.connect(remoteId, 19, { identifier = trustId })\n\nif not socket then\n\terror(msg)\nend\n\nlocal identifier = Security.getIdentifier()\n\nsocket:write(Crypto.encrypt({ pk = identifier, dh = os.getComputerID() }, SHA.compute(password)))\n\nlocal data = socket:read(2)\nsocket:close()\n\nif data and data.success then\n\tprint(data.msg)\nelseif data then\n\terror(data.msg)\nelse\n\terror('No response')\nend\n", "sys/apps/autorun.lua": "local Packages = require('opus.packages')\n\nlocal colors     = _G.colors\nlocal fs         = _G.fs\nlocal keys       = _G.keys\nlocal multishell = _ENV.multishell\nlocal os         = _G.os\nlocal shell      = _ENV.shell\nlocal term       = _G.term\n\nlocal success = true\n\nlocal function runDir(directory)\n\tif not fs.exists(directory) then\n\t\treturn true\n\tend\n\n\tlocal files = fs.list(directory)\n\ttable.sort(files)\n\n\tfor _,file in ipairs(files) do\n\t\tos.sleep(0)\n\t\tlocal result, err = shell.run(directory .. '/' .. file)\n\n\t\tif result then\n\t\t\tif term.isColor() then\n\t\t\t\tterm.setTextColor(colors.green)\n\t\t\tend\n\t\t\tterm.write('[PASS] ')\n\t\t\tterm.setTextColor(colors.white)\n\t\t\tterm.write(fs.combine(directory, file))\n\t\t\tprint()\n\t\telse\n\t\t\tif term.isColor() then\n\t\t\t\tterm.setTextColor(colors.red)\n\t\t\tend\n\t\t\tterm.write('[FAIL] ')\n\t\t\tterm.setTextColor(colors.white)\n\t\t\tterm.write(fs.combine(directory, file))\n\t\t\tif err then\n\t\t\t\t_G.printError('\\n' .. err)\n\t\t\tend\n\t\t\tprint()\n\t\t\tsuccess = false\n\t\tend\n\tend\nend\n\nrunDir('sys/autorun')\nfor _, package in pairs(Packages:installedSorted()) do\n\tlocal packageDir = 'packages/' .. package.name .. '/autorun'\n\trunDir(packageDir)\nend\nrunDir('usr/autorun')\n\nif not success then\n\tif multishell then\n\t\tmultishell.setFocus(multishell.getCurrent())\n\tend\n\t_G.printError('A startup program has errored')\n\tprint('Press enter to continue')\n\n\twhile true do\n\t\tlocal e, code = os.pullEventRaw('key')\n\t\tif e == 'terminate' or e == 'key' and code == keys.enter then\n\t\t\tbreak\n\t\tend\n\tend\nend\n\n", "sys/apps/compat.lua": "local Util = require('opus.util')\n\n-- some programs expect to be run in the global scope\n-- ie. busted, moonscript\n\n-- create a new environment mimicing pure lua\n\nlocal fs    = _G.fs\nlocal shell = _ENV.shell\n\nlocal env = Util.shallowCopy(_G)\nUtil.merge(env, _ENV)\nenv._G = env\n\nenv.arg = { ... }\nenv.arg[0] = shell.resolveProgram(table.remove(env.arg, 1) or error('file name is required'))\n\n_G.requireInjector(env, fs.getDir(env.arg[0]))\n\nlocal s, m = Util.run(env, env.arg[0], table.unpack(env.arg))\n\nif not s then\n    error(m, -1)\nend\n", "sys/apps/Network.lua": "local Config = require('opus.config')\nlocal Event  = require('opus.event')\nlocal Socket = require('opus.socket')\nlocal UI     = require('opus.ui')\nlocal Util   = require('opus.util')\n\nlocal device     = _G.device\nlocal network    = _G.network\nlocal shell      = _ENV.shell\n\nUI:configure('Network', ...)\n\nlocal gridColumns = {\n\t{ heading = 'Label',  key = 'label'    },\n\t{ heading = 'Dist',   key = 'distance', align = 'right' },\n\t{ heading = 'Status', key = 'status'   },\n}\n\nlocal config = Config.load('network', { })\n\nif UI.term.width >= 30 then\n\ttable.insert(gridColumns, { heading = 'Fuel',   key = 'fuel', width = 5, align = 'right' })\nend\nif UI.term.width >= 40 then\n\ttable.insert(gridColumns, { heading = 'Uptime', key = 'uptime', align = 'right' })\nend\n\nlocal page = UI.Page {\n\tmenuBar = UI.MenuBar {\n\t\tbuttons = {\n\t\t\t{ text = 'Connect', dropdown = {\n\t\t\t\t{ text = 'Telnet      t', event = 'telnet' },\n\t\t\t\t{ text = 'VNC         v', event = 'vnc'    },\n\t\t\t\t{ spacer = true },\n\t\t\t\t{ text = 'Reboot      r', event = 'reboot' },\n\t\t\t} },\n\t\t\t{ text = 'Trust', dropdown = {\n\t\t\t\t{ text = 'Establish', event = 'trust'   },\n\t\t\t} },\n\t\t\t{\n\t\t\t\ttext = '\\187',\n\t\t\t\tx = -3,\n\t\t\t\tdropdown = {\n\t\t\t\t\t{ text = 'Port Status', event = 'ports', modem = true },\n\t\t\t\t\t{ spacer = true },\n\t\t\t\t\t{ text = 'Help', event = 'help', noCheck = true },\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t},\n\tgrid = UI.ScrollingGrid {\n\t\ty = 2,\n\t\tvalues = network,\n\t\tcolumns = gridColumns,\n\t\tsortColumn = 'label',\n\t\tautospace = true,\n\t\tgetRowTextColor = function(self, row, selected)\n\t\t\tif not row.active then\n\t\t\t\treturn 'lightGray'\n\t\t\tend\n\t\t\treturn UI.Grid.getRowTextColor(self, row, selected)\n\t\tend,\n\t\tgetDisplayValues = function(_, row)\n\t\t\trow = Util.shallowCopy(row)\n\t\t\tif row.uptime then\n\t\t\t\tif row.uptime < 60 then\n\t\t\t\t\trow.uptime = string.format(\"%ds\", math.floor(row.uptime))\n\t\t\t\telseif row.uptime < 3600 then\n\t\t\t\t\trow.uptime = string.format(\"%sm\", math.floor(row.uptime / 60))\n\t\t\t\telse\n\t\t\t\t\trow.uptime = string.format(\"%sh\", math.floor(row.uptime / 3600))\n\t\t\t\tend\n\t\t\tend\n\t\t\tif row.fuel then\n\t\t\t\trow.fuel = row.fuel > 0 and Util.toBytes(row.fuel) or ''\n\t\t\tend\n\t\t\tif row.distance then\n\t\t\t\trow.distance = Util.toBytes(Util.round(row.distance, 1))\n\t\t\tend\n\t\t\treturn row\n\t\tend,\n\t},\n\tports = UI.SlideOut {\n\t\ttitleBar = UI.TitleBar {\n\t\t\ttitle = 'Ports',\n\t\t\tevent = 'ports_hide',\n\t\t},\n\t\tgrid = UI.ScrollingGrid {\n\t\t\ty = 2,\n\t\t\tcolumns = {\n\t\t\t\t{ heading = 'Port',       key = 'port'       },\n\t\t\t\t{ heading = 'State',      key = 'state'      },\n\t\t\t\t{ heading = 'Connection', key = 'connection' },\n\t\t\t},\n\t\t\tsortColumn = 'port',\n\t\t\tautospace = true,\n\t\t},\n\t\teventHandler = function(self, event)\n\t\t\tif event.type == 'grid_select' then\n\t\t\t\tshell.openForegroundTab('Sniff ' .. event.selected.port)\n\t\t\tend\n\t\t\treturn UI.SlideOut.eventHandler(self, event)\n\t\tend,\n\t},\n\tnotification = UI.Notification { },\n\taccelerators = {\n\t\tt = 'telnet',\n\t\tv = 'vnc',\n\t\tr = 'reboot',\n\t\t[ 'control-q' ] = 'quit',\n\t\tc = 'clear',\n\t},\n}\n\nlocal function sendCommand(host, command)\n\tif not device.wireless_modem then\n\t\tpage.notification:error('Wireless modem not present')\n\t\treturn\n\tend\n\n\tpage.notification:info('Connecting')\n\tpage:sync()\n\n\tlocal socket = Socket.connect(host, 161)\n\tif socket then\n\t\tsocket:write({ type = command })\n\t\tsocket:close()\n\t\tpage.notification:success('Command sent')\n\telse\n\t\tpage.notification:error('Failed to connect')\n\tend\nend\n\nfunction page.ports.grid:update()\n\tlocal transport = network:getTransport()\n\n\tlocal function findConnection(port)\n\t\tif transport then\n\t\t\tfor _,socket in pairs(transport.sockets) do\n\t\t\t\tif socket.sport == port then\n\t\t\t\t\treturn socket\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\n\tlocal connections = { }\n\n\tpcall(function() -- guard against modem removal\n\t\tif device.wireless_modem then\n\t\t\tfor i = 0, 65535 do\n\t\t\t\tif device.wireless_modem.isOpen(i) then\n\t\t\t\t\tlocal conn = {\n\t\t\t\t\t\tport = i\n\t\t\t\t\t}\n\t\t\t\t\tlocal socket = findConnection(i)\n\t\t\t\t\tif socket then\n\t\t\t\t\t\tconn.state = 'CONNECTED'\n\t\t\t\t\t\tlocal host = socket.dhost\n\t\t\t\t\t\tif network[host] then\n\t\t\t\t\t\t\thost = network[host].label\n\t\t\t\t\t\tend\n\t\t\t\t\t\tconn.connection = host .. ':' .. socket.dport\n\t\t\t\t\telse\n\t\t\t\t\t\tconn.state = 'LISTEN'\n\t\t\t\t\tend\n\t\t\t\t\ttable.insert(connections, conn)\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend)\n\n\tself.values = connections\n\tUI.Grid.update(self)\nend\n\nfunction page:eventHandler(event)\n\tlocal t = self.grid:getSelected()\n\tif t then\n\t\tif event.type == 'telnet' then\n\t\t\tshell.openForegroundTab('telnet ' .. t.id)\n\n\t\telseif event.type == 'vnc' then\n\t\t\tshell.openForegroundTab('vnc.lua ' .. t.id)\n\t\t\t--[[\n\t\t\tos.queueEvent('overview_shortcut', {\n\t\t\t\ttitle = t.label,\n\t\t\t\tcategory = \"VNC\",\n\t\t\t\ticon = \"\\010\\030 \\009\\009\\031e\\\\\\031   \\031e/\\031dn\\010\\030 \\009\\009 \\031e\\\\/\\031  \\031bc\",\n\t\t\t\trun = \"vnc.lua \" .. t.id,\n\t\t\t})\n\t\t\t--]]\n\n\t\telseif event.type == 'clear' then\n\t\t\tUtil.clear(network)\n\t\t\tpage.grid:update()\n\t\t\tpage.grid:draw()\n\n\t\telseif event.type == 'trust' then\n\t\t\tshell.openForegroundTab('trust ' .. t.id)\n\n\t\telseif event.type == 'reboot' then\n\t\t\tsendCommand(t.id, 'reboot')\n\n\t\telseif event.type == 'shutdown' then\n\t\t\tsendCommand(t.id, 'shutdown')\n\t\tend\n\tend\n\n\tif event.type == 'help' then\n\t\tshell.switchTab(shell.openTab('Help Networking'))\n\n\telseif event.type == 'ports' then\n\t\tself.ports.grid:update()\n\t\tself.ports:show()\n\n\t\tself.portsHandler = Event.onInterval(3, function()\n\t\t\tself.ports.grid:update()\n\t\t\tself.ports.grid:draw()\n\t\t\tself:sync()\n\t\tend)\n\n\telseif event.type == 'ports_hide' then\n\t\tEvent.off(self.portsHandler)\n\t\tself.ports:hide()\n\n\telseif event.type == 'show_trusted' then\n\t\tconfig.showTrusted = true\n\t\tConfig.update('network', config)\n\n\telseif event.type == 'quit' then\n\t\tUI:quit()\n\tend\n\tUI.Page.eventHandler(self, event)\nend\n\nfunction page.menuBar:getActive(menuItem)\n\tlocal t = page.grid:getSelected()\n\tif menuItem.modem then\n\t\treturn not not device.wireless_modem\n\tend\n\treturn menuItem.noCheck or not not t\nend\n\nEvent.onInterval(1, function()\n\tpage.grid:update()\n\tpage.grid:draw()\n\tpage:sync()\nend)\n\nEvent.on('device_attach', function(_, deviceName)\n\tif deviceName == 'wireless_modem' then\n\t\tpage.notification:success('Modem connected')\n\t\tpage:sync()\n\tend\nend)\n\nEvent.on('device_detach', function(_, deviceName)\n\tif deviceName == 'wireless_modem' then\n\t\tpage.notification:error('Wireless modem not attached')\n\t\tpage:sync()\n\tend\nend)\n\nif not device.wireless_modem then\n\tpage.notification:error('Wireless modem not attached')\nend\n\nUI:setPage(page)\nUI:start()\n", "sys/apps/pastebin.lua": "local function printUsage()\n\tprint( \"Usages:\" )\n\tprint( \"pastebin put <filename>\" )\n\tprint( \"pastebin get <code> <filename>\" )\n\tprint( \"pastebin run <code> <arguments>\" )\nend\n\nif not http then\n\tprintError( \"Pastebin requires http API\" )\n\tprintError( \"Set http_enable to true in ComputerCraft.cfg\" )\n\treturn\nend\n\nlocal pastebin = require('opus.http.pastebin')\n\nlocal tArgs = { ... }\nlocal sCommand = tArgs[1]\n\nif sCommand == \"put\" then\n\t-- Upload a file to pastebin.com\n\n\tif #tArgs < 2 then\n\t\tprintUsage()\n\t\treturn\n\tend\n\n\t-- Determine file to upload\n\tlocal sFile = tArgs[2]\n\tlocal sPath = shell.resolve( sFile )\n\tif not fs.exists( sPath ) or fs.isDir( sPath ) then\n\t\tprint( \"No such file\" )\n\t\treturn\n\tend\n\n\tprint( \"Connecting to pastebin.com... \" )\n\n\tlocal resp, msg = pastebin.put(sPath)\n\n\tif resp then\n\t\tprint( \"Uploaded as \" .. resp )\n\t\tprint( \"Run \\\"pastebin get \"..resp..\"\\\" to download anywhere\" )\n\n\telse\n\t\tprintError( msg )\n\tend\n\nelseif sCommand == \"get\" then\n\t-- Download a file from pastebin.com\n\n\tif #tArgs < 3 then\n\t\tprintUsage()\n\t\treturn\n\tend\n\n\tlocal sCode = pastebin.parseCode(tArgs[2])\n\tif not sCode then\n\t\treturn false, \"Invalid pastebin code. The code is the ID at the end of the pastebin.com URL.\"\n\tend\n\n\t-- Determine file to download\n\tlocal sFile = tArgs[3]\n\tlocal sPath = shell.resolve( sFile )\n\tif fs.exists( sPath ) then\n\t\tprintError( \"File already exists\" )\n\t\treturn\n\tend\n\n\tprint( \"Connecting to pastebin.com... \" )\n\n\tlocal resp, msg = pastebin.get(sCode, sPath)\n\n\tif resp then\n\t\tprint( \"Downloaded as \" .. sPath )\n\telse\n\t\tprintError( msg )\n\tend\n\nelseif sCommand == \"run\" then\n\t-- Download and run a file from pastebin.com\n\n\tif #tArgs < 2 then\n\t\tprintUsage()\n\t\treturn\n\tend\n\n\tlocal sCode = pastebin.parseCode(tArgs[2])\n\tif not sCode then\n\t\treturn false, \"Invalid pastebin code. The code is the ID at the end of the pastebin.com URL.\"\n\tend\n\n\tprint( \"Connecting to pastebin.com... \" )\n\n\tlocal res, msg = pastebin.download(sCode)\n\tif not res then\n\t\tprintError( msg )\n\t\treturn res, msg\n\tend\n\n\tres, msg = load(res, sCode, \"t\", _ENV)\n\tif not res then\n\t\tprintError( msg )\n\t\treturn res, msg\n\tend\n\n\tres, msg =  pcall(res, table.unpack(tArgs, 3))\n\tif not res then\n\t\tprintError( msg )\n\tend\nelse\n\n\tprintUsage()\n\treturn\nend\n\n", "sys/apps/Welcome.lua": "local Ansi     = require('opus.ansi')\nlocal Security = require('opus.security')\nlocal SHA      = require('opus.crypto.sha2')\nlocal UI       = require('opus.ui')\n\nlocal colors   = _G.colors\nlocal os       = _G.os\nlocal shell    = _ENV.shell\n\nlocal splashIntro = [[First Time Setup\n\n%sThanks for installing Opus OS. The next screens will prompt you for basic settings for this computer.]]\nlocal labelIntro = [[Set a friendly name for this computer.\n\n%sNo spaces recommended.]]\nlocal passwordIntro = [[A password is required for wireless access.\n\n%sLeave blank to skip.]]\nlocal packagesIntro = [[Setup Complete\n\n%sOpen the package manager to add software to this computer.]]\nlocal contributorsIntro = [[Contributors%s\n\nAnavrins:    Encryption/security/custom apps\nCommunity:   Several selected applications\nhugeblank:   Startup screen improvements\nLDDestroier: Art design + custom apps\nLemmmy:      Application improvements\n\n%sContribute at:%s\nhttps://github.com/kepler155c/opus]]\n\nlocal page = UI.Page {\n\twizard = UI.Wizard {\n\t\tey = -2,\n\t\tsplash = UI.WizardPage {\n\t\t\tindex = 1,\n\t\t\tintro = UI.TextArea {\n\t\t\t\ttextColor = colors.yellow,\n\t\t\t\tinactive = true,\n\t\t\t\tx = 3, ex = -3, y = 2, ey = -2,\n\t\t\t\tvalue = string.format(splashIntro, Ansi.white),\n\t\t\t},\n\t\t},\n\t\tlabel = UI.WizardPage {\n\t\t\tindex = 2,\n\t\t\tlabelText = UI.Text {\n\t\t\t\tx = 3, y = 2,\n\t\t\t\tvalue = 'Label'\n\t\t\t},\n\t\t\tlabel = UI.TextEntry {\n\t\t\t\tx = 9, y = 2, ex = -3,\n\t\t\t\tlimit = 32,\n\t\t\t\tvalue = os.getComputerLabel(),\n\t\t\t},\n\t\t\tintro = UI.TextArea {\n\t\t\t\ttextColor = colors.yellow,\n\t\t\t\tinactive = true,\n\t\t\t\tx = 3, ex = -3, y = 4, ey = -3,\n\t\t\t\tvalue = string.format(labelIntro, Ansi.white),\n\t\t\t},\n\t\t\tvalidate = function (self)\n\t\t\t\tif self.label.value then\n\t\t\t\t\tos.setComputerLabel(self.label.value)\n\t\t\t\tend\n\t\t\t\treturn true\n\t\t\tend,\n\t\t},\n\t\tpassword = UI.WizardPage {\n\t\t\tindex = 3,\n\t\t\tpasswordLabel = UI.Text {\n\t\t\t\tx = 3, y = 2,\n\t\t\t\tvalue = 'Password'\n\t\t\t},\n\t\t\tnewPass = UI.TextEntry {\n\t\t\t\tx = 12, ex = -3, y = 2,\n\t\t\t\tlimit = 32,\n\t\t\t\tmask = true,\n\t\t\t\tshadowText = 'password',\n\t\t\t},\n\t\t\tintro = UI.TextArea {\n\t\t\t\ttextColor = colors.yellow,\n\t\t\t\tinactive = true,\n\t\t\t\tx = 3, ex = -3, y = 5, ey = -3,\n\t\t\t\tvalue = string.format(passwordIntro, Ansi.white),\n\t\t\t},\n\t\t\tvalidate = function (self)\n\t\t\t\tif type(self.newPass.value) == \"string\" and #self.newPass.value > 0 then\n\t\t\t\t\tSecurity.updatePassword(SHA.compute(self.newPass.value))\n\t\t\t\tend\n\t\t\t\treturn true\n\t\t\tend,\n\t\t},\n\t\tpackages = UI.WizardPage {\n\t\t\tindex = 4,\n\t\t\tbutton = UI.Button {\n\t\t\t\tx = 3, y = -3,\n\t\t\t\ttext = 'Open Package Manager',\n\t\t\t\tevent = 'packages',\n\t\t\t},\n\t\t\tintro = UI.TextArea {\n\t\t\t\ttextColor = colors.yellow,\n\t\t\t\tinactive = true,\n\t\t\t\tx = 3, ex = -3, y = 2, ey = -4,\n\t\t\t\tvalue = string.format(packagesIntro, Ansi.white),\n\t\t\t},\n\t\t},\n\t\tcontributors = UI.WizardPage {\n\t\t\tindex = 5,\n\t\t\tintro = UI.TextArea {\n\t\t\t\ttextColor = colors.yellow,\n\t\t\t\tinactive = true,\n\t\t\t\tx = 3, ex = -3, y = 2, ey = -2,\n\t\t\t\tvalue = string.format(contributorsIntro, Ansi.white, Ansi.yellow, Ansi.white),\n\t\t\t},\n\t\t},\n\t},\n\tnotification = UI.Notification { },\n}\n\nfunction page:eventHandler(event)\n\tif event.type == 'skip' then\n\t\tself.wizard:emit({ type = 'nextView' })\n\n\telseif event.type == 'view_enabled' then\n\t\tevent.view:focusFirst()\n\n\telseif event.type == 'packages' then\n\t\tshell.openForegroundTab('PackageManager')\n\n\telseif event.type == 'wizard_complete' or event.type == 'cancel' then\n\t\tUI:quit()\n\n\telse\n\t\treturn UI.Page.eventHandler(self, event)\n\tend\n\treturn true\nend\n\nUI:setPage(page)\nUI:start()\n", "sys/apps/genotp.lua": "local SHA = require(\"opus.crypto.sha2\")\n\nlocal acceptableCharacters = {\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"}\nlocal acceptableCharactersLen = #acceptableCharacters\n   \nlocal password = \"\"\n\nfor _i = 1, 8 do\n    password = password .. acceptableCharacters[math.random(acceptableCharactersLen)]\nend\n\nos.queueEvent(\"set_otp\", SHA.compute(password))\n\nprint(\"Your one-time password is: \" .. password)", "sys/apps/network/samba.lua": "local Event  = require('opus.event')\nlocal Socket = require('opus.socket')\n\nlocal fs = _G.fs\n\nlocal fileUid = 0\nlocal fileHandles = { }\n\nlocal function remoteOpen(fn, fl)\n\tlocal fh = fs.open(fn, fl)\n\tif fh then\n\t\tlocal methods = { 'close', 'write', 'writeLine', 'flush', 'read', 'readLine', 'readAll', }\n\t\tfileUid = fileUid + 1\n\t\tfileHandles[fileUid] = fh\n\n\t\tlocal vfh = {\n\t\t\tmethods = { },\n\t\t\tfileUid = fileUid,\n\t\t}\n\n\t\tfor _,m in ipairs(methods) do\n\t\t\tif fh[m] then\n\t\t\t\ttable.insert(vfh.methods, m)\n\t\t\tend\n\t\tend\n\t\treturn vfh\n\tend\nend\n\nlocal function remoteFileOperation(fileId, op, ...)\n\tlocal fh = fileHandles[fileId]\n\tif fh then\n\t\treturn fh[op](...)\n\tend\nend\n\nlocal function sambaConnection(socket)\n\twhile true do\n\t\tlocal msg = socket:read()\n\t\tif not msg then\n\t\t\tbreak\n\t\tend\n\t\tlocal fn = fs[msg.fn]\n\t\tif msg.fn == 'open' then\n\t\t\tfn = remoteOpen\n\t\telseif msg.fn == 'fileOp' then\n\t\t\tfn = remoteFileOperation\n\t\tend\n\t\tlocal ret\n\t\tlocal s, m = pcall(function()\n\t\t\tret = fn(table.unpack(msg.args))\n\t\tend)\n\t\tif not s and m then\n\t\t\t_G.printError('samba: ' .. m)\n\t\tend\n\t\tsocket:write({ response = ret })\n\tend\n\n\tprint('samba: Connection closed')\nend\n\nEvent.addRoutine(function()\n\tprint('samba: listening on port 139')\n\n\twhile true do\n\t\tlocal socket = Socket.server(139)\n\n\t\tEvent.addRoutine(function()\n\t\t\tprint('samba: connection from ' .. socket.dhost)\n\t\t\tlocal s, m = pcall(sambaConnection, socket)\n\t\t\tprint('samba: closing connection to ' .. socket.dhost)\n\t\t\tsocket:close()\n\t\t\tif not s and m then\n\t\t\t\tprint('Samba error')\n\t\t\t\t_G.printError(m)\n\t\t\tend\n\t\tend)\n\tend\nend)\n\nEvent.on('network_attach', function(_, computer)\n\tfs.mount(fs.combine('network', computer.label), 'netfs', computer.id)\nend)\n\nEvent.on('network_detach', function(_, computer)\n\tprint('samba: detaching ' .. computer.label)\n\tfs.unmount(fs.combine('network', computer.label))\nend)\n", "sys/apps/network/telnet.lua": "local Event  = require('opus.event')\nlocal Socket = require('opus.socket')\nlocal Util   = require('opus.util')\n\nlocal kernel = _G.kernel\nlocal shell  = _ENV.shell\nlocal term   = _G.term\nlocal window = _G.window\n\nlocal function telnetHost(socket, mode)\n\tlocal methods = { 'clear', 'clearLine', 'setCursorPos', 'write', 'blit',\n\t\t\t\t\t\t\t\t\t\t'setTextColor', 'setTextColour', 'setBackgroundColor',\n\t\t\t\t\t\t\t\t\t\t'setBackgroundColour', 'scroll', 'setCursorBlink', }\n\n\tlocal termInfo = socket:read(5)\n\tif not termInfo then\n\t\t_G.printError('read failed')\n\t\treturn\n\tend\n\n\tlocal win = window.create(_G.device.terminal, 1, 1, termInfo.width, termInfo.height, false)\n\twin.setCursorPos(table.unpack(termInfo.pos))\n\n\tfor _,k in pairs(methods) do\n\t\tlocal fn = win[k]\n\t\twin[k] = function(...)\n\n\t\t\tif not socket.queue then\n\t\t\t\tsocket.queue = { }\n\t\t\t\tEvent.onTimeout(0, function()\n\t\t\t\t\tsocket:write(socket.queue)\n\t\t\t\t\tsocket.queue = nil\n\t\t\t\tend)\n\t\t\tend\n\n\t\t\ttable.insert(socket.queue, {\n\t\t\t\tf = k,\n\t\t\t\targs = { ... },\n\t\t\t})\n\t\t\tfn(...)\n\t\tend\n\tend\n\n\tlocal shellThread = kernel.run(_ENV, {\n\t\twindow = win,\n\t\ttitle = mode .. ' client',\n\t\thidden = true,\n\t\tfn = function()\n\t\t\tUtil.run(kernel.makeEnv(_ENV), shell.resolveProgram('shell'), table.unpack(termInfo.program))\n\t\t\tif socket.queue then\n\t\t\t\tsocket:write(socket.queue)\n\t\t\tend\n\t\t\tsocket:close()\n\t\tend,\n\t})\n\n\tEvent.addRoutine(function()\n\t\twhile true do\n\t\t\tlocal data = socket:read()\n\t\t\tif not data then\n\t\t\t\tshellThread:resume('terminate')\n\t\t\t\tbreak\n\t\t\tend\n\t\t\tlocal previousTerm = term.current()\n\t\t\tshellThread:resume(table.unpack(data))\n\t\t\tterm.redirect(previousTerm)\n\t\tend\n\tend)\nend\n\nEvent.addRoutine(function()\n\tprint('ssh: listening on port 22')\n\twhile true do\n\t\tlocal socket = Socket.server(22, { ENCRYPT = true })\n\n\t\tprint('ssh: connection from ' .. socket.dhost)\n\n\t\tEvent.addRoutine(function()\n\t\t\tlocal s, m = pcall(telnetHost, socket, 'SSH')\n\t\t\tif not s and m then\n\t\t\t\tprint('ssh error')\n\t\t\t\t_G.printError(m)\n\t\t\tend\n\t\tend)\n\tend\nend)\n\nEvent.addRoutine(function()\n\tprint('telnet: listening on port 23')\n\twhile true do\n\t\tlocal socket = Socket.server(23)\n\n\t\tprint('telnet: connection from ' .. socket.dhost)\n\n\t\tEvent.addRoutine(function()\n\t\t\tlocal s, m = pcall(telnetHost, socket, 'Telnet')\n\t\t\tif not s and m then\n\t\t\t\tprint('Telnet error')\n\t\t\t\t_G.printError(m)\n\t\t\tend\n\t\tend)\n\tend\nend)\n", "sys/apps/network/snmp.lua": "local Event  = require('opus.event')\nlocal GPS    = require('opus.gps')\nlocal Socket = require('opus.socket')\nlocal Util   = require('opus.util')\n\nlocal device  = _G.device\nlocal kernel  = _G.kernel\nlocal network = _G.network\nlocal os      = _G.os\nlocal turtle  = _G.turtle\n\n-- move this into gps api\nlocal gpsRequested\nlocal gpsLastPoint\nlocal gpsLastRequestTime\n\nlocal function snmpConnection(socket)\n\twhile true do\n\t\tlocal msg = socket:read()\n\t\tif not msg then\n\t\t\tbreak\n\t\tend\n\n\t\tif msg.type == 'reboot' then\n\t\t\tos.reboot()\n\n\t\telseif msg.type == 'shutdown' then\n\t\t\tos.shutdown()\n\n\t\telseif msg.type == 'ping' then\n\t\t\tsocket:write('pong')\n\n\t\telseif msg.type == 'script' then\n\t\t\tkernel.run(_ENV, {\n\t\t\t\tchunk = msg.args,\n\t\t\t\ttitle = 'script',\n\t\t\t})\n\n\t\telseif msg.type == 'scriptEx' then\n\t\t\tlocal s, m = pcall(function()\n\t\t\t\tlocal env = kernel.makeEnv(_ENV)\n\t\t\t\tlocal fn, m = load(msg.args, 'script', nil, env)\n\t\t\t\tif not fn then\n\t\t\t\t\terror(m)\n\t\t\t\tend\n\t\t\t\treturn { fn() }\n\t\t\tend)\n\t\t\tif s then\n\t\t\t\tsocket:write(m)\n\t\t\telse\n\t\t\t\tsocket:write({ s, m })\n\t\t\tend\n\n\t\telseif msg.type == 'gps' then\n\t\t\tif gpsRequested then\n\t\t\t\trepeat\n\t\t\t\t\tos.sleep(0)\n\t\t\t\tuntil not gpsRequested\n\t\t\tend\n\n\t\t\tif gpsLastPoint and os.clock() - gpsLastRequestTime < .5 then\n\t\t\t\tsocket:write(gpsLastPoint)\n\t\t\telse\n\n\t\t\t\tgpsRequested = true\n\t\t\t\tlocal pt = GPS.getPoint(2)\n\t\t\t\tif pt then\n\t\t\t\t\tsocket:write(pt)\n\t\t\t\telse\n\t\t\t\t\tprint('snmp: Unable to get GPS point')\n\t\t\t\tend\n\t\t\t\tgpsRequested = false\n\t\t\t\tgpsLastPoint = pt\n\t\t\t\tif pt then\n\t\t\t\t\tgpsLastRequestTime = os.clock()\n\t\t\t\tend\n\t\t\tend\n\n\t\telseif msg.type == 'info' then\n\t\t\tlocal info = {\n\t\t\t\tid = os.getComputerID(),\n\t\t\t\tlabel = os.getComputerLabel(),\n\t\t\t\tuptime = math.floor(os.clock()),\n\t\t\t}\n\t\t\tif turtle then\n\t\t\t\tinfo.fuel = turtle.getFuelLevel()\n\t\t\t\tinfo.status = turtle.getStatus()\n\t\t\tend\n\t\t\tsocket:write(info)\n\t\tend\n\tend\nend\n\nEvent.addRoutine(function()\n\tprint('snmp: listening on port 161')\n\n\twhile true do\n\t\tlocal socket = Socket.server(161)\n\n\t\tEvent.addRoutine(function()\n\t\t\tprint('snmp: connection from ' .. socket.dhost)\n\t\t\tlocal s, m = pcall(snmpConnection, socket)\n\t\t\tprint('snmp: closing connection to ' .. socket.dhost)\n\t\t\tif not s and m then\n\t\t\t\tprint('snmp error')\n\t\t\t\t_G.printError(m)\n\t\t\tend\n\t\tend)\n\tend\nend)\n\ndevice.wireless_modem.open(999)\nprint('discovery: listening on port 999')\n\nEvent.on('modem_message', function(_, _, sport, id, info, distance)\n\tif sport == 999 and tonumber(id) and type(info) == 'table' then\n\t\tif type(info.label) == 'string' and type(info.id) == 'number' then\n\n\t\t\tif not network[id] then\n\t\t\t\tnetwork[id] = { }\n\t\t\tend\n\t\t\tUtil.merge(network[id], info)\n\t\t\tnetwork[id].distance = type(distance) == 'number' and distance\n\t\t\tnetwork[id].timestamp = os.clock()\n\n\t\t\tif not network[id].label then\n\t\t\t\tnetwork[id].label = 'unknown'\n\t\t\tend\n\n\t\t\tif not network[id].active then\n\t\t\t\tnetwork[id].active = true\n\t\t\t\tos.queueEvent('network_attach', network[id])\n\t\t\tend\n\t\telse\n\t\t\tprint('discovery: Invalid alive message ' .. id)\n\t\tend\n\tend\nend)\n\nlocal info = {\n\tid = os.getComputerID()\n}\nlocal infoTimer = os.clock()\n\nlocal function getSlots()\n\treturn Util.reduce(turtle.getInventory(), function(acc, v)\n\t\tif v.count > 0 then\n\t\t\tacc[v.index .. ',' .. v.count]  = v.key\n\t\tend\n\t\treturn acc\n\tend, { })\nend\n\nlocal function sendInfo()\n\tif os.clock() - infoTimer >= 1 then -- don't flood\n\t\tinfoTimer = os.clock()\n\t\tinfo.label = os.getComputerLabel()\n\t\tinfo.uptime = math.floor(os.clock())\n\t\tinfo.group = network.getGroup()\n\t\tif turtle and turtle.getStatus then\n\t\t\tinfo.fuel = turtle.getFuelLevel()\n\t\t\tinfo.status = turtle.getStatus()\n\t\t\tinfo.point = turtle.point\n\t\t\tinfo.inv = getSlots()\n\t\t\tinfo.slotIndex = turtle.getSelectedSlot()\n\t\tend\n\t\tif device.neuralInterface then\n\t\t\tinfo.status = device.neuralInterface.status\n\t\t\tif not info.status and device.neuralInterface.getMetaOwner then\n\t\t\t\tpcall(function()\n\t\t\t\t\tlocal meta = device.neuralInterface.getMetaOwner()\n\t\t\t\t\tlocal states = {\n\t\t\t\t\t\tisWet = 'Swimming',\n\t\t\t\t\t\tisElytraFlying = 'Flying',\n\t\t\t\t\t\tisBurning = 'Burning',\n\t\t\t\t\t\tisDead = 'Deceased',\n\t\t\t\t\t\tisOnLadder = 'Climbing',\n\t\t\t\t\t\tisRiding = 'Riding',\n\t\t\t\t\t\tisSneaking = 'Sneaking',\n\t\t\t\t\t\tisSprinting = 'Running',\n\t\t\t\t\t}\n\t\t\t\t\tfor k,v in pairs(states) do\n\t\t\t\t\t\tif meta[k] then\n\t\t\t\t\t\t\tinfo.status = v\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\tend\n\t\t\t\t\tend\n\t\t\t\t\tinfo.status = info.status or 'health: ' ..\n\t\t\t\t\t\t\tmath.floor(meta.health / meta.maxHealth * 100)\n\t\t\t\tend)\n\t\t\tend\n\t\tend\n\t\tdevice.wireless_modem.transmit(999, os.getComputerID(), info)\n\tend\nend\n\n-- every 10 seconds, send out this computer's info\nEvent.onInterval(10, function()\n\tsendInfo()\n\tfor _,c in pairs(_G.network) do\n\t\tlocal elapsed = os.clock()-c.timestamp\n\t\tif c.active and elapsed > 15 then\n\t\t\tc.active = false\n\t\t\tos.queueEvent('network_detach', c)\n\t\tend\n\tend\nend)\n\nEvent.on('turtle_response', function()\n\tif turtle.getStatus() ~= info.status or\n\t\t turtle.fuel ~= info.fuel then\n\t\tsendInfo()\n\tend\nend)\n\nEvent.onTimeout(1, sendInfo)\n", "sys/apps/network/vnc.lua": "local Event  = require('opus.event')\nlocal Socket = require('opus.socket')\nlocal Util   = require('opus.util')\n\nlocal os       = _G.os\nlocal terminal = _G.device.terminal\n\nlocal function vncHost(socket)\n\tlocal methods = { 'blit', 'clear', 'clearLine', 'setCursorPos', 'write',\n\t\t\t\t\t\t\t\t\t\t'setTextColor', 'setTextColour', 'setBackgroundColor',\n\t\t\t\t\t\t\t\t\t\t'setBackgroundColour', 'scroll', 'setCursorBlink', }\n\n\tlocal oldTerm = Util.shallowCopy(terminal)\n\n\tfor _,k in pairs(methods) do\n\t\tterminal[k] = function(...)\n\t\t\tif not socket.queue then\n\t\t\t\tsocket.queue = { }\n\t\t\t\tEvent.onTimeout(0, function()\n\t\t\t\t\tsocket:write(socket.queue)\n\t\t\t\t\tsocket.queue = nil\n\t\t\t\tend)\n\t\t\tend\n\t\t\ttable.insert(socket.queue, {\n\t\t\t\tf = k,\n\t\t\t\targs = { ... },\n\t\t\t})\n\t\t\toldTerm[k](...)\n\t\tend\n\tend\n\n\twhile true do\n\t\tlocal data = socket:read()\n\t\tif not data then\n\t\t\tprint('vnc: closing connection to ' .. socket.dhost)\n\t\t\tbreak\n\t\tend\n\n\t\tif data.type == 'shellRemote' then\n\t\t\tos.queueEvent(table.unpack(data.event))\n\t\telseif data.type == 'termInfo' then\n\t\t\tterminal.getSize = function()\n\t\t\t\treturn data.width, data.height\n\t\t\tend\n\t\t\tos.queueEvent('term_resize')\n\t\tend\n\tend\n\n\tfor k,v in pairs(oldTerm) do\n\t\tterminal[k] = v\n\tend\n\tos.queueEvent('term_resize')\nend\n\nEvent.addRoutine(function()\n\n\tprint('vnc: listening on port 5900')\n\n\twhile true do\n\t\tlocal socket = Socket.server(5900)\n\n\t\tprint('vnc: connection from ' .. socket.dhost)\n\n\t\t-- no new process - only 1 connection allowed\n\t\t-- due to term size issues\n\t\tlocal s, m = pcall(vncHost, socket)\n\t\tsocket:close()\n\t\tif not s and m then\n\t\t\tprint('vnc error')\n\t\t\t_G.printError(m)\n\t\tend\n\tend\nend)\n\nEvent.addRoutine(function()\n\n\tprint('svnc: listening on port 5901')\n\n\twhile true do\n\t\tlocal socket = Socket.server(5901, { ENCRYPT = true })\n\n\t\tprint('svnc: connection from ' .. socket.dhost)\n\n\t\t-- no new process - only 1 connection allowed\n\t\t-- due to term size issues\n\t\tlocal s, m = pcall(vncHost, socket)\n\t\tsocket:close()\n\t\tif not s and m then\n\t\t\tprint('vnc error')\n\t\t\t_G.printError(m)\n\t\tend\n\tend\nend)\n", "sys/apps/network/transport.lua": "--[[\n\tLow level socket protocol implementation.\n\n\t* sequencing\n\t* background read buffering\n]]--\n\nlocal Crypto = require('opus.crypto.chacha20')\nlocal Event  = require('opus.event')\n\nlocal network = _G.network\nlocal os = _G.os\n\nlocal computerId = os.getComputerID()\nlocal transport = {\n\ttimers  = { },\n\tsockets = { },\n\tencryptQueue = { },\n\tUID = 0,\n}\n\ngetmetatable(network).__index.getTransport = function()\n\treturn transport\nend\n\nfunction transport.open(socket)\n\ttransport.UID = transport.UID + 1\n\n\ttransport.sockets[socket.sport] = socket\n\tsocket.activityTimer = os.clock()\n\tsocket.uid = transport.UID\nend\n\nfunction transport.read(socket)\n\tlocal data = table.remove(socket.messages, 1)\n\tif data then\n\t\tif socket.options.ENCRYPT then\n\t\t\treturn table.unpack(Crypto.decrypt(data[1], socket.enckey)), data[2]\n\t\tend\n\t\treturn table.unpack(data)\n\tend\nend\n\nfunction transport.write(socket, msg)\n\tif socket.options.ENCRYPT then\n\t\tif #transport.encryptQueue == 0 then\n\t\t\tos.queueEvent('transport_encrypt')\n\t\tend\n\t\ttable.insert(transport.encryptQueue, { socket.sport, msg })\n\telse\n\t\tsocket.transmit(socket.dport, socket.dhost, msg)\n\tend\n\tsocket.wseq = socket.wrng:nextInt(5)\nend\n\nfunction transport.ping(socket)\n\tif os.clock() - socket.activityTimer > 10 then\n\t\tsocket.activityTimer = os.clock()\n\t\tsocket.transmit(socket.dport, socket.dhost, {\n\t\t\t\ttype = 'PING',\n\t\t\t\tseq = -1,\n\t\t\t})\n\n\t\tlocal timerId = os.startTimer(3)\n\t\ttransport.timers[timerId] = socket\n\t\tsocket.timers[-1] = timerId\n\tend\nend\n\nfunction transport.close(socket)\n\ttransport.sockets[socket.sport] = nil\nend\n\nEvent.on('transport_encrypt', function()\n\twhile #transport.encryptQueue > 0 do\n\t\tlocal entry = table.remove(transport.encryptQueue, 1)\n\t\tlocal socket = transport.sockets[entry[1]]\n\n\t\tif socket and socket.connected then\n\t\t\tlocal msg = entry[2]\n\t\t\tmsg.data = Crypto.encrypt({ msg.data }, socket.enckey)\n\t\t\tsocket.transmit(socket.dport, socket.dhost, msg)\n\t\tend\n\tend\nend)\n\nEvent.on('timer', function(_, timerId)\n\tlocal socket = transport.timers[timerId]\n\n\tif socket and socket.connected then\n\t\tprint('transport timeout - closing socket ' .. socket.sport)\n\t\tsocket:close()\n\t\ttransport.timers[timerId] = nil\n\tend\nend)\n\nEvent.on('modem_message', function(_, _, dport, dhost, msg, distance)\n\tif dhost == computerId and type(msg) == 'table' then\n\t\tlocal socket = transport.sockets[dport]\n\t\tif socket and socket.connected then\n\n\t\t\tif socket.co and coroutine.status(socket.co) == 'dead' then\n\t\t\t\t_G._syslog('socket coroutine dead')\n\t\t\t\tsocket:close()\n\n\t\t\telseif msg.type == 'DISC' then\n\t\t\t\t-- received disconnect from other end\n\t\t\t\tif msg.seq == socket.rseq then\n\t\t\t\t\tif socket.connected then\n\t\t\t\t\t\tos.queueEvent('transport_' .. socket.uid)\n\t\t\t\t\tend\n\t\t\t\t\tsocket.connected = false\n\t\t\t\t\tsocket:close()\n\t\t\t\tend\n\n\t\t\telseif msg.type == 'ACK' then\n\t\t\t\tlocal ackTimerId = socket.timers[msg.seq]\n\t\t\t\tif ackTimerId then\n\t\t\t\t\tos.cancelTimer(ackTimerId)\n\t\t\t\t\tsocket.timers[msg.seq] = nil\n\t\t\t\t\tsocket.activityTimer = os.clock()\n\t\t\t\t\ttransport.timers[ackTimerId] = nil\n\t\t\t\tend\n\n\t\t\telseif msg.type == 'PING' then\n\t\t\t\tsocket.activityTimer = os.clock()\n\t\t\t\tsocket.transmit(socket.dport, socket.dhost, {\n\t\t\t\t\ttype = 'ACK',\n\t\t\t\t\tseq = msg.seq,\n\t\t\t\t})\n\n\t\t\telseif msg.type == 'DATA' and msg.data then\n\t\t\t\tif msg.seq ~= socket.rseq then\n\t\t\t\t\tprint('transport seq error ' .. socket.sport)\n\t\t\t\t\t_syslog(msg.data)\n\t\t\t\t\t_syslog('expected ' .. socket.rseq)\n\t\t\t\t\t_syslog('got ' .. msg.seq)\n\t\t\t\telse\n\t\t\t\t\tsocket.activityTimer = os.clock()\n\t\t\t\t\tsocket.rseq = socket.rrng:nextInt(5)\n\n\t\t\t\t\ttable.insert(socket.messages, { msg.data, distance })\n\n\t\t\t\t\tif not socket.messages[2] then  -- table size is 1\n\t\t\t\t\t\tos.queueEvent('transport_' .. socket.uid)\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\nend)\n", "sys/apps/network/proxy.lua": "local Event  = require('opus.event')\nlocal Socket = require('opus.socket')\nlocal Util   = require('opus.util')\n\nlocal function getProxy(path)\n\tlocal x = Util.split(path, '(.-)/')\n\tlocal proxy = _G\n\tfor _, v in pairs(x) do\n\t\tproxy = proxy[v]\n\t\tif not proxy then\n\t\t\tbreak\n\t\tend\n\tend\n\treturn proxy\nend\n\nlocal function proxyConnection(socket)\n\tlocal path = socket:read(2)\n\tif path then\n\t\tlocal api = getProxy(path)\n\n\t\tif not api then\n\t\t\tprint('proxy: invalid API')\n\t\t\tsocket:close()\n\t\t\treturn\n\t\tend\n\n\t\tlocal methods = { }\n\t\tfor k,v in pairs(api) do\n\t\t\tif type(v) == 'function' then\n\t\t\t\ttable.insert(methods, k)\n\t\t\tend\n\t\tend\n\t\tsocket:write(methods)\n\n\t\twhile true do\n\t\t\tlocal data = socket:read()\n\t\t\tif not data then\n\t\t\t\tprint('proxy: lost connection from ' .. socket.dhost)\n\t\t\t\tbreak\n\t\t\tend\n\t\t\tsocket:write({ api[data[1]](table.unpack(data, 2)) })\n\t\tend\n\tend\nend\n\nEvent.addRoutine(function()\n\tprint('proxy: listening on port 188')\n\twhile true do\n\t\tlocal socket = Socket.server(188)\n\n\t\tprint('proxy: connection from ' .. socket.dhost)\n\n\t\tEvent.addRoutine(function()\n\t\t\tlocal s, m = pcall(proxyConnection, socket)\n\t\t\tprint('proxy: closing connection to ' .. socket.dhost)\n\t\t\tsocket:close()\n\t\t\tif not s and m then\n\t\t\t\tprint('Proxy error')\n\t\t\t\t_G.printError(m)\n\t\t\tend\n\t\tend)\n\tend\nend)\n", "sys/apps/network/keygen.lua": "local ECC    = require('opus.crypto.ecc')\nlocal Event  = require('opus.event')\nlocal Util   = require('opus.util')\n\nlocal network = _G.network\nlocal os      = _G.os\n\nlocal keyPairs = { }\n\nlocal function generateKeyPair()\n\tlocal key = { }\n\tfor _ = 1, 32 do\n\t\ttable.insert(key, math.random(0, 0xFF))\n\tend\n\tlocal privateKey = setmetatable(key, Util.byteArrayMT)\n\treturn privateKey, ECC.publicKey(privateKey)\nend\n\ngetmetatable(network).__index.getKeyPair = function()\n\tlocal keys = table.remove(keyPairs)\n\tos.queueEvent('generate_keypair')\n\tif not keys then\n\t\treturn generateKeyPair()\n\tend\n\treturn table.unpack(keys)\nend\n\n-- Generate key pairs in the background as this is a time-consuming process\nEvent.on('generate_keypair', function()\n\twhile true do\n\t\tos.sleep(5)\n\t\tlocal timer = Util.timer()\n\t\ttable.insert(keyPairs, { generateKeyPair() })\n\t\t_G._syslog('Generated keypair in ' .. timer())\n\t\tif #keyPairs >= 3 then\n\t\t\tbreak\n\t\tend\n\tend\nend)\n", "sys/apps/network/trust.lua": "local Crypto   = require('opus.crypto.chacha20')\nlocal Event    = require('opus.event')\nlocal Security = require('opus.security')\nlocal Socket   = require('opus.socket')\nlocal Util     = require('opus.util')\n\nlocal trustId = '01c3ba27fe01383a03a1785276d99df27c3edcef68fbf231ca'\n\nlocal oneTimePassword -- nil by default\n\nlocal function validateData(data, password, dhost)\n\tlocal s\n\ts, data = pcall(Crypto.decrypt, data, password)\n\n\tif s and data and type(data) == \"table\" and data.pk and data.dh == dhost then\n\t\tlocal trustList = Util.readTable('usr/.known_hosts') or { }\n\t\ttrustList[data.dh] = data.pk\n\t\tUtil.writeTable('usr/.known_hosts', trustList)\n\t\treturn true\n\telse\n\t\treturn false\n\tend\nend\n\nlocal function trustConnection(socket)\n\tlocal data = socket:read(2)\n\tif data then\n\t\tlocal password = Security.getPassword()\n\t\tif not password then\n\t\t\tsocket:write({ msg = 'No password has been set' })\n\t\telse\n\t\t\tif validateData(data, password, socket.dhost) then\n\t\t\t\tprint(\"Accepted trust from \" .. socket.dhost)\n\t\t\t\tsocket:write({ success = true, msg = 'Trust accepted' })\n\t\t\t\treturn\n\t\t\tend\n\n\t\t\tif oneTimePassword then\n\t\t\t\tif validateData(data, oneTimePassword, socket.dhost) then\n\t\t\t\t\tprint(\"Accepted trust from \" .. socket.dhost .. \"using one-time password\")\n\t\t\t\t\tsocket:write({ success = true, msg = 'Trust accepted - this one-time password will not be usable again' })\n\t\t\t\t\toneTimePassword = nil -- Make sure nobody can use the one-time password again\n\t\t\t\t\treturn\n\t\t\t\tend\n\t\t\tend\n\n\t\t\tsocket:write({ msg = 'Invalid password' })\n\t\tend\n\tend\nend\n\nEvent.addRoutine(function()\n\tprint('trust: listening on port 19')\n\n\twhile true do\n\t\tlocal socket = Socket.server(19, { identifier = trustId })\n\n\t\tprint('trust: connection from ' .. socket.dhost)\n\n\t\tlocal s, m = pcall(trustConnection, socket)\n\t\tsocket:close()\n\t\tif not s and m then\n\t\t\tprint('Trust error')\n\t\t\t_G.printError(m)\n\t\tend\n\tend\nend)\n\nEvent.addRoutine(function()\n\twhile true do\n\t\tlocal _event, password = os.pullEvent(\"set_otp\")\n\n\t\toneTimePassword = password\n\t\tprint(\"got new one-time password\")\n\tend\nend)", "sys/apps/system/launcher.lua": "local Config = require('opus.config')\nlocal UI     = require('opus.ui')\n\nlocal colors = _G.colors\nlocal fs     = _G.fs\n\nlocal config = Config.load('multishell')\n\nlocal tab = UI.Tab {\n\ttitle = 'Launcher',\n\tdescription = 'Set the application launcher',\n\t[1] = UI.Window {\n\t\tx = 2, y = 2, ex = -2, ey = 5,\n\t},\n\tlauncherLabel = UI.Text {\n\t\tx = 3, y = 3,\n\t\tvalue = 'Launcher',\n\t},\n\tlauncher = UI.Chooser {\n\t\tx = 13, y = 3, width = 12,\n\t\tchoices = {\n\t\t\t{ name = 'Overview', value = 'sys/apps/Overview.lua' },\n\t\t\t{ name = 'Shell',    value = 'sys/apps/ShellLauncher.lua'    },\n\t\t\t{ name = 'Custom',   value = 'custom'                },\n\t\t},\n\t},\n\tcustom = UI.TextEntry {\n\t\tx = 13, ex = -3, y = 4,\n\t\tshadowText = 'File name',\n\t},\n\tbutton = UI.Button {\n\t\tx = -8, ex = -2, y = -2,\n\t\ttext = 'Apply',\n\t\tevent = 'update',\n\t},\n\tlabelText = UI.TextArea {\n\t\tx = 2, ex = -2, y = 6, ey = -4,\n\t\tbackgroundColor = colors.black,\n\t\ttextColor = colors.yellow,\n\t\tmarginLeft = 1, marginRight = 1, marginTop = 1,\n\t\tvalue = 'Choose an application launcher',\n\t},\n}\n\nfunction tab:enable()\n\tlocal launcher = config.launcher and 'custom' or 'sys/apps/Overview.lua'\n\n\tfor _, v in pairs(self.launcher.choices) do\n\t\tif v.value == config.launcher then\n\t\t\tlauncher = v.value\n\t\t\tbreak\n\t\tend\n\tend\n\n\tUI.Tab.enable(self)\n\n\tself.launcher.value = launcher\n\tself.custom.enabled = launcher == 'custom'\nend\n\nfunction tab:eventHandler(event)\n\tif event.type == 'choice_change' then\n\t\tself.custom.enabled = event.value == 'custom'\n\t\tif self.custom.enabled then\n\t\t\tself.custom.value = config.launcher\n\t\tend\n\t\tself:draw()\n\n\telseif event.type == 'update' then\n\t\tlocal launcher\n\n\t\tif self.launcher.value ~= 'custom' then\n\t\t\tlauncher = self.launcher.value\n\t\telseif fs.exists(self.custom.value) and not fs.isDir(self.custom.value) then\n\t\t\tlauncher = self.custom.value\n\t\tend\n\n\t\tif launcher then\n\t\t\tconfig.launcher = launcher\n\t\t\tConfig.update('multishell', config)\n\t\t\tself:emit({ type = 'success_message', message = 'Updated' })\n\t\telse\n\t\t\tself:emit({ type = 'error_message', message = 'Invalid file' })\n\t\tend\n\tend\nend\n\nreturn tab\n", "sys/apps/system/settings.lua": "local UI = require('opus.ui')\n\nlocal settings = _G.settings\n\nlocal transform = {\n\tstring = tostring,\n\tnumber = tonumber,\n}\n\nreturn settings and UI.Tab {\n\ttitle = 'Settings',\n\tdescription = 'Computercraft settings',\n\tgrid = UI.Grid {\n\t\tx = 2, y = 2, ex = -2, ey = -2,\n\t\tsortColumn = 'name',\n\t\tcolumns = {\n\t\t\t{ heading = 'Setting',   key = 'name' },\n\t\t\t{ heading = 'Value', key = 'value'  },\n\t\t},\n\t},\n\teditor = UI.SlideOut {\n\t\ty = -6, height = 6,\n\t\ttitleBar = UI.TitleBar {\n\t\t\tevent = 'slide_hide',\n\t\t\ttitle = 'Enter value',\n\t\t},\n\t\tform = UI.Form {\n\t\t\ty = 2,\n\t\t\tvalue = UI.TextEntry {\n\t\t\t\tformIndex = 1,\n\t\t\t\tformLabel = 'Value',\n\t\t\t\tformKey = 'value',\n\t\t\t},\n\t\t\tvalidateField = function(self, entry)\n\t\t\t\tif entry.value then\n\t\t\t\t\treturn transform[self.type](entry.value)\n\t\t\t\tend\n\t\t\t\treturn true\n\t\t\tend,\n\t\t},\n\t\taccelerators = {\n\t\t\tform_cancel = 'slide_hide',\n\t\t},\n\t\tshow = function(self, entry)\n\t\t\tself.form.type = type(entry.value) or 'string'\n\t\t\tself.form:setValues(entry)\n\t\t\tself.titleBar.title = entry.name\n\t\t\tUI.SlideOut.show(self)\n\t\tend,\n\t\teventHandler = function(self, event)\n\t\t\tif event.type == 'form_complete' then\n\t\t\t\tif not event.values.value then\n\t\t\t\t\tsettings.unset(event.values.name)\n\t\t\t\t\tself.parent:reload()\n\t\t\t\telse\n\t\t\t\t\tevent.values.value = transform[self.form.type](event.values.value)\n\t\t\t\t\tsettings.set(event.values.name, event.values.value)\n\t\t\t\tend\n\t\t\t\tself.parent.grid:draw()\n\t\t\t\tself:hide()\n\t\t\t\tsettings.save('.settings')\n\t\t\tend\n\t\t\treturn UI.SlideOut.eventHandler(self, event)\n\t\tend,\n\t},\n\treload = function(self)\n\t\tlocal values = { }\n\t\tfor _,v in pairs(settings.getNames()) do\n\t\t\ttable.insert(values, {\n\t\t\t\tname = v,\n\t\t\t\tvalue = settings.get(v) or false,\n\t\t\t})\n\t\tend\n\t\tself.grid:setValues(values)\n\t\tself.grid:setIndex(1)\n\tend,\n\tenable = function(self)\n\t\tself:reload()\n\t\tUI.Tab.enable(self)\n\tend,\n\teventHandler = function(self, event)\n\t\tif event.type == 'grid_select' then\n\t\t\tif type(event.selected.value) == 'boolean' then\n\t\t\t\tevent.selected.value = not event.selected.value\n\t\t\t\tsettings.set(event.selected.name, event.selected.value)\n\t\t\t\tsettings.save('.settings')\n\t\t\t\tself.grid:draw()\n\t\t\telse\n\t\t\t\tself.editor:show(event.selected)\n\t\t\tend\n\t\t\treturn true\n\t\tend\n\tend,\n}\n", "sys/apps/system/shell.lua": "local Config = require('opus.config')\nlocal UI     = require('opus.ui')\nlocal Util   = require('opus.util')\n\nlocal colors = _G.colors\nlocal os     = _G.os\n\nlocal config = Config.load('shellprompt')\n\nlocal allColors = { }\nfor k,v in pairs(colors) do\n\tif type(v) == 'number' then\n\t\ttable.insert(allColors, { name = k, value = v })\n\tend\nend\n\nlocal defaults = {\n\ttextColor = colors.white,\n\tcommandTextColor = colors.yellow,\n\tdirectoryTextColor  = colors.orange,\n\tpromptTextColor = colors.blue,\n\tdirectoryColor = colors.green,\n\tfileColor = colors.white,\n\tbackgroundColor = colors.black,\n}\nlocal _colors = config.color or Util.shallowCopy(defaults)\n\nlocal allSettings = { }\nfor k in pairs(defaults) do\n\ttable.insert(allSettings, { name = k })\nend\n\n-- temp\nif not _colors.backgroundColor then\n\t_colors.backgroundColor = colors.black\n\t_colors.fileColor = colors.white\nend\n\nreturn UI.Tab {\n\ttitle = 'Shell',\n\tdescription = 'Shell options',\n\tgrid1 = UI.ScrollingGrid {\n\t\ty = 2, ey = -10, x = 2, ex = -17,\n\t\tdisableHeader = true,\n\t\tcolumns = { { key = 'name' } },\n\t\tvalues = allSettings,\n\t\tsortColumn = 'name',\n\t},\n\tgrid2 = UI.ScrollingGrid {\n\t\ty = 2, ey = -10, x = -14, ex = -2,\n\t\tdisableHeader = true,\n\t\tcolumns = { { key = 'name' } },\n\t\tvalues = allColors,\n\t\tsortColumn = 'name',\n\t\tgetRowTextColor = function(self, row)\n\t\t\tlocal selected = self.parent.grid1:getSelected()\n\t\t\tif _colors[selected.name] == row.value then\n\t\t\t\treturn colors.yellow\n\t\t\tend\n\t\t\treturn UI.Grid.getRowTextColor(self, row)\n\t\tend\n\t},\n\tdirectory = UI.Checkbox {\n\t\tx = 2, y = -2,\n\t\tlabelBackgroundColor = colors.black,\n\t\tlabel = 'Directory',\n\t\tvalue = config.displayDirectory\n\t},\n\treset = UI.Button {\n\t\tx = -18, y = -2,\n\t\ttext = 'Reset',\n\t\tevent = 'reset',\n\t},\n\tbutton = UI.Button {\n\t\tx = -9, y = -2,\n\t\ttext = 'Update',\n\t\tevent = 'update',\n\t},\n\tdisplay = UI.Window {\n\t\tx = 2, ex = -2, y = -8, height = 5,\n\t\tdraw = function(self)\n\t\t\tself:clear(_colors.backgroundColor)\n\t\t\tlocal offset = 0\n\t\t\tif config.displayDirectory then\n\t\t\t\tself:write(1, 1,\n\t\t\t\t\t'==' .. os.getComputerLabel() .. ':/dir/etc',\n\t\t\t\t\t_colors.backgroundColor, _colors.directoryTextColor)\n\t\t\t\toffset = 1\n\t\t\tend\n\n\t\t\tself:write(1, 1 + offset, '$ ',\n\t\t\t\t_colors.backgroundColor, _colors.promptTextColor)\n\n\t\t\tself:write(3, 1 + offset, 'ls /',\n\t\t\t\t_colors.backgroundColor, _colors.commandTextColor)\n\n\t\t\tself:write(1, 2 + offset, 'sys    usr',\n\t\t\t\t_colors.backgroundColor, _colors.directoryColor)\n\n\t\t\tself:write(1, 3 + offset, 'startup',\n\t\t\t\t_colors.backgroundColor, _colors.fileColor)\n\t\tend,\n\t},\n\teventHandler = function(self, event)\n\t\tif event.type =='checkbox_change' then\n\t\t\tconfig.displayDirectory = not not event.checked\n\t\t\tself.display:draw()\n\n\t\telseif event.type == 'grid_focus_row' and event.element == self.grid1 then\n\t\t\tself.grid2:draw()\n\n\t\telseif event.type == 'grid_select' and event.element == self.grid2 then\n\t\t\t_colors[self.grid1:getSelected().name] = event.selected.value\n\t\t\tself.display:draw()\n\t\t\tself.grid2:draw()\n\n\t\telseif event.type == 'reset' then\n\t\t\tconfig.color = defaults\n\t\t\tconfig.displayDirectory = true\n\t\t\tself.directory.value = true\n\t\t\t_colors = Util.shallowCopy(defaults)\n\n\t\t\tConfig.update('shellprompt', config)\n\t\t\tself:draw()\n\n\t\telseif event.type == 'update' then\n\t\t\tconfig.color = _colors\n\t\t\tConfig.update('shellprompt', config)\n\n\t\tend\n\t\treturn UI.Tab.eventHandler(self, event)\n\tend\n}\n", "sys/apps/system/label.lua": "local UI   = require('opus.ui')\nlocal Util = require('opus.util')\n\nlocal fs   = _G.fs\nlocal os   = _G.os\n\nreturn UI.Tab {\n\ttitle = 'Label',\n\tdescription = 'Set the computer label',\n\tlabelText = UI.Text {\n\t\tx = 3, y = 3,\n\t\tvalue = 'Label'\n\t},\n\tlabel = UI.TextEntry {\n\t\tx = 9, y = 3, ex = -4,\n\t\tlimit = 32,\n\t\tvalue = os.getComputerLabel(),\n\t\taccelerators = {\n\t\t\tenter = 'update_label',\n\t\t},\n\t},\n\t[1] = UI.Window {\n\t\tx = 2, y = 2, ex = -2, ey = 4,\n\t},\n\tgrid = UI.ScrollingGrid {\n\t\tx = 2, y = 5, ex = -2, ey = -2,\n\t\tvalues = {\n\t\t\t{ name = '',  value = ''                  },\n\t\t\t{ name = 'CC version',  value = Util.getVersion()                  },\n\t\t\t{ name = 'Lua version', value = _VERSION                           },\n\t\t\t{ name = 'MC version',  value = Util.getMinecraftVersion()         },\n\t\t\t{ name = 'Disk free',   value = Util.toBytes(fs.getFreeSpace('/')) },\n\t\t\t{ name = 'Computer ID', value = tostring(os.getComputerID())       },\n\t\t\t{ name = 'Day',         value = tostring(os.day())                 },\n\t\t},\n\t\tdisableHeader = true,\n\t\tinactive = true,\n\t\tcolumns = {\n\t\t\t{ key = 'name',  width = 12 },\n\t\t\t{ key = 'value', textColor = colors.yellow },\n\t\t},\n\t},\n\teventHandler = function(self, event)\n\t\tif event.type == 'update_label' and self.label.value then\n\t\t\tos.setComputerLabel(self.label.value)\n\t\t\tself:emit({ type = 'success_message', message = 'Label updated' })\n\t\t\treturn true\n\t\tend\n\tend,\n}\n", "sys/apps/system/theme.lua": "local Config = require('opus.config')\nlocal UI     = require('opus.ui')\nlocal Util   = require('opus.util')\n\nlocal colors = _G.colors\n\nlocal allColors = { }\nfor k,v in pairs(colors) do\n\tif type(v) == 'number' then\n\t\ttable.insert(allColors, { name = k, value = v })\n\tend\nend\n\nlocal allSettings = { }\nfor k,v in pairs(UI.theme.colors) do\n\tallSettings[k] = { name = k, value = v }\nend\n\nreturn UI.Tab {\n\ttitle = 'Theme',\n\tdescription = 'Theme colors',\n\tgrid1 = UI.ScrollingGrid {\n\t\ty = 2, ey = -10, x = 2, ex = -17,\n\t\tdisableHeader = true,\n\t\tcolumns = { { key = 'name' } },\n\t\tvalues = allSettings,\n\t\tsortColumn = 'name',\n\t},\n\tgrid2 = UI.ScrollingGrid {\n\t\ty = 2, ey = -10, x = -14, ex = -2,\n\t\tdisableHeader = true,\n\t\tcolumns = { { key = 'name' } },\n\t\tvalues = allColors,\n\t\tsortColumn = 'name',\n\t\tgetRowTextColor = function(self, row)\n\t\t\tlocal selected = self.parent.grid1:getSelected()\n\t\t\tif selected.value == row.value then\n\t\t\t\treturn colors.yellow\n\t\t\tend\n\t\t\treturn UI.Grid.getRowTextColor(self, row)\n\t\tend\n\t},\n\tbutton = UI.Button {\n\t\tx = -9, y = -2,\n\t\ttext = 'Update',\n\t\tevent = 'update',\n\t},\n\tdisplay = UI.Window {\n\t\tx = 2, ex = -2, y = -8, height = 5,\n\t\ttextColor = colors.black,\n\t\tbackgroundColor = colors.black,\n\t\tdraw = function(self)\n\t\t\tself:clear()\n\n\t\t\tself:write(1, 1, Util.widthify(' Local  Global  Device', self.width),\n\t\t\t\tallSettings.secondary.value)\n\n\t\t\tself:write(2, 2, 'enter command ',\n\t\t\t\tcolors.black, colors.gray)\n\n\t\t\tself:write(1, 3, ' Formatted ',\n\t\t\t\tallSettings.primary.value)\n\n\t\t\tself:write(12, 3, Util.widthify(' Output ', self.width - 11),\n\t\t\t\tallSettings.tertiary.value)\n\n\t\t\tself:write(1, 4, Util.widthify(' Key', self.width),\n\t\t\t\tallSettings.primary.value)\n\t\tend,\n\t},\n\teventHandler = function(self, event)\n\t\tif event.type == 'grid_focus_row' and event.element == self.grid1 then\n\t\t\tself.grid2:draw()\n\n\t\telseif event.type == 'grid_select' and event.element == self.grid2 then\n\t\t\tself.grid1:getSelected().value = event.selected.value\n\t\t\tself.display:draw()\n\t\t\tself.grid2:draw()\n\n\t\telseif event.type == 'update' then\n\t\t\tlocal config = Config.load('ui.theme', { colors = { } })\n\t\t\tfor k,v in pairs(allSettings) do\n\t\t\t\tconfig.colors[k] = v.value\n\t\t\tend\n\t\t\tConfig.update('ui.theme', config)\n\t\tend\n\t\treturn UI.Tab.eventHandler(self, event)\n\tend\n}\n", "sys/apps/system/path.lua": "local Config = require('opus.config')\nlocal UI     = require('opus.ui')\nlocal Util   = require('opus.util')\n\nlocal tab = UI.Tab {\n\ttitle = 'Path',\n\tdescription = 'Set the shell path',\n\ttabClose = true,\n\t[1] = UI.Window {\n\t\tx = 2, y = 2, ex = -2, ey = 4,\n\t},\n\tentry = UI.TextEntry {\n\t\tx = 3, y = 3, ex = -3,\n\t\tshadowText = 'enter new path',\n\t\taccelerators = {\n\t\t\tenter = 'update_path',\n\t\t},\n\t\thelp = 'add a new path',\n\t},\n\tgrid = UI.Grid {\n\t\tx = 2, y = 6, ex = -2, ey = -3,\n\t\tdisableHeader = true,\n\t\tcolumns = { { key = 'value' } },\n\t\tautospace = true,\n\t\tsortColumn = 'index',\n\t\thelp = 'double-click to remove, shift-arrow to move',\n\t\taccelerators = {\n\t\t\tdelete = 'remove',\n\t\t},\n\t},\n\tstatusBar = UI.StatusBar { },\n\taccelerators = {\n\t\t[ 'shift-up' ] = 'move_up',\n\t\t[ 'shift-down' ] = 'move_down',\n\t},\n}\n\nfunction tab:updateList(path)\n\tself.grid.values = { }\n\tfor k,v in ipairs(Util.split(path, '(.-):')) do\n\t\ttable.insert(self.grid.values, { index = k, value = v })\n\tend\n\tself.grid:update()\nend\n\nfunction tab:enable()\n\tlocal env = Config.load('shell')\n\tself:updateList(env.path)\n\tUI.Tab.enable(self)\nend\n\nfunction tab:save()\n\tlocal t = { }\n\tfor _, v in ipairs(self.grid.values) do\n\t\ttable.insert(t, v.value)\n\tend\n\tlocal env = Config.load('shell')\n\tenv.path = table.concat(t, ':')\n\tself:updateList(env.path)\n\tConfig.update('shell', env)\nend\n\nfunction tab:eventHandler(event)\n\tif event.type == 'update_path' and self.entry.value then\n\t\ttable.insert(self.grid.values, {\n\t\t\tvalue = self.entry.value,\n\t\t})\n\t\tself:save()\n\t\tself.entry:reset()\n\t\tself.entry:draw()\n\t\tself.grid:draw()\n\t\treturn true\n\n\telseif event.type == 'grid_select' or event.type == 'remove' then\n\t\tlocal selected = self.grid:getSelected()\n\t\tif selected then\n\t\t\ttable.remove(self.grid.values, selected.index)\n\t\t\tself:save()\n\t\t\tself.grid:draw()\n\t\tend\n\n\telseif event.type == 'focus_change' then\n\t\tself.statusBar:setStatus(event.focused.help)\n\n\telseif event.type == 'move_up' then\n\t\tlocal entry = self.grid:getSelected()\n\t\tif entry.index > 1 then\n\t\t\ttable.insert(self.grid.values, entry.index - 1, table.remove(self.grid.values, entry.index))\n\t\t\tself.grid:setIndex(entry.index - 1)\n\t\t\tself:save()\n\t\t\tself.grid:draw()\n\t\tend\n\n\telseif event.type == 'move_down' then\n\t\tlocal entry = self.grid:getSelected()\n\t\tif entry.index < #self.grid.values then\n\t\t\ttable.insert(self.grid.values, entry.index + 1, table.remove(self.grid.values, entry.index))\n\t\t\tself.grid:setIndex(entry.index + 1)\n\t\t\tself:save()\n\t\t\tself.grid:draw()\n\t\tend\n\tend\nend\n\nreturn tab\n", "sys/apps/system/diskusage.lua": "local UI     = require('opus.ui')\nlocal Event  = require('opus.event')\nlocal NFT    = require('opus.nft')\n\nlocal colors     = _G.colors\nlocal fs         = _G.fs\nlocal os         = _G.os\nlocal peripheral = _G.peripheral\n\nlocal NftImages = {\n\tblank = '\\0308\\0317\\153\\153\\153\\153\\153\\153\\153\\153\\010\\0307\\0318\\153\\153\\153\\153\\153\\153\\153\\153\\010\\0308\\0317\\153\\153\\153\\153\\153\\153\\153\\153\\010\\0307\\0318\\153\\153\\153\\153\\153\\153\\153\\153\\010\\0308\\0317\\153\\153\\153\\153\\153\\153\\153\\153',\n\tdrive = '\\030 \\031  \\030b\\031b\\128\\0308\\0318\\128\\128\\030f\\149\\030b\\149\\031 \\139\\010\\030 \\031  \\030b\\031b\\128\\128\\128\\128\\128\\128\\010\\030 \\031  \\030b\\031b\\128\\0300\\0317____\\030b\\031b\\128\\010\\030 \\031  \\030b\\031b\\128\\0300\\0317____\\030b\\031b\\128',\n\tram   = '\\030 \\031 \\128\\0318\\144\\144\\144\\144\\144\\031 \\128\\010\\0308\\031 \\157\\0307\\0317\\128\\128\\128\\128\\128\\030 \\0318\\145\\010\\030 \\0318\\136\\0307\\0317\\128\\0307\\0310RAM\\0307\\128\\030 \\0318\\132\\010\\0308\\031 \\157\\0307\\0317\\128\\128\\128\\128\\128\\030 \\0318\\145\\010\\030 \\031 \\128\\0318\\129\\129\\129\\129\\129\\031 \\128',\n\trom   = '\\030 \\031 \\128\\0318\\144\\144\\144\\144\\144\\031 \\128\\010\\0308\\031 \\157\\0307\\0317\\128\\128\\128\\128\\128\\030 \\0318\\145\\010\\030 \\0318\\136\\0307\\0317\\128\\0307\\0310ROM\\0307\\128\\030 \\0318\\132\\010\\0308\\031 \\157\\0307\\0317\\128\\128\\128\\128\\128\\030 \\0318\\145\\010\\030 \\031 \\128\\0318\\129\\129\\129\\129\\129\\031 \\128',\n\thdd   = '\\030 \\031  \\0307\\0317\\128\\0300\\135\\131\\139\\0307\\128\\010\\030 \\031  \\0300\\0317\\149\\0310\\128\\0307\\131\\0300\\128\\0307\\149\\010\\030 \\031  \\0307\\0310\\130\\0300\\0317\\144\\0308\\0310\\133\\0307\\159\\129\\010\\030 \\031  \\0308\\0317\\149\\129\\142\\159\\0307\\128\\010\\030 \\031  \\030 \\0317\\143\\143\\143\\143\\143',\n}\n\nlocal tab = UI.Tab {\n\ttitle = 'Disks Usage',\n\tdescription = 'Visualise HDD and disks usage',\n\n\tdrives = UI.ScrollingGrid {\n\t\tx = 2, y = 2,\n\t\tex = '47%', ey = -8,\n\t\tcolumns = {\n\t\t\t{ heading = 'Drive', key = 'name' },\n\t\t\t{ heading = 'Side' ,key = 'side', textColor = colors.yellow }\n\t\t},\n\t\tsortColumn = 'name',\n\t},\n\tinfos = UI.Grid {\n\t\tx = '52%', y = 2,\n\t\tex = -2, ey = -8,\n\t\tdisableHeader = true,\n\t\tunfocusedBackgroundSelectedColor = colors.black,\n\t\tinactive = true,\n\t\tbackgroundSelectedColor = colors.black,\n\t\tcolumns = {\n\t\t\t{ key = 'name' },\n\t\t\t{ key = 'value', align = 'right', textColor = colors.yellow },\n\t\t}\n\t},\n\t[1] = UI.Window {\n\t\tx = 2, y = -6, ex = -2, ey = -2,\n\t\tbackgroundColor = colors.black,\n\t},\n\tprogress = UI.ProgressBar {\n\t\tx = 11, y = -3,\n\t\tex = -3,\n\t},\n\tpercentage = UI.Text {\n\t\ty = -4, width = 5,\n\t\tx = 12,\n\t\t--align = 'center',\n\t\tbackgroundColor = colors.black,\n\t},\n\ticon = UI.NftImage {\n\t\tx = 2, y = -6, ey = -2,\n\t\tbackgroundColor = colors.black,\n\t\timage = NFT.parse(NftImages.blank)\n\t},\n}\n\nlocal function getDrives()\n\tlocal unique = { ['hdd'] = true, ['virt'] = true }\n\tlocal drives = { { name = 'hdd', side = '' } }\n\n\tfor _, drive in pairs(fs.list('/')) do\n\t\tlocal side = fs.getDrive(drive)\n\t\tif side and not unique[side] then\n\t\t\tunique[side] = true\n\t\t\ttable.insert(drives, { name = drive, side = side })\n\t\tend\n\tend\n\treturn drives\nend\n\nlocal function getDriveInfo(p)\n\tlocal files, dirs, total = 0, 0, 0\n\n\tif p == \"hdd\" then p = \"/\" end\n\tp = fs.combine(p, '')\n\tlocal drive = fs.getDrive(p)\n\n\tlocal function recurse(path)\n\t\tif fs.getDrive(path) == drive then\n\t\t\tif fs.isDir(path) then\n\t\t\t\tif path ~= p then\n\t\t\t\t\ttotal = total + 500\n\t\t\t\t\tdirs = dirs + 1\n\t\t\t\tend\n\t\t\t\tfor _, v in pairs(fs.list(path)) do\n\t\t\t\t\trecurse(fs.combine(path, v))\n\t\t\t\tend\n\t\t\telse\n\t\t\t\tlocal sz = fs.getSize(path)\n\t\t\t\tfiles = files + 1\n\t\t\t\tif drive == 'rom' then\n\t\t\t\t\ttotal = total + sz\n\t\t\t\telse\n\t\t\t\t\ttotal = total + math.max(500, sz)\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\n\trecurse(p)\n\n\tlocal info = {}\n\ttable.insert(info, { name = 'Type', value = peripheral.getType(drive) or drive })\n\ttable.insert(info, { name = 'Used', value = total })\n\ttable.insert(info, { name = 'Total', value = total + fs.getFreeSpace(p) })\n\ttable.insert(info, { name = 'Free', value = fs.getFreeSpace(p) })\n\ttable.insert(info, { })\n\ttable.insert(info, { name = 'Files', value = files })\n\ttable.insert(info, { name = 'Dirs', value = dirs })\n\treturn info, math.floor((total / (total + fs.getFreeSpace(p))) * 100)\nend\n\nfunction tab:updateInfo()\n\tlocal selected = self.drives:getSelected()\n\tlocal info, percent = getDriveInfo(selected and selected.name or self.drives.values[1].name)\n\tself.infos:setValues(info)\n\tself.progress.value = percent\n\tself.percentage.value = ('%#3d%%'):format(percent)\n\tself.icon.image = NFT.parse(NftImages[info[1].value] or NftImages.blank)\n\tself:draw()\nend\n\nfunction tab:updateDrives()\n\tlocal drives = getDrives()\n\tself.drives:setValues(drives)\nend\n\nfunction tab:enable()\n\tself:updateDrives()\n\tself:updateInfo()\n\tUI.Tab.enable(self)\n\tself.handler = Event.on({ 'disk', 'disk_eject' }, function()\n\t\tos.sleep(1)\n\t\ttab:updateDrives()\n\t\ttab:updateInfo()\n\t\ttab:sync()\n\tend)\nend\n\nfunction tab:disable()\n\tEvent.off(self.handler)\n\tUI.Tab.disable(self)\nend\n\nfunction tab:eventHandler(event)\n\tif event.type == 'grid_focus_row' then\n\t\tself:updateInfo()\n\telse\n\t\treturn UI.Tab.eventHandler(self, event)\n\tend\n\treturn true\nend\n\nreturn tab\n", "sys/apps/system/password.lua": "local Security = require('opus.security')\nlocal SHA      = require('opus.crypto.sha2')\nlocal UI       = require('opus.ui')\n\nreturn UI.Tab {\n\ttitle = 'Password',\n\tdescription = 'Wireless network password',\n\t[1] = UI.Window {\n\t\tx = 2, y = 2, ex = -2, ey = 4,\n\t},\n\tnewPass = UI.TextEntry {\n\t\tx = 3, ex = -3, y = 3,\n\t\tlimit = 32,\n\t\tmask = true,\n\t\tshadowText = 'new password',\n\t\taccelerators = {\n\t\t\tenter = 'new_password',\n\t\t},\n\t},\n\tbutton = UI.Button {\n\t\tx = -8, ex = -2, y = -2,\n\t\ttext = 'Apply',\n\t\tevent = 'update_password',\n\t},\n\tinfo = UI.TextArea {\n\t\tx = 2, ex = -2, y = 5, ey = -4,\n\t\tbackgroundColor = 'black',\n\t\ttextColor = 'yellow',\n\t\tinactive = true,\n\t\tmarginLeft = 1, marginRight = 1, marginTop = 1,\n\t\tvalue = 'Add a password to enable other computers to connect to this one.',\n\t},\n\teventHandler = function(self, event)\n\t\tif event.type == 'update_password' then\n\t\t\tif not self.newPass.value or #self.newPass.value == 0 then\n\t\t\t\tself:emit({ type = 'error_message', message = 'Invalid password' })\n\n\t\t\telse\n\t\t\t\tSecurity.updatePassword(SHA.compute(self.newPass.value))\n\t\t\t\tself:emit({ type = 'success_message', message = 'Password updated' })\n\t\t\tend\n\t\t\treturn true\n\t\tend\n\tend\n}\n", "sys/apps/system/cloud.lua": "local Ansi   = require('opus.ansi')\nlocal Config = require('opus.config')\nlocal UI     = require('opus.ui')\n\nif _G.http.websocket then\n\tlocal config = Config.load('cloud')\n\n\tlocal tab = UI.Tab {\n\t\ttitle = 'Cloud',\n\t\tdescription = 'Cloud Catcher options',\n\t\t[1] = UI.Window {\n\t\t\tx = 2, y = 2, ex = -2, ey = 4,\n\t\t},\n\t\tkey = UI.TextEntry {\n\t\t\tx = 3, ex = -3, y = 3,\n\t\t\tlimit = 32,\n\t\t\tvalue = config.key,\n\t\t\tshadowText = 'Cloud key',\n\t\t\taccelerators = {\n\t\t\t\tenter = 'update_key',\n\t\t\t},\n\t\t},\n\t\tbutton = UI.Button {\n\t\t\tx = -8, ex = -2, y = -2,\n\t\t\ttext = 'Apply',\n\t\t\tevent = 'update_key',\n\t\t},\n\t\tlabelText = UI.TextArea {\n\t\t\tx = 2, ex = -2, y = 5, ey = -4,\n\t\t\ttextColor = 'yellow',\n\t\t\tbackgroundColor = 'black',\n\t\t\tmarginLeft = 1, marginRight = 1, marginTop = 1,\n\t\t\tvalue = string.format(\n[[Use a non-changing cloud key. Note that only a single computer can use this session at one time.\nTo obtain a key, visit:\n%shttps://cloud-catcher.squiddev.cc%s then bookmark:\n%shttps://cloud-catcher.squiddev.cc/?id=KEY\n\t\t]],\n\t\t\tAnsi.white, Ansi.reset, Ansi.white),\n\t\t},\n\t}\n\n\tfunction tab:eventHandler(event)\n\t\tif event.type == 'update_key' then\n\t\t\tif self.key.value then\n\t\t\t\tconfig.key = self.key.value\n\t\t\telse\n\t\t\t\tconfig.key = nil\n\t\t\tend\n\t\t\tConfig.update('cloud', config)\n\t\t\tself:emit({ type = 'success_message', message = 'Updated' })\n\t\tend\n\tend\n\n\treturn tab\nend\n\n", "sys/apps/system/aliases.lua": "local Config = require('opus.config')\nlocal UI     = require('opus.ui')\n\nlocal kernel = _G.kernel\n\nlocal aliasTab = UI.Tab {\n\ttitle = 'Aliases',\n\tdescription = 'Shell aliases',\n\talias = UI.TextEntry {\n\t\tx = 2, y = 2, ex = -2,\n\t\tlimit = 32,\n\t\tshadowText = 'Alias',\n\t},\n\tpath = UI.TextEntry {\n\t\ty = 3, x = 2, ex = -2,\n\t\tshadowText = 'Program path',\n\t\taccelerators = {\n\t\t\tenter = 'new_alias',\n\t\t},\n\t},\n\tgrid = UI.Grid {\n\t\tx = 2, y = 5, ex = -2, ey = -2,\n\t\tsortColumn = 'alias',\n\t\tcolumns = {\n\t\t\t{ heading = 'Alias',   key = 'alias' },\n\t\t\t{ heading = 'Program', key = 'path'  },\n\t\t},\n\t\taccelerators = {\n\t\t\tdelete = 'delete_alias',\n\t\t},\n\t},\n}\n\nfunction aliasTab.grid:draw()\n\tself.values = { }\n\tlocal env = Config.load('shell')\n\tfor k in pairs(kernel.getShell().aliases()) do\n\t\tkernel.getShell().clearAlias(k)\n\tend\n\tfor k,v in pairs(env.aliases) do\n\t\ttable.insert(self.values, { alias = k, path = v })\n\t\tkernel.getShell().setAlias(k, v)\n\tend\n\tself:update()\n\tUI.Grid.draw(self)\nend\n\nfunction aliasTab:eventHandler(event)\n\tif event.type == 'delete_alias' then\n\t\tlocal env = Config.load('shell', { aliases = { } })\n\t\tenv.aliases[self.grid:getSelected().alias] = nil\n\t\tConfig.update('shell', env)\n\t\tself.grid:setIndex(self.grid:getIndex())\n\t\tself.grid:draw()\n\t\tself:emit({ type = 'success_message', message = 'Aliases updated' })\n\t\treturn true\n\n\telseif event.type == 'new_alias' then\n\t\tlocal env = Config.load('shell', { aliases = { } })\n\t\tenv.aliases[self.alias.value] = self.path.value\n\t\tConfig.update('shell', env)\n\t\tself.alias:reset()\n\t\tself.path:reset()\n\t\tself:draw()\n\t\tself:setFocus(self.alias)\n\t\tself:emit({ type = 'success_message', message = 'Aliases updated' })\n\t\treturn true\n\tend\nend\n\nreturn aliasTab\n", "sys/apps/system/trust.lua": "local UI   = require(\"opus.ui\")\nlocal Util = require(\"opus.util\")\nlocal SHA  = require('opus.crypto.sha2')\n\nlocal function split(s)\n  local b = \"\"\n  for i = 1, #s, 5 do\n    b = b .. s:sub(i, i+4)\n    if i ~= #s-4 then\n      b = b .. \"-\"\n    end\n  end\n  return b\nend\n\nreturn UI.Tab {\n  title = 'Trust',\n  description = 'Manage trusted devices',\n  grid = UI.Grid {\n    x = 2, y = 2, ex = -2, ey = -3,\n    autospace = true,\n    sortColumn = 'id',\n    columns = {\n      { heading = 'Computer ID', key = 'id'},\n      { heading = 'Identity', key = 'pkey'}\n    }\n  },\n  statusBar = UI.StatusBar { values = 'double-click to revoke trust' },\n  reload = function(self)\n    local values = {}\n    for k,v in pairs(Util.readTable('usr/.known_hosts') or {}) do\n      table.insert(values, {\n        id = k,\n        pkey = split(SHA.compute(v):sub(-20):upper()) -- Obfuscate private key for visual ident\n      })\n    end\n    self.grid:setValues(values)\n    self.grid:setIndex(1)\n  end,\n  enable = function(self)\n    self:reload()\n    UI.Tab.enable(self)\n  end,\n  eventHandler = function(self, event)\n    if event.type == 'grid_select' then\n      local hosts = Util.readTable('usr/.known_hosts')\n      hosts[event.selected.id] = nil\n      Util.writeTable('usr/.known_hosts', hosts)\n      self:reload()\n    else\n      return UI.Tab.eventHandler(self, event)\n    end\n    return true\n  end\n}", "sys/apps/system/kiosk.lua": "local UI = require('opus.ui')\n\nlocal colors     = _G.colors\nlocal peripheral = _G.peripheral\nlocal settings   = _G.settings\n\nreturn peripheral.find('monitor') and UI.Tab {\n\ttitle = 'Kiosk',\n\tdescription = 'Kiosk options',\n\tform = UI.Form {\n\t\tx = 2, y = 2, ex = -2, ey = 5,\n\t\tmanualControls = true,\n\t\tmonitor = UI.Chooser {\n\t\t\tformLabel = 'Monitor', formKey = 'monitor',\n\t\t},\n\t\ttextScale = UI.Chooser {\n\t\t\tformLabel = 'Font Size', formKey = 'textScale',\n\t\t\tnochoice = 'Small',\n\t\t\tchoices = {\n\t\t\t\t{ name = 'Small', value = '.5' },\n\t\t\t\t{ name = 'Large', value = '1'  },\n\t\t\t},\n\t\t\thelp = 'Adjust text scaling',\n\t\t},\n\t},\n\tlabelText = UI.TextArea {\n\t\tx = 2, ex = -2, y = 7, ey = -2,\n\t\ttextColor = colors.yellow,\n\t\tbackgroundColor = colors.black,\n\t\tvalue = 'Settings apply to kiosk mode selected during startup'\n\t},\n\tenable = function(self)\n\t\tlocal choices = { }\n\n\t\tperipheral.find('monitor', function(side)\n\t\t\ttable.insert(choices, { name = side, value = side })\n\t\tend)\n\n\t\tself.form.monitor.choices = choices\n\t\tself.form.monitor.value = settings.get('kiosk.monitor')\n\n\t\tself.form.textScale.value = settings.get('kiosk.textscale')\n\n\t\tUI.Tab.enable(self)\n\tend,\n\teventHandler = function(self, event)\n\t\tif event.type == 'choice_change' then\n\t\t\tif self.form.monitor.value then\n\t\t\t\tsettings.set('kiosk.monitor', self.form.monitor.value)\n\t\t\tend\n\t\t\tif self.form.textScale.value then\n\t\t\t\tsettings.set('kiosk.textscale', self.form.textScale.value)\n\t\t\tend\n\t\t\tsettings.save('.settings')\n\t\tend\n\tend\n}\n", "sys/apps/system/network.lua": "local Ansi   = require('opus.ansi')\nlocal Config = require('opus.config')\nlocal UI     = require('opus.ui')\n\nlocal colors = _G.colors\nlocal device = _G.device\n\nreturn UI.Tab {\n\ttitle = 'Network',\n\tdescription = 'Networking options',\n\tinfo = UI.TextArea {\n\t\tx = 2, y = 5, ex = -2, ey = -2,\n\t\tbackgroundColor = colors.black,\n\t\tmarginLeft = 1, marginRight = 1, marginTop = 1,\n\t\tvalue = string.format(\n[[%sSet the primary modem used for wireless communications.%s\n\nReboot to take effect.]], Ansi.yellow, Ansi.reset)\n\t},\n\t[1] = UI.Window {\n\t\tx = 2, y = 2, ex = -2, ey = 4,\n\t},\n\tlabel = UI.Text {\n\t\tx = 3, y = 3,\n\t\tvalue = 'Modem',\n\t},\n\tmodem = UI.Chooser {\n\t\tx = 10, ex = -3, y = 3,\n\t\tnochoice = 'auto',\n\t},\n\tenable = function(self)\n\t\tlocal width = 7\n\t\tlocal choices = {\n\t\t\t{ name = 'auto',    value = 'auto' },\n\t\t\t{ name = 'disable', value = 'none' },\n\t\t}\n\n\t\tfor k,v in pairs(device) do\n\t\t\tif v.isWireless and v.isWireless() and k ~= 'wireless_modem' then\n\t\t\t\ttable.insert(choices, { name = k, value = v.name })\n\t\t\t\twidth = math.max(width, #k)\n\t\t\tend\n\t\tend\n\n\t\tself.modem.choices = choices\n\t\t--self.modem.width = width + 4\n\n\t\tlocal config = Config.load('os')\n\t\tself.modem.value = config.wirelessModem or 'auto'\n\n\t\tUI.Tab.enable(self)\n\tend,\n\teventHandler = function(self, event)\n\t\tif event.type == 'choice_change' then\n\t\t\tlocal config = Config.load('os')\n\t\t\tconfig.wirelessModem = self.modem.value\n\t\t\tConfig.update('os', config)\n\t\t\tself:emit({ type = 'success_message', message = 'reboot to take effect' })\n\t\t\treturn true\n\t\tend\n\tend\n}\n", "sys/apps/system/requires.lua": "local Config = require('opus.config')\nlocal UI     = require('opus.ui')\nlocal Util   = require('opus.util')\n\nlocal tab = UI.Tab {\n\ttitle = 'Requires',\n\tdescription = 'Require path',\n\ttabClose = true,\n\tentry = UI.TextEntry {\n\t\tx = 2, y = 2, ex = -2,\n\t\tshadowText = 'Enter new require path',\n\t\taccelerators = {\n\t\t\tenter = 'update_path',\n\t\t},\n\t\thelp = 'add a new path (reboot required)',\n\t},\n\tgrid = UI.Grid {\n\t\ty = 4, ey = -3,\n\t\tdisableHeader = true,\n\t\tcolumns = { { key = 'value' } },\n\t\tautospace = true,\n\t\tsortColumn = 'index',\n\t\thelp = 'double-click to remove, shift-arrow to move',\n\t\taccelerators = {\n\t\t\tdelete = 'remove',\n\t\t},\n\t},\n\tstatusBar = UI.StatusBar { },\n\taccelerators = {\n\t\t[ 'shift-up' ] = 'move_up',\n\t\t[ 'shift-down' ] = 'move_down',\n\t},\n}\n\nfunction tab:updateList(lua_path)\n\tself.grid.values = { }\n\tfor k,v in ipairs(Util.split(lua_path, '(.-);')) do\n\t\ttable.insert(self.grid.values, { index = k, value = v })\n\tend\n\tself.grid:update()\nend\n\nfunction tab:enable()\n\tlocal env = Config.load('shell')\n\tself:updateList(env.lua_path)\n\tUI.Tab.enable(self)\nend\n\nfunction tab:save()\n\tlocal t = { }\n\tfor _, v in ipairs(self.grid.values) do\n\t\ttable.insert(t, v.value)\n\tend\n\tlocal env = Config.load('shell')\n\tenv.lua_path = table.concat(t, ';')\n\tself:updateList(env.lua_path)\n\tConfig.update('shell', env)\nend\n\nfunction tab:eventHandler(event)\n\tif event.type == 'update_path' then\n\t\ttable.insert(self.grid.values, {\n\t\t\tvalue = self.entry.value,\n\t\t})\n\t\tself:save()\n\t\tself.entry:reset()\n\t\tself.entry:draw()\n\t\tself.grid:draw()\n\t\treturn true\n\n\telseif event.type == 'grid_select' or event.type == 'remove' then\n\t\tlocal selected = self.grid:getSelected()\n\t\tif selected then\n\t\t\ttable.remove(self.grid.values, selected.index)\n\t\t\tself:save()\n\t\t\tself.grid:draw()\n\t\tend\n\n\telseif event.type == 'focus_change' then\n\t\tself.statusBar:setStatus(event.focused.help)\n\n\telseif event.type == 'move_up' then\n\t\tlocal entry = self.grid:getSelected()\n\t\tif entry.index > 1 then\n\t\t\ttable.insert(self.grid.values, entry.index - 1, table.remove(self.grid.values, entry.index))\n\t\t\tself.grid:setIndex(entry.index - 1)\n\t\t\tself:save()\n\t\t\tself.grid:draw()\n\t\tend\n\n\telseif event.type == 'move_down' then\n\t\tlocal entry = self.grid:getSelected()\n\t\tif entry.index < #self.grid.values then\n\t\t\ttable.insert(self.grid.values, entry.index + 1, table.remove(self.grid.values, entry.index))\n\t\t\tself.grid:setIndex(entry.index + 1)\n\t\t\tself:save()\n\t\t\tself.grid:draw()\n\t\tend\n\tend\nend\n\n--this needs rework - see 4.user.lua\n--return tab\n", "sys/help/Overview.txt": "Overview is the main application launcher.\n\nShortcut keys\n=============\n * s: Shell\n * l: Lua application\n * f: Files\n * e: Edit an application (or right-click)\n * n: Network\n * control-n: Add a new application\n * delete: Delete an application\n\nAdding a new application\n========================\nThe run entry can be either a disk file or a URL.\nIcons must be in NFT format with a height of 3 and a width of 3 to 8 characters. Magenta is used for transparency.", "sys/help/Networking.txt": "Wireless Networking\n===================\nTo establish one-way trust between two computers with modems, run the following in a shell prompt:\n\nOn the target computer, run:\n> password\n\nOn the source computer, run:\n> trust <target computer ID>", "sys/help/CloudCatcher.txt": "Cloud Catcher is a web terminal for ComputerCraft, allowing you to interact with any in-game computer in the browser, as well as edit files remotely!\n\nTo get started, visit https://cloud-catcher.squiddev.cc for a session key.\n\nWithin Files, press 'c' to edit a file using Cloud Catcher.\n", "sys/help/pastebin.txt": "pastebin is a program for uploading files to and downloading files from pastebin.com. This is useful for sharing programs with other players.\nThe HTTP API must be enabled in ComputerCraft.cfg to use this program.\n\nex:\n\"pastebin put foo\" will upload the file \"foo\" to pastebin.com, and print the URL.\n\"pastebin get xq5gc7LB foo\" will download the file from the URL http://pastebin.com/xq5gc7LB, and save it as \"foo\".\n\"pastebin run CxaWmPrX\" will download the file from the URL http://pastebin.com/CxaWmPrX, and immediately run it.\n\nFunctions in the pastebin API:\npastebin.get( code, filepath )\npastebin.put( filepath )\npastebin.download( code )\npastebin.upload( pastename, text )\npastebin.parseCode( code )\n\n", "sys/help/Packages.txt": "Opus applications are grouped into packages with a common theme.\n\nTo install a package, use either the System -> Packages program or the package command line program.\n\nShell usage:\n\n> package list\n> package install <name>\n> package update <name>\n> package updateall\n> package uninstall <name>\n\nPackage definitions are located in usr/config/packages. This file can be modified to add custom packages.\n", "sys/help/Opus.txt": "Shortcut Keys\n=============\n * Control-o: Show the Overview\n * Control-tab: Cycle to next tab\n * Control-shift-tab: Cycle to previous tab\n * Control-d: Show/toggle logging screen\n * Control-c: Copy (in most applications)\n * Control-shift-v: Paste from internal clipboard\n * Control-shift-click: Open the clicked UI element in Lua\n\nRunning Custom Programs\n=======================\nTo create a program that runs at startup, create a file in /usr/autorun to start the program. Example:\n\nIn file: /usr/autorun/startup.lua\nshell.openForegroundTab('myprogram')\n\nThere are 3 different ways to open tabs:\n\n * shell.openTab : background tab\n * shell.openForegroundTab : focused tab\n * shell.openHiddenTab : appears only in the Tasks application\n\nCopy / Paste\n============\nOpus can paste from both the system clipboard and the internal clipboard.\n\n * control-v: for normal clipboard\n * control-shift-v: for internal clipboard\n"}}